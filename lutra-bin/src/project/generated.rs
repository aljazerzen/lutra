//# Generated by lutra-codegen

pub mod br {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Program {
        pub externals: crate::vec::Vec<ExternalSymbol>,
        pub main: Expr,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct ExternalSymbol {
        pub id: crate::string::String,
        pub layout_args: crate::vec::Vec<u32>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Expr {
        pub kind: ExprKind,
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum ExprKind {
        Pointer(Sid),
        Literal(super::ir::Literal),
        Call(crate::boxed::Box<Call>),
        Function(crate::boxed::Box<Function>),
        Tuple(crate::boxed::Box<Tuple>),
        Array(crate::boxed::Box<Array>),
        TupleLookup(crate::boxed::Box<TupleLookup>),
        Binding(crate::boxed::Box<Binding>),
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Sid(pub u32);

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Call {
        pub function: Expr,
        pub args: crate::vec::Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Function {
        pub symbol_ns: Sid,
        pub body: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Tuple {
        pub fields: crate::vec::Vec<Expr>,
        pub field_layouts: crate::vec::Vec<TyLayout>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Array {
        pub item_layout: TyLayout,
        pub items: crate::vec::Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleLookup {
        pub base: Expr,
        pub offset: u32,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Binding {
        pub symbol: Sid,
        pub expr: Expr,
        pub main: Expr,
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub struct TyLayout {
        pub head_size: u32,
        pub body_ptrs: crate::vec::Vec<u32>,
    }

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::bytes::BufMut;
        use crate::ReaderExt;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let externals = self.externals.encode_head(buf);
                let main = self.main.encode_head(buf);
                ProgramHeadPtr { externals, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.externals.encode_body(head.externals, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramHeadPtr {
            externals: <crate::vec::Vec<super::ExternalSymbol> as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let externals = crate::vec::Vec::<super::ExternalSymbol>::decode(buf.skip(0))?;
                let main = super::Expr::decode(buf.skip(8))?;
                Ok(Program { externals, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ExternalSymbol {
            type HeadPtr = ExternalSymbolHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                let layout_args = self.layout_args.encode_head(buf);
                ExternalSymbolHeadPtr { id, layout_args }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
                self.layout_args.encode_body(head.layout_args, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExternalSymbolHeadPtr {
            id: <crate::string::String as crate::Encode>::HeadPtr,
            layout_args: <crate::vec::Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ExternalSymbol {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for ExternalSymbol {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = crate::string::String::decode(buf.skip(0))?;
                let layout_args = crate::vec::Vec::<u32>::decode(buf.skip(8))?;
                Ok(ExternalSymbol { id, layout_args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Expr {
            type HeadPtr = ExprHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let kind = self.kind.encode_head(buf);
                ExprHeadPtr { kind }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.kind.encode_body(head.kind, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExprHeadPtr {
            kind: <super::ExprKind as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Expr {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Expr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::ExprKind::decode(buf.skip(0))?;
                Ok(Expr { kind })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExprKind {
            type HeadPtr = ExprKindHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> ExprKindHeadPtr {
                match self {
                    Self::Pointer(inner) => {
                        w.put_slice(&[0]);
                        let inner_head_ptr = inner.encode_head(w);
                        let r = ExprKindHeadPtr::Pointer(inner_head_ptr);
                        r
                    }
                    Self::Literal(_) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Literal(head_ptr);
                        r
                    }
                    Self::Call(_) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Call(head_ptr);
                        r
                    }
                    Self::Function(_) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Tuple(_) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(_) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::TupleLookup(_) => {
                        w.put_slice(&[6]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::TupleLookup(head_ptr);
                        r
                    }
                    Self::Binding(_) => {
                        w.put_slice(&[7]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Binding(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: ExprKindHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Pointer(inner) => {
                        let ExprKindHeadPtr::Pointer(inner_head_ptr) = head else {
                            unreachable!()
                        };
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Literal(inner) => {
                        let ExprKindHeadPtr::Literal(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Call(inner) => {
                        let ExprKindHeadPtr::Call(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Function(inner) => {
                        let ExprKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Tuple(inner) => {
                        let ExprKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Array(inner) => {
                        let ExprKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::TupleLookup(inner) => {
                        let ExprKindHeadPtr::TupleLookup(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Binding(inner) => {
                        let ExprKindHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExprKindHeadPtr {
            None,
            Pointer(<super::Sid as crate::Encode>::HeadPtr),
            Literal(crate::ReversePointer),
            Call(crate::ReversePointer),
            Function(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            TupleLookup(crate::ReversePointer),
            Binding(crate::ReversePointer),
        }
        impl crate::Layout for ExprKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExprKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let inner = super::Sid::decode(buf)?;
                        ExprKind::Pointer(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::super::ir::Literal::decode(buf.skip(offset as usize))?;
                        ExprKind::Literal(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Call::decode(buf.skip(offset as usize))?;
                        ExprKind::Call(crate::boxed::Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Function::decode(buf.skip(offset as usize))?;
                        ExprKind::Function(crate::boxed::Box::new(inner))
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Tuple::decode(buf.skip(offset as usize))?;
                        ExprKind::Tuple(crate::boxed::Box::new(inner))
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Array::decode(buf.skip(offset as usize))?;
                        ExprKind::Array(crate::boxed::Box::new(inner))
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TupleLookup::decode(buf.skip(offset as usize))?;
                        ExprKind::TupleLookup(crate::boxed::Box::new(inner))
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Binding::decode(buf.skip(offset as usize))?;
                        ExprKind::Binding(crate::boxed::Box::new(inner))
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        impl crate::Encode for Sid {
            type HeadPtr = ();
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) {
                self.0.encode_head(buf)
            }
            fn encode_body(&self, _: (), _: &mut crate::bytes::BytesMut) {}
        }
        impl crate::Layout for Sid {
            fn head_size() -> usize {
                32
            }
        }

        impl crate::Decode for Sid {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                Ok(Self(u32::decode(buf)?))
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Call {
            type HeadPtr = CallHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let function = self.function.encode_head(buf);
                let args = self.args.encode_head(buf);
                CallHeadPtr { function, args }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.function.encode_body(head.function, buf);
                self.args.encode_body(head.args, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct CallHeadPtr {
            function: <super::Expr as crate::Encode>::HeadPtr,
            args: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Call {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for Call {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function = super::Expr::decode(buf.skip(0))?;
                let args = crate::vec::Vec::<super::Expr>::decode(buf.skip(5))?;
                Ok(Call { function, args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Function {
            type HeadPtr = FunctionHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let symbol_ns = self.symbol_ns.encode_head(buf);
                let body = self.body.encode_head(buf);
                FunctionHeadPtr { symbol_ns, body }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.symbol_ns.encode_body(head.symbol_ns, buf);
                self.body.encode_body(head.body, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct FunctionHeadPtr {
            symbol_ns: <super::Sid as crate::Encode>::HeadPtr,
            body: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Function {
            fn head_size() -> usize {
                72
            }
        }

        impl crate::Decode for Function {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let symbol_ns = super::Sid::decode(buf.skip(0))?;
                let body = super::Expr::decode(buf.skip(4))?;
                Ok(Function { symbol_ns, body })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Tuple {
            type HeadPtr = TupleHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let fields = self.fields.encode_head(buf);
                let field_layouts = self.field_layouts.encode_head(buf);
                TupleHeadPtr {
                    fields,
                    field_layouts,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.fields.encode_body(head.fields, buf);
                self.field_layouts.encode_body(head.field_layouts, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleHeadPtr {
            fields: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
            field_layouts: <crate::vec::Vec<super::TyLayout> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Tuple {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for Tuple {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let fields = crate::vec::Vec::<super::Expr>::decode(buf.skip(0))?;
                let field_layouts = crate::vec::Vec::<super::TyLayout>::decode(buf.skip(8))?;
                Ok(Tuple {
                    fields,
                    field_layouts,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Array {
            type HeadPtr = ArrayHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let item_layout = self.item_layout.encode_head(buf);
                let items = self.items.encode_head(buf);
                ArrayHeadPtr { item_layout, items }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.item_layout.encode_body(head.item_layout, buf);
                self.items.encode_body(head.items, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ArrayHeadPtr {
            item_layout: <super::TyLayout as crate::Encode>::HeadPtr,
            items: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Array {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Array {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let item_layout = super::TyLayout::decode(buf.skip(0))?;
                let items = crate::vec::Vec::<super::Expr>::decode(buf.skip(12))?;
                Ok(Array { item_layout, items })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleLookup {
            type HeadPtr = TupleLookupHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let base = self.base.encode_head(buf);
                let offset = self.offset.encode_head(buf);
                TupleLookupHeadPtr { base, offset }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.base.encode_body(head.base, buf);
                self.offset.encode_body(head.offset, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleLookupHeadPtr {
            base: <super::Expr as crate::Encode>::HeadPtr,
            offset: <u32 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleLookup {
            fn head_size() -> usize {
                72
            }
        }

        impl crate::Decode for TupleLookup {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let base = super::Expr::decode(buf.skip(0))?;
                let offset = u32::decode(buf.skip(5))?;
                Ok(TupleLookup { base, offset })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Binding {
            type HeadPtr = BindingHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let symbol = self.symbol.encode_head(buf);
                let expr = self.expr.encode_head(buf);
                let main = self.main.encode_head(buf);
                BindingHeadPtr { symbol, expr, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.symbol.encode_body(head.symbol, buf);
                self.expr.encode_body(head.expr, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BindingHeadPtr {
            symbol: <super::Sid as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Binding {
            fn head_size() -> usize {
                112
            }
        }

        impl crate::Decode for Binding {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let symbol = super::Sid::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(4))?;
                let main = super::Expr::decode(buf.skip(9))?;
                Ok(Binding { symbol, expr, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyLayout {
            type HeadPtr = TyLayoutHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let head_size = self.head_size.encode_head(buf);
                let body_ptrs = self.body_ptrs.encode_head(buf);
                TyLayoutHeadPtr {
                    head_size,
                    body_ptrs,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.head_size.encode_body(head.head_size, buf);
                self.body_ptrs.encode_body(head.body_ptrs, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyLayoutHeadPtr {
            head_size: <u32 as crate::Encode>::HeadPtr,
            body_ptrs: <crate::vec::Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyLayout {
            fn head_size() -> usize {
                96
            }
        }

        impl crate::Decode for TyLayout {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let head_size = u32::decode(buf.skip(0))?;
                let body_ptrs = crate::vec::Vec::<u32>::decode(buf.skip(4))?;
                Ok(TyLayout {
                    head_size,
                    body_ptrs,
                })
            }
        }
    }
}

pub mod ir {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Program {
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Expr {
        pub kind: ExprKind,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum ExprKind {
        Pointer(Pointer),
        Literal(Literal),
        Call(crate::boxed::Box<Call>),
        Function(crate::boxed::Box<Function>),
        Tuple(crate::vec::Vec<Expr>),
        Array(crate::vec::Vec<Expr>),
        TupleLookup(crate::boxed::Box<TupleLookup>),
        Binding(crate::boxed::Box<Binding>),
        RemoteCall(crate::boxed::Box<RemoteCall>),
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Pointer {
        External(ExternalPtr),
        Binding(u32),
        Parameter(ParameterPtr),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ExternalPtr {
        pub id: crate::string::String,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ParameterPtr {
        pub function_id: u32,
        pub param_position: u8,
    }

    #[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Literal {
        Int(i64),
        Float(f64),
        Bool(bool),
        Text(crate::string::String),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Call {
        pub function: Expr,
        pub args: crate::vec::Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Function {
        pub id: u32,
        pub body: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleLookup {
        pub base: Expr,
        pub position: u16,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Binding {
        pub id: u32,
        pub expr: Expr,
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct RemoteCall {
        pub remote_id: crate::string::String,
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Ty {
        pub kind: TyKind,
        pub layout: core::option::Option<TyLayout>,
        pub name: core::option::Option<crate::string::String>,
    }

    #[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum TyKind {
        Primitive(PrimitiveSet),
        Tuple(crate::vec::Vec<TyTupleField>),
        Array(crate::boxed::Box<Ty>),
        Enum(crate::vec::Vec<TyEnumVariant>),
        Function(crate::boxed::Box<TyFunction>),
        Ident(Path),
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimitiveSet {
        bool,
        int8,
        int16,
        int32,
        int64,
        uint8,
        uint16,
        uint32,
        uint64,
        float32,
        float64,
        text,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyTupleField {
        pub name: core::option::Option<crate::string::String>,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyEnumVariant {
        pub name: crate::string::String,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub struct TyLayout {
        pub head_size: u32,
        pub body_ptrs: crate::vec::Vec<u32>,
        pub variants_recursive: crate::vec::Vec<u16>,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyFunction {
        pub params: crate::vec::Vec<Ty>,
        pub body: Ty,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct Path(pub crate::vec::Vec<crate::string::String>);

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::bytes::BufMut;
        use crate::ReaderExt;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let main = self.main.encode_head(buf);
                ProgramHeadPtr { main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramHeadPtr {
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let main = super::Expr::decode(buf.skip(0))?;
                Ok(Program { main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Expr {
            type HeadPtr = ExprHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let kind = self.kind.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                ExprHeadPtr { kind, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.kind.encode_body(head.kind, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExprHeadPtr {
            kind: <super::ExprKind as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Expr {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Expr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::ExprKind::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(5))?;
                Ok(Expr { kind, ty })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExprKind {
            type HeadPtr = ExprKindHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> ExprKindHeadPtr {
                match self {
                    Self::Pointer(_) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Pointer(head_ptr);
                        r
                    }
                    Self::Literal(_) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Literal(head_ptr);
                        r
                    }
                    Self::Call(_) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Call(head_ptr);
                        r
                    }
                    Self::Function(_) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Tuple(_) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(_) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::TupleLookup(_) => {
                        w.put_slice(&[6]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::TupleLookup(head_ptr);
                        r
                    }
                    Self::Binding(_) => {
                        w.put_slice(&[7]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Binding(head_ptr);
                        r
                    }
                    Self::RemoteCall(_) => {
                        w.put_slice(&[8]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::RemoteCall(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: ExprKindHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Pointer(inner) => {
                        let ExprKindHeadPtr::Pointer(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Literal(inner) => {
                        let ExprKindHeadPtr::Literal(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Call(inner) => {
                        let ExprKindHeadPtr::Call(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Function(inner) => {
                        let ExprKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Tuple(inner) => {
                        let ExprKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Array(inner) => {
                        let ExprKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::TupleLookup(inner) => {
                        let ExprKindHeadPtr::TupleLookup(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Binding(inner) => {
                        let ExprKindHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::RemoteCall(inner) => {
                        let ExprKindHeadPtr::RemoteCall(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExprKindHeadPtr {
            None,
            Pointer(crate::ReversePointer),
            Literal(crate::ReversePointer),
            Call(crate::ReversePointer),
            Function(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            TupleLookup(crate::ReversePointer),
            Binding(crate::ReversePointer),
            RemoteCall(crate::ReversePointer),
        }
        impl crate::Layout for ExprKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExprKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Pointer::decode(buf.skip(offset as usize))?;
                        ExprKind::Pointer(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Literal::decode(buf.skip(offset as usize))?;
                        ExprKind::Literal(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Call::decode(buf.skip(offset as usize))?;
                        ExprKind::Call(crate::boxed::Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Function::decode(buf.skip(offset as usize))?;
                        ExprKind::Function(crate::boxed::Box::new(inner))
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner =
                            crate::vec::Vec::<super::Expr>::decode(buf.skip(offset as usize))?;
                        ExprKind::Tuple(inner)
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner =
                            crate::vec::Vec::<super::Expr>::decode(buf.skip(offset as usize))?;
                        ExprKind::Array(inner)
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TupleLookup::decode(buf.skip(offset as usize))?;
                        ExprKind::TupleLookup(crate::boxed::Box::new(inner))
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Binding::decode(buf.skip(offset as usize))?;
                        ExprKind::Binding(crate::boxed::Box::new(inner))
                    }
                    8 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::RemoteCall::decode(buf.skip(offset as usize))?;
                        ExprKind::RemoteCall(crate::boxed::Box::new(inner))
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Pointer {
            type HeadPtr = PointerHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> PointerHeadPtr {
                match self {
                    Self::External(_) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::External(head_ptr);
                        r
                    }
                    Self::Binding(inner) => {
                        w.put_slice(&[1]);
                        let inner_head_ptr = inner.encode_head(w);
                        let r = PointerHeadPtr::Binding(inner_head_ptr);
                        r
                    }
                    Self::Parameter(_) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::Parameter(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: PointerHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::External(inner) => {
                        let PointerHeadPtr::External(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Binding(inner) => {
                        let PointerHeadPtr::Binding(inner_head_ptr) = head else {
                            unreachable!()
                        };
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Parameter(inner) => {
                        let PointerHeadPtr::Parameter(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum PointerHeadPtr {
            None,
            External(crate::ReversePointer),
            Binding(<u32 as crate::Encode>::HeadPtr),
            Parameter(crate::ReversePointer),
        }
        impl crate::Layout for Pointer {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Pointer {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::ExternalPtr::decode(buf.skip(offset as usize))?;
                        Pointer::External(inner)
                    }
                    1 => {
                        let inner = u32::decode(buf)?;
                        Pointer::Binding(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::ParameterPtr::decode(buf.skip(offset as usize))?;
                        Pointer::Parameter(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ExternalPtr {
            type HeadPtr = ExternalPtrHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                ExternalPtrHeadPtr { id }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExternalPtrHeadPtr {
            id: <crate::string::String as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ExternalPtr {
            fn head_size() -> usize {
                64
            }
        }

        impl crate::Decode for ExternalPtr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = crate::string::String::decode(buf.skip(0))?;
                Ok(ExternalPtr { id })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ParameterPtr {
            type HeadPtr = ParameterPtrHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let function_id = self.function_id.encode_head(buf);
                let param_position = self.param_position.encode_head(buf);
                ParameterPtrHeadPtr {
                    function_id,
                    param_position,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.function_id.encode_body(head.function_id, buf);
                self.param_position.encode_body(head.param_position, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ParameterPtrHeadPtr {
            function_id: <u32 as crate::Encode>::HeadPtr,
            param_position: <u8 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ParameterPtr {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ParameterPtr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function_id = u32::decode(buf.skip(0))?;
                let param_position = u8::decode(buf.skip(4))?;
                Ok(ParameterPtr {
                    function_id,
                    param_position,
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Literal {
            type HeadPtr = LiteralHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> LiteralHeadPtr {
                match self {
                    Self::Int(_) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::Int(head_ptr);
                        r
                    }
                    Self::Float(_) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::Float(head_ptr);
                        r
                    }
                    Self::Bool(inner) => {
                        w.put_slice(&[2]);
                        let inner_head_ptr = inner.encode_head(w);
                        let r = LiteralHeadPtr::Bool(inner_head_ptr);
                        w.put_bytes(0, 3);
                        r
                    }
                    Self::Text(_) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::Text(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: LiteralHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Int(inner) => {
                        let LiteralHeadPtr::Int(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Float(inner) => {
                        let LiteralHeadPtr::Float(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Bool(inner) => {
                        let LiteralHeadPtr::Bool(inner_head_ptr) = head else {
                            unreachable!()
                        };
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Text(inner) => {
                        let LiteralHeadPtr::Text(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum LiteralHeadPtr {
            None,
            Int(crate::ReversePointer),
            Float(crate::ReversePointer),
            Bool(<bool as crate::Encode>::HeadPtr),
            Text(crate::ReversePointer),
        }
        impl crate::Layout for Literal {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Literal {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = i64::decode(buf.skip(offset as usize))?;
                        Literal::Int(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = f64::decode(buf.skip(offset as usize))?;
                        Literal::Float(inner)
                    }
                    2 => {
                        let inner = bool::decode(buf)?;
                        Literal::Bool(inner)
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::string::String::decode(buf.skip(offset as usize))?;
                        Literal::Text(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Call {
            type HeadPtr = CallHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let function = self.function.encode_head(buf);
                let args = self.args.encode_head(buf);
                CallHeadPtr { function, args }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.function.encode_body(head.function, buf);
                self.args.encode_body(head.args, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct CallHeadPtr {
            function: <super::Expr as crate::Encode>::HeadPtr,
            args: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Call {
            fn head_size() -> usize {
                224
            }
        }

        impl crate::Decode for Call {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function = super::Expr::decode(buf.skip(0))?;
                let args = crate::vec::Vec::<super::Expr>::decode(buf.skip(20))?;
                Ok(Call { function, args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Function {
            type HeadPtr = FunctionHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                let body = self.body.encode_head(buf);
                FunctionHeadPtr { id, body }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
                self.body.encode_body(head.body, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct FunctionHeadPtr {
            id: <u32 as crate::Encode>::HeadPtr,
            body: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Function {
            fn head_size() -> usize {
                192
            }
        }

        impl crate::Decode for Function {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = u32::decode(buf.skip(0))?;
                let body = super::Expr::decode(buf.skip(4))?;
                Ok(Function { id, body })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleLookup {
            type HeadPtr = TupleLookupHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let base = self.base.encode_head(buf);
                let position = self.position.encode_head(buf);
                TupleLookupHeadPtr { base, position }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.base.encode_body(head.base, buf);
                self.position.encode_body(head.position, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleLookupHeadPtr {
            base: <super::Expr as crate::Encode>::HeadPtr,
            position: <u16 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleLookup {
            fn head_size() -> usize {
                176
            }
        }

        impl crate::Decode for TupleLookup {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let base = super::Expr::decode(buf.skip(0))?;
                let position = u16::decode(buf.skip(20))?;
                Ok(TupleLookup { base, position })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Binding {
            type HeadPtr = BindingHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                let expr = self.expr.encode_head(buf);
                let main = self.main.encode_head(buf);
                BindingHeadPtr { id, expr, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
                self.expr.encode_body(head.expr, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BindingHeadPtr {
            id: <u32 as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Binding {
            fn head_size() -> usize {
                352
            }
        }

        impl crate::Decode for Binding {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = u32::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(4))?;
                let main = super::Expr::decode(buf.skip(24))?;
                Ok(Binding { id, expr, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for RemoteCall {
            type HeadPtr = RemoteCallHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let remote_id = self.remote_id.encode_head(buf);
                let main = self.main.encode_head(buf);
                RemoteCallHeadPtr { remote_id, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.remote_id.encode_body(head.remote_id, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct RemoteCallHeadPtr {
            remote_id: <crate::string::String as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for RemoteCall {
            fn head_size() -> usize {
                224
            }
        }

        impl crate::Decode for RemoteCall {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let remote_id = crate::string::String::decode(buf.skip(0))?;
                let main = super::Expr::decode(buf.skip(8))?;
                Ok(RemoteCall { remote_id, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Ty {
            type HeadPtr = TyHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let kind = self.kind.encode_head(buf);
                let layout = self.layout.encode_head(buf);
                let name = self.name.encode_head(buf);
                TyHeadPtr { kind, layout, name }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.kind.encode_body(head.kind, buf);
                self.layout.encode_body(head.layout, buf);
                self.name.encode_body(head.name, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyHeadPtr {
            kind: <super::TyKind as crate::Encode>::HeadPtr,
            layout: <core::option::Option<super::TyLayout> as crate::Encode>::HeadPtr,
            name: <core::option::Option<crate::string::String> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Ty {
            fn head_size() -> usize {
                120
            }
        }

        impl crate::Decode for Ty {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::TyKind::decode(buf.skip(0))?;
                let layout = core::option::Option::<super::TyLayout>::decode(buf.skip(5))?;
                let name = core::option::Option::<crate::string::String>::decode(buf.skip(10))?;
                Ok(Ty { kind, layout, name })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for TyKind {
            type HeadPtr = TyKindHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> TyKindHeadPtr {
                match self {
                    Self::Primitive(_) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Primitive(head_ptr);
                        r
                    }
                    Self::Tuple(_) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(_) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::Enum(_) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Enum(head_ptr);
                        r
                    }
                    Self::Function(_) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Ident(_) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Ident(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: TyKindHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Primitive(inner) => {
                        let TyKindHeadPtr::Primitive(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Tuple(inner) => {
                        let TyKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Array(inner) => {
                        let TyKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Enum(inner) => {
                        let TyKindHeadPtr::Enum(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Function(inner) => {
                        let TyKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Ident(inner) => {
                        let TyKindHeadPtr::Ident(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum TyKindHeadPtr {
            None,
            Primitive(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            Enum(crate::ReversePointer),
            Function(crate::ReversePointer),
            Ident(crate::ReversePointer),
        }
        impl crate::Layout for TyKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for TyKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::PrimitiveSet::decode(buf.skip(offset as usize))?;
                        TyKind::Primitive(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::TyTupleField>::decode(
                            buf.skip(offset as usize),
                        )?;
                        TyKind::Tuple(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Ty::decode(buf.skip(offset as usize))?;
                        TyKind::Array(crate::boxed::Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::TyEnumVariant>::decode(
                            buf.skip(offset as usize),
                        )?;
                        TyKind::Enum(inner)
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TyFunction::decode(buf.skip(offset as usize))?;
                        TyKind::Function(crate::boxed::Box::new(inner))
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Path::decode(buf.skip(offset as usize))?;
                        TyKind::Ident(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for PrimitiveSet {
            type HeadPtr = ();
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> () {
                match self {
                    Self::bool => {
                        w.put_slice(&[0]);
                    }
                    Self::int8 => {
                        w.put_slice(&[1]);
                    }
                    Self::int16 => {
                        w.put_slice(&[2]);
                    }
                    Self::int32 => {
                        w.put_slice(&[3]);
                    }
                    Self::int64 => {
                        w.put_slice(&[4]);
                    }
                    Self::uint8 => {
                        w.put_slice(&[5]);
                    }
                    Self::uint16 => {
                        w.put_slice(&[6]);
                    }
                    Self::uint32 => {
                        w.put_slice(&[7]);
                    }
                    Self::uint64 => {
                        w.put_slice(&[8]);
                    }
                    Self::float32 => {
                        w.put_slice(&[9]);
                    }
                    Self::float64 => {
                        w.put_slice(&[10]);
                    }
                    Self::text => {
                        w.put_slice(&[11]);
                    }
                }
            }
            fn encode_body(&self, head: (), w: &mut crate::bytes::BytesMut) {}
        }
        impl crate::Layout for PrimitiveSet {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for PrimitiveSet {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                Ok(match tag {
                    0 => PrimitiveSet::bool,
                    1 => PrimitiveSet::int8,
                    2 => PrimitiveSet::int16,
                    3 => PrimitiveSet::int32,
                    4 => PrimitiveSet::int64,
                    5 => PrimitiveSet::uint8,
                    6 => PrimitiveSet::uint16,
                    7 => PrimitiveSet::uint32,
                    8 => PrimitiveSet::uint64,
                    9 => PrimitiveSet::float32,
                    10 => PrimitiveSet::float64,
                    11 => PrimitiveSet::text,
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyTupleField {
            type HeadPtr = TyTupleFieldHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let name = self.name.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                TyTupleFieldHeadPtr { name, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.name.encode_body(head.name, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyTupleFieldHeadPtr {
            name: <core::option::Option<crate::string::String> as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyTupleField {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for TyTupleField {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = core::option::Option::<crate::string::String>::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(5))?;
                Ok(TyTupleField { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyEnumVariant {
            type HeadPtr = TyEnumVariantHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let name = self.name.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                TyEnumVariantHeadPtr { name, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.name.encode_body(head.name, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyEnumVariantHeadPtr {
            name: <crate::string::String as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyEnumVariant {
            fn head_size() -> usize {
                184
            }
        }

        impl crate::Decode for TyEnumVariant {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = crate::string::String::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(8))?;
                Ok(TyEnumVariant { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyLayout {
            type HeadPtr = TyLayoutHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let head_size = self.head_size.encode_head(buf);
                let body_ptrs = self.body_ptrs.encode_head(buf);
                let variants_recursive = self.variants_recursive.encode_head(buf);
                TyLayoutHeadPtr {
                    head_size,
                    body_ptrs,
                    variants_recursive,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.head_size.encode_body(head.head_size, buf);
                self.body_ptrs.encode_body(head.body_ptrs, buf);
                self.variants_recursive
                    .encode_body(head.variants_recursive, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyLayoutHeadPtr {
            head_size: <u32 as crate::Encode>::HeadPtr,
            body_ptrs: <crate::vec::Vec<u32> as crate::Encode>::HeadPtr,
            variants_recursive: <crate::vec::Vec<u16> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyLayout {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for TyLayout {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let head_size = u32::decode(buf.skip(0))?;
                let body_ptrs = crate::vec::Vec::<u32>::decode(buf.skip(4))?;
                let variants_recursive = crate::vec::Vec::<u16>::decode(buf.skip(12))?;
                Ok(TyLayout {
                    head_size,
                    body_ptrs,
                    variants_recursive,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyFunction {
            type HeadPtr = TyFunctionHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let params = self.params.encode_head(buf);
                let body = self.body.encode_head(buf);
                TyFunctionHeadPtr { params, body }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.params.encode_body(head.params, buf);
                self.body.encode_body(head.body, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyFunctionHeadPtr {
            params: <crate::vec::Vec<super::Ty> as crate::Encode>::HeadPtr,
            body: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyFunction {
            fn head_size() -> usize {
                184
            }
        }

        impl crate::Decode for TyFunction {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let params = crate::vec::Vec::<super::Ty>::decode(buf.skip(0))?;
                let body = super::Ty::decode(buf.skip(8))?;
                Ok(TyFunction { params, body })
            }
        }

        impl crate::Encode for Path {
            type HeadPtr = crate::ReversePointer;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                self.0.encode_head(buf)
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.0.encode_body(head, buf)
            }
        }
        impl crate::Layout for Path {
            fn head_size() -> usize {
                64
            }
        }

        impl crate::Decode for Path {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                Ok(Self(crate::vec::Vec::<crate::string::String>::decode(buf)?))
            }
        }
    }
}
