//# Generated by lutra-codegen

pub mod br {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Program {
        pub externals: Vec<ExternalSymbol>,
        pub main: Expr,
        pub input_tys: Vec<super::ir::Ty>,
        pub output_ty: super::ir::Ty,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ExternalSymbol {
        pub id: String,
        pub layout_args: Vec<u32>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Expr {
        pub kind: ExprKind,
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum ExprKind {
        Pointer(Sid),
        Literal(super::ir::Literal),
        Call(Box<Call>),
        Function(Box<Function>),
        Tuple(Box<Tuple>),
        Array(Box<Array>),
        TupleLookup(Box<TupleLookup>),
        Binding(Box<Binding>),
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Sid(pub u32);

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Call {
        pub function: Expr,
        pub args: Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Function {
        pub symbol_ns: Sid,
        pub body: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Tuple {
        pub fields: Vec<Expr>,
        pub field_layouts: Vec<TyLayout>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Array {
        pub item_layout: TyLayout,
        pub items: Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleLookup {
        pub base: Expr,
        pub offset: u32,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Binding {
        pub symbol: Sid,
        pub expr: Expr,
        pub main: Expr,
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub struct TyLayout {
        pub head_size: u32,
        pub body_ptrs: Vec<u32>,
    }

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::ReaderExt;
        use ::std::io::Write;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let externals = self.externals.encode_head(w)?;
                let main = self.main.encode_head(w)?;
                let input_tys = self.input_tys.encode_head(w)?;
                let output_ty = self.output_ty.encode_head(w)?;
                Ok(ProgramHeadPtr {
                    externals,
                    main,
                    input_tys,
                    output_ty,
                })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.externals.encode_body(head.externals, w)?;
                self.main.encode_body(head.main, w)?;
                self.input_tys.encode_body(head.input_tys, w)?;
                self.output_ty.encode_body(head.output_ty, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramHeadPtr {
            externals: <Vec<super::ExternalSymbol> as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
            input_tys: <Vec<super::super::ir::Ty> as crate::Encode>::HeadPtr,
            output_ty: <super::super::ir::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                288
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let externals = Vec::<super::ExternalSymbol>::decode(buf.skip(0))?;
                let main = super::Expr::decode(buf.skip(8))?;
                let input_tys = Vec::<super::super::ir::Ty>::decode(buf.skip(13))?;
                let output_ty = super::super::ir::Ty::decode(buf.skip(21))?;
                Ok(Program {
                    externals,
                    main,
                    input_tys,
                    output_ty,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ExternalSymbol {
            type HeadPtr = ExternalSymbolHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let id = self.id.encode_head(w)?;
                let layout_args = self.layout_args.encode_head(w)?;
                Ok(ExternalSymbolHeadPtr { id, layout_args })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.id.encode_body(head.id, w)?;
                self.layout_args.encode_body(head.layout_args, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExternalSymbolHeadPtr {
            id: <String as crate::Encode>::HeadPtr,
            layout_args: <Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ExternalSymbol {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for ExternalSymbol {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = String::decode(buf.skip(0))?;
                let layout_args = Vec::<u32>::decode(buf.skip(8))?;
                Ok(ExternalSymbol { id, layout_args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Expr {
            type HeadPtr = ExprHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let kind = self.kind.encode_head(w)?;
                Ok(ExprHeadPtr { kind })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.kind.encode_body(head.kind, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExprHeadPtr {
            kind: <super::ExprKind as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Expr {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Expr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::ExprKind::decode(buf.skip(0))?;
                Ok(Expr { kind })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExprKind {
            type HeadPtr = ExprKindHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<ExprKindHeadPtr> {
                Ok(match self {
                    Self::Pointer(inner) => {
                        w.write_all(&[0])?;
                        let inner_head_ptr = inner.encode_head(w)?;
                        let r = ExprKindHeadPtr::Pointer(inner_head_ptr);
                        r
                    }
                    Self::Literal(_) => {
                        w.write_all(&[1])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Literal(head_ptr);
                        r
                    }
                    Self::Call(_) => {
                        w.write_all(&[2])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Call(head_ptr);
                        r
                    }
                    Self::Function(_) => {
                        w.write_all(&[3])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Tuple(_) => {
                        w.write_all(&[4])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(_) => {
                        w.write_all(&[5])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::TupleLookup(_) => {
                        w.write_all(&[6])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::TupleLookup(head_ptr);
                        r
                    }
                    Self::Binding(_) => {
                        w.write_all(&[7])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Binding(head_ptr);
                        r
                    }
                })
            }
            fn encode_body(&self, head: ExprKindHeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                match self {
                    Self::Pointer(inner) => {
                        let ExprKindHeadPtr::Pointer(inner_head_ptr) = head else {
                            unreachable!()
                        };
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Literal(inner) => {
                        let ExprKindHeadPtr::Literal(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Call(inner) => {
                        let ExprKindHeadPtr::Call(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Function(inner) => {
                        let ExprKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Tuple(inner) => {
                        let ExprKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Array(inner) => {
                        let ExprKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::TupleLookup(inner) => {
                        let ExprKindHeadPtr::TupleLookup(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Binding(inner) => {
                        let ExprKindHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                }
                Ok(())
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExprKindHeadPtr {
            None,
            Pointer(<super::Sid as crate::Encode>::HeadPtr),
            Literal(crate::ReversePointer),
            Call(crate::ReversePointer),
            Function(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            TupleLookup(crate::ReversePointer),
            Binding(crate::ReversePointer),
        }
        impl crate::Layout for ExprKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExprKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let inner = super::Sid::decode(buf)?;
                        ExprKind::Pointer(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::super::ir::Literal::decode(buf.skip(offset as usize))?;
                        ExprKind::Literal(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Call::decode(buf.skip(offset as usize))?;
                        ExprKind::Call(Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Function::decode(buf.skip(offset as usize))?;
                        ExprKind::Function(Box::new(inner))
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Tuple::decode(buf.skip(offset as usize))?;
                        ExprKind::Tuple(Box::new(inner))
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Array::decode(buf.skip(offset as usize))?;
                        ExprKind::Array(Box::new(inner))
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TupleLookup::decode(buf.skip(offset as usize))?;
                        ExprKind::TupleLookup(Box::new(inner))
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Binding::decode(buf.skip(offset as usize))?;
                        ExprKind::Binding(Box::new(inner))
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        impl crate::Encode for Sid {
            type HeadPtr = ();
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<()> {
                self.0.encode_head(w)
            }
            fn encode_body(&self, _: (), _w: &mut Vec<u8>) -> crate::Result<()> {
                Ok(())
            }
        }
        impl crate::Layout for Sid {
            fn head_size() -> usize {
                32
            }
        }

        impl crate::Decode for Sid {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                Ok(Self(u32::decode(buf)?))
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Call {
            type HeadPtr = CallHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let function = self.function.encode_head(w)?;
                let args = self.args.encode_head(w)?;
                Ok(CallHeadPtr { function, args })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.function.encode_body(head.function, w)?;
                self.args.encode_body(head.args, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct CallHeadPtr {
            function: <super::Expr as crate::Encode>::HeadPtr,
            args: <Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Call {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for Call {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function = super::Expr::decode(buf.skip(0))?;
                let args = Vec::<super::Expr>::decode(buf.skip(5))?;
                Ok(Call { function, args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Function {
            type HeadPtr = FunctionHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let symbol_ns = self.symbol_ns.encode_head(w)?;
                let body = self.body.encode_head(w)?;
                Ok(FunctionHeadPtr { symbol_ns, body })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.symbol_ns.encode_body(head.symbol_ns, w)?;
                self.body.encode_body(head.body, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct FunctionHeadPtr {
            symbol_ns: <super::Sid as crate::Encode>::HeadPtr,
            body: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Function {
            fn head_size() -> usize {
                72
            }
        }

        impl crate::Decode for Function {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let symbol_ns = super::Sid::decode(buf.skip(0))?;
                let body = super::Expr::decode(buf.skip(4))?;
                Ok(Function { symbol_ns, body })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Tuple {
            type HeadPtr = TupleHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let fields = self.fields.encode_head(w)?;
                let field_layouts = self.field_layouts.encode_head(w)?;
                Ok(TupleHeadPtr {
                    fields,
                    field_layouts,
                })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.fields.encode_body(head.fields, w)?;
                self.field_layouts.encode_body(head.field_layouts, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleHeadPtr {
            fields: <Vec<super::Expr> as crate::Encode>::HeadPtr,
            field_layouts: <Vec<super::TyLayout> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Tuple {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for Tuple {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let fields = Vec::<super::Expr>::decode(buf.skip(0))?;
                let field_layouts = Vec::<super::TyLayout>::decode(buf.skip(8))?;
                Ok(Tuple {
                    fields,
                    field_layouts,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Array {
            type HeadPtr = ArrayHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let item_layout = self.item_layout.encode_head(w)?;
                let items = self.items.encode_head(w)?;
                Ok(ArrayHeadPtr { item_layout, items })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.item_layout.encode_body(head.item_layout, w)?;
                self.items.encode_body(head.items, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ArrayHeadPtr {
            item_layout: <super::TyLayout as crate::Encode>::HeadPtr,
            items: <Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Array {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Array {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let item_layout = super::TyLayout::decode(buf.skip(0))?;
                let items = Vec::<super::Expr>::decode(buf.skip(12))?;
                Ok(Array { item_layout, items })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleLookup {
            type HeadPtr = TupleLookupHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let base = self.base.encode_head(w)?;
                let offset = self.offset.encode_head(w)?;
                Ok(TupleLookupHeadPtr { base, offset })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.base.encode_body(head.base, w)?;
                self.offset.encode_body(head.offset, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleLookupHeadPtr {
            base: <super::Expr as crate::Encode>::HeadPtr,
            offset: <u32 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleLookup {
            fn head_size() -> usize {
                72
            }
        }

        impl crate::Decode for TupleLookup {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let base = super::Expr::decode(buf.skip(0))?;
                let offset = u32::decode(buf.skip(5))?;
                Ok(TupleLookup { base, offset })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Binding {
            type HeadPtr = BindingHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let symbol = self.symbol.encode_head(w)?;
                let expr = self.expr.encode_head(w)?;
                let main = self.main.encode_head(w)?;
                Ok(BindingHeadPtr { symbol, expr, main })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.symbol.encode_body(head.symbol, w)?;
                self.expr.encode_body(head.expr, w)?;
                self.main.encode_body(head.main, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BindingHeadPtr {
            symbol: <super::Sid as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Binding {
            fn head_size() -> usize {
                112
            }
        }

        impl crate::Decode for Binding {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let symbol = super::Sid::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(4))?;
                let main = super::Expr::decode(buf.skip(9))?;
                Ok(Binding { symbol, expr, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyLayout {
            type HeadPtr = TyLayoutHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let head_size = self.head_size.encode_head(w)?;
                let body_ptrs = self.body_ptrs.encode_head(w)?;
                Ok(TyLayoutHeadPtr {
                    head_size,
                    body_ptrs,
                })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.head_size.encode_body(head.head_size, w)?;
                self.body_ptrs.encode_body(head.body_ptrs, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyLayoutHeadPtr {
            head_size: <u32 as crate::Encode>::HeadPtr,
            body_ptrs: <Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyLayout {
            fn head_size() -> usize {
                96
            }
        }

        impl crate::Decode for TyLayout {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let head_size = u32::decode(buf.skip(0))?;
                let body_ptrs = Vec::<u32>::decode(buf.skip(4))?;
                Ok(TyLayout {
                    head_size,
                    body_ptrs,
                })
            }
        }
    }
}

pub mod ir {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Program {
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Expr {
        pub kind: ExprKind,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum ExprKind {
        Pointer(Pointer),
        Literal(Literal),
        Call(Box<Call>),
        Function(Box<Function>),
        Tuple(Vec<Expr>),
        Array(Vec<Expr>),
        TupleLookup(Box<TupleLookup>),
        Binding(Box<Binding>),
        RemoteCall(Box<RemoteCall>),
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Pointer {
        External(ExternalPtr),
        Binding(u32),
        Parameter(ParameterPtr),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ExternalPtr {
        pub host: ExecutionHost,
        pub id: String,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ParameterPtr {
        pub function_id: u32,
        pub param_position: u8,
    }

    #[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Literal {
        Int(i64),
        Float(f64),
        Bool(bool),
        Text(String),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Call {
        pub function: Expr,
        pub args: Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Function {
        pub id: u32,
        pub host: ExecutionHost,
        pub body: Expr,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[allow(non_camel_case_types)]
    pub enum ExecutionHost {
        Any,
        Local,
        Remote(String),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleLookup {
        pub base: Expr,
        pub position: u16,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Binding {
        pub id: u32,
        pub expr: Expr,
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct RemoteCall {
        pub remote_id: String,
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Ty {
        pub kind: TyKind,
        pub layout: Option<TyLayout>,
        pub name: Option<String>,
    }

    #[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum TyKind {
        Primitive(PrimitiveSet),
        Tuple(Vec<TyTupleField>),
        Array(Box<Ty>),
        Enum(Vec<TyEnumVariant>),
        Function(Box<TyFunction>),
        Ident(Path),
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimitiveSet {
        bool,
        int8,
        int16,
        int32,
        int64,
        uint8,
        uint16,
        uint32,
        uint64,
        float32,
        float64,
        text,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyTupleField {
        pub name: Option<String>,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyEnumVariant {
        pub name: String,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub struct TyLayout {
        pub head_size: u32,
        pub body_ptrs: Vec<u32>,
        pub variants_recursive: Vec<u16>,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyFunction {
        pub params: Vec<Ty>,
        pub body: Ty,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct Path(pub Vec<String>);

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::ReaderExt;
        use ::std::io::Write;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let main = self.main.encode_head(w)?;
                Ok(ProgramHeadPtr { main })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.main.encode_body(head.main, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramHeadPtr {
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let main = super::Expr::decode(buf.skip(0))?;
                Ok(Program { main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Expr {
            type HeadPtr = ExprHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let kind = self.kind.encode_head(w)?;
                let ty = self.ty.encode_head(w)?;
                Ok(ExprHeadPtr { kind, ty })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.kind.encode_body(head.kind, w)?;
                self.ty.encode_body(head.ty, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExprHeadPtr {
            kind: <super::ExprKind as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Expr {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Expr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::ExprKind::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(5))?;
                Ok(Expr { kind, ty })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExprKind {
            type HeadPtr = ExprKindHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<ExprKindHeadPtr> {
                Ok(match self {
                    Self::Pointer(_) => {
                        w.write_all(&[0])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Pointer(head_ptr);
                        r
                    }
                    Self::Literal(_) => {
                        w.write_all(&[1])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Literal(head_ptr);
                        r
                    }
                    Self::Call(_) => {
                        w.write_all(&[2])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Call(head_ptr);
                        r
                    }
                    Self::Function(_) => {
                        w.write_all(&[3])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Tuple(_) => {
                        w.write_all(&[4])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(_) => {
                        w.write_all(&[5])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::TupleLookup(_) => {
                        w.write_all(&[6])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::TupleLookup(head_ptr);
                        r
                    }
                    Self::Binding(_) => {
                        w.write_all(&[7])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Binding(head_ptr);
                        r
                    }
                    Self::RemoteCall(_) => {
                        w.write_all(&[8])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::RemoteCall(head_ptr);
                        r
                    }
                })
            }
            fn encode_body(&self, head: ExprKindHeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                match self {
                    Self::Pointer(inner) => {
                        let ExprKindHeadPtr::Pointer(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Literal(inner) => {
                        let ExprKindHeadPtr::Literal(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Call(inner) => {
                        let ExprKindHeadPtr::Call(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Function(inner) => {
                        let ExprKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Tuple(inner) => {
                        let ExprKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Array(inner) => {
                        let ExprKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::TupleLookup(inner) => {
                        let ExprKindHeadPtr::TupleLookup(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Binding(inner) => {
                        let ExprKindHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::RemoteCall(inner) => {
                        let ExprKindHeadPtr::RemoteCall(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                }
                Ok(())
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExprKindHeadPtr {
            None,
            Pointer(crate::ReversePointer),
            Literal(crate::ReversePointer),
            Call(crate::ReversePointer),
            Function(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            TupleLookup(crate::ReversePointer),
            Binding(crate::ReversePointer),
            RemoteCall(crate::ReversePointer),
        }
        impl crate::Layout for ExprKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExprKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Pointer::decode(buf.skip(offset as usize))?;
                        ExprKind::Pointer(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Literal::decode(buf.skip(offset as usize))?;
                        ExprKind::Literal(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Call::decode(buf.skip(offset as usize))?;
                        ExprKind::Call(Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Function::decode(buf.skip(offset as usize))?;
                        ExprKind::Function(Box::new(inner))
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = Vec::<super::Expr>::decode(buf.skip(offset as usize))?;
                        ExprKind::Tuple(inner)
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = Vec::<super::Expr>::decode(buf.skip(offset as usize))?;
                        ExprKind::Array(inner)
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TupleLookup::decode(buf.skip(offset as usize))?;
                        ExprKind::TupleLookup(Box::new(inner))
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Binding::decode(buf.skip(offset as usize))?;
                        ExprKind::Binding(Box::new(inner))
                    }
                    8 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::RemoteCall::decode(buf.skip(offset as usize))?;
                        ExprKind::RemoteCall(Box::new(inner))
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Pointer {
            type HeadPtr = PointerHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<PointerHeadPtr> {
                Ok(match self {
                    Self::External(_) => {
                        w.write_all(&[0])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::External(head_ptr);
                        r
                    }
                    Self::Binding(inner) => {
                        w.write_all(&[1])?;
                        let inner_head_ptr = inner.encode_head(w)?;
                        let r = PointerHeadPtr::Binding(inner_head_ptr);
                        r
                    }
                    Self::Parameter(_) => {
                        w.write_all(&[2])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::Parameter(head_ptr);
                        r
                    }
                })
            }
            fn encode_body(&self, head: PointerHeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                match self {
                    Self::External(inner) => {
                        let PointerHeadPtr::External(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Binding(inner) => {
                        let PointerHeadPtr::Binding(inner_head_ptr) = head else {
                            unreachable!()
                        };
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Parameter(inner) => {
                        let PointerHeadPtr::Parameter(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                }
                Ok(())
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum PointerHeadPtr {
            None,
            External(crate::ReversePointer),
            Binding(<u32 as crate::Encode>::HeadPtr),
            Parameter(crate::ReversePointer),
        }
        impl crate::Layout for Pointer {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Pointer {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::ExternalPtr::decode(buf.skip(offset as usize))?;
                        Pointer::External(inner)
                    }
                    1 => {
                        let inner = u32::decode(buf)?;
                        Pointer::Binding(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::ParameterPtr::decode(buf.skip(offset as usize))?;
                        Pointer::Parameter(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ExternalPtr {
            type HeadPtr = ExternalPtrHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let host = self.host.encode_head(w)?;
                let id = self.id.encode_head(w)?;
                Ok(ExternalPtrHeadPtr { host, id })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.host.encode_body(head.host, w)?;
                self.id.encode_body(head.id, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExternalPtrHeadPtr {
            host: <super::ExecutionHost as crate::Encode>::HeadPtr,
            id: <String as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ExternalPtr {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for ExternalPtr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let host = super::ExecutionHost::decode(buf.skip(0))?;
                let id = String::decode(buf.skip(5))?;
                Ok(ExternalPtr { host, id })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ParameterPtr {
            type HeadPtr = ParameterPtrHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let function_id = self.function_id.encode_head(w)?;
                let param_position = self.param_position.encode_head(w)?;
                Ok(ParameterPtrHeadPtr {
                    function_id,
                    param_position,
                })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.function_id.encode_body(head.function_id, w)?;
                self.param_position.encode_body(head.param_position, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ParameterPtrHeadPtr {
            function_id: <u32 as crate::Encode>::HeadPtr,
            param_position: <u8 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ParameterPtr {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ParameterPtr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function_id = u32::decode(buf.skip(0))?;
                let param_position = u8::decode(buf.skip(4))?;
                Ok(ParameterPtr {
                    function_id,
                    param_position,
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Literal {
            type HeadPtr = LiteralHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<LiteralHeadPtr> {
                Ok(match self {
                    Self::Int(_) => {
                        w.write_all(&[0])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::Int(head_ptr);
                        r
                    }
                    Self::Float(_) => {
                        w.write_all(&[1])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::Float(head_ptr);
                        r
                    }
                    Self::Bool(inner) => {
                        w.write_all(&[2])?;
                        let inner_head_ptr = inner.encode_head(w)?;
                        let r = LiteralHeadPtr::Bool(inner_head_ptr);
                        w.write_all(&[0u8, 0u8, 0u8])?;
                        r
                    }
                    Self::Text(_) => {
                        w.write_all(&[3])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::Text(head_ptr);
                        r
                    }
                })
            }
            fn encode_body(&self, head: LiteralHeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                match self {
                    Self::Int(inner) => {
                        let LiteralHeadPtr::Int(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Float(inner) => {
                        let LiteralHeadPtr::Float(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Bool(inner) => {
                        let LiteralHeadPtr::Bool(inner_head_ptr) = head else {
                            unreachable!()
                        };
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Text(inner) => {
                        let LiteralHeadPtr::Text(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                }
                Ok(())
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum LiteralHeadPtr {
            None,
            Int(crate::ReversePointer),
            Float(crate::ReversePointer),
            Bool(<bool as crate::Encode>::HeadPtr),
            Text(crate::ReversePointer),
        }
        impl crate::Layout for Literal {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Literal {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = i64::decode(buf.skip(offset as usize))?;
                        Literal::Int(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = f64::decode(buf.skip(offset as usize))?;
                        Literal::Float(inner)
                    }
                    2 => {
                        let inner = bool::decode(buf)?;
                        Literal::Bool(inner)
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = String::decode(buf.skip(offset as usize))?;
                        Literal::Text(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Call {
            type HeadPtr = CallHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let function = self.function.encode_head(w)?;
                let args = self.args.encode_head(w)?;
                Ok(CallHeadPtr { function, args })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.function.encode_body(head.function, w)?;
                self.args.encode_body(head.args, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct CallHeadPtr {
            function: <super::Expr as crate::Encode>::HeadPtr,
            args: <Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Call {
            fn head_size() -> usize {
                224
            }
        }

        impl crate::Decode for Call {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function = super::Expr::decode(buf.skip(0))?;
                let args = Vec::<super::Expr>::decode(buf.skip(20))?;
                Ok(Call { function, args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Function {
            type HeadPtr = FunctionHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let id = self.id.encode_head(w)?;
                let host = self.host.encode_head(w)?;
                let body = self.body.encode_head(w)?;
                Ok(FunctionHeadPtr { id, host, body })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.id.encode_body(head.id, w)?;
                self.host.encode_body(head.host, w)?;
                self.body.encode_body(head.body, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct FunctionHeadPtr {
            id: <u32 as crate::Encode>::HeadPtr,
            host: <super::ExecutionHost as crate::Encode>::HeadPtr,
            body: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Function {
            fn head_size() -> usize {
                232
            }
        }

        impl crate::Decode for Function {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = u32::decode(buf.skip(0))?;
                let host = super::ExecutionHost::decode(buf.skip(4))?;
                let body = super::Expr::decode(buf.skip(9))?;
                Ok(Function { id, host, body })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExecutionHost {
            type HeadPtr = ExecutionHostHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<ExecutionHostHeadPtr> {
                Ok(match self {
                    Self::Any => {
                        w.write_all(&[0])?;
                        let r = ExecutionHostHeadPtr::None;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                        r
                    }
                    Self::Local => {
                        w.write_all(&[1])?;
                        let r = ExecutionHostHeadPtr::None;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                        r
                    }
                    Self::Remote(_) => {
                        w.write_all(&[2])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExecutionHostHeadPtr::Remote(head_ptr);
                        r
                    }
                })
            }
            fn encode_body(
                &self,
                head: ExecutionHostHeadPtr,
                w: &mut Vec<u8>,
            ) -> crate::Result<()> {
                match self {
                    Self::Any => {}
                    Self::Local => {}
                    Self::Remote(inner) => {
                        let ExecutionHostHeadPtr::Remote(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                }
                Ok(())
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExecutionHostHeadPtr {
            None,
            Remote(crate::ReversePointer),
        }
        impl crate::Layout for ExecutionHost {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExecutionHost {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => ExecutionHost::Any,
                    1 => ExecutionHost::Local,
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = String::decode(buf.skip(offset as usize))?;
                        ExecutionHost::Remote(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleLookup {
            type HeadPtr = TupleLookupHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let base = self.base.encode_head(w)?;
                let position = self.position.encode_head(w)?;
                Ok(TupleLookupHeadPtr { base, position })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.base.encode_body(head.base, w)?;
                self.position.encode_body(head.position, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleLookupHeadPtr {
            base: <super::Expr as crate::Encode>::HeadPtr,
            position: <u16 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleLookup {
            fn head_size() -> usize {
                176
            }
        }

        impl crate::Decode for TupleLookup {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let base = super::Expr::decode(buf.skip(0))?;
                let position = u16::decode(buf.skip(20))?;
                Ok(TupleLookup { base, position })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Binding {
            type HeadPtr = BindingHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let id = self.id.encode_head(w)?;
                let expr = self.expr.encode_head(w)?;
                let main = self.main.encode_head(w)?;
                Ok(BindingHeadPtr { id, expr, main })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.id.encode_body(head.id, w)?;
                self.expr.encode_body(head.expr, w)?;
                self.main.encode_body(head.main, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BindingHeadPtr {
            id: <u32 as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Binding {
            fn head_size() -> usize {
                352
            }
        }

        impl crate::Decode for Binding {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = u32::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(4))?;
                let main = super::Expr::decode(buf.skip(24))?;
                Ok(Binding { id, expr, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for RemoteCall {
            type HeadPtr = RemoteCallHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let remote_id = self.remote_id.encode_head(w)?;
                let main = self.main.encode_head(w)?;
                Ok(RemoteCallHeadPtr { remote_id, main })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.remote_id.encode_body(head.remote_id, w)?;
                self.main.encode_body(head.main, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct RemoteCallHeadPtr {
            remote_id: <String as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for RemoteCall {
            fn head_size() -> usize {
                224
            }
        }

        impl crate::Decode for RemoteCall {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let remote_id = String::decode(buf.skip(0))?;
                let main = super::Expr::decode(buf.skip(8))?;
                Ok(RemoteCall { remote_id, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Ty {
            type HeadPtr = TyHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let kind = self.kind.encode_head(w)?;
                let layout = self.layout.encode_head(w)?;
                let name = self.name.encode_head(w)?;
                Ok(TyHeadPtr { kind, layout, name })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.kind.encode_body(head.kind, w)?;
                self.layout.encode_body(head.layout, w)?;
                self.name.encode_body(head.name, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyHeadPtr {
            kind: <super::TyKind as crate::Encode>::HeadPtr,
            layout: <Option<super::TyLayout> as crate::Encode>::HeadPtr,
            name: <Option<String> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Ty {
            fn head_size() -> usize {
                120
            }
        }

        impl crate::Decode for Ty {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::TyKind::decode(buf.skip(0))?;
                let layout = Option::<super::TyLayout>::decode(buf.skip(5))?;
                let name = Option::<String>::decode(buf.skip(10))?;
                Ok(Ty { kind, layout, name })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for TyKind {
            type HeadPtr = TyKindHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<TyKindHeadPtr> {
                Ok(match self {
                    Self::Primitive(_) => {
                        w.write_all(&[0])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Primitive(head_ptr);
                        r
                    }
                    Self::Tuple(_) => {
                        w.write_all(&[1])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(_) => {
                        w.write_all(&[2])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::Enum(_) => {
                        w.write_all(&[3])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Enum(head_ptr);
                        r
                    }
                    Self::Function(_) => {
                        w.write_all(&[4])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Ident(_) => {
                        w.write_all(&[5])?;
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Ident(head_ptr);
                        r
                    }
                })
            }
            fn encode_body(&self, head: TyKindHeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                match self {
                    Self::Primitive(inner) => {
                        let TyKindHeadPtr::Primitive(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Tuple(inner) => {
                        let TyKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Array(inner) => {
                        let TyKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Enum(inner) => {
                        let TyKindHeadPtr::Enum(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Function(inner) => {
                        let TyKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                    Self::Ident(inner) => {
                        let TyKindHeadPtr::Ident(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w)?;
                        inner.encode_body(inner_head_ptr, w)?;
                    }
                }
                Ok(())
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum TyKindHeadPtr {
            None,
            Primitive(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            Enum(crate::ReversePointer),
            Function(crate::ReversePointer),
            Ident(crate::ReversePointer),
        }
        impl crate::Layout for TyKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for TyKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::PrimitiveSet::decode(buf.skip(offset as usize))?;
                        TyKind::Primitive(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = Vec::<super::TyTupleField>::decode(buf.skip(offset as usize))?;
                        TyKind::Tuple(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Ty::decode(buf.skip(offset as usize))?;
                        TyKind::Array(Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = Vec::<super::TyEnumVariant>::decode(buf.skip(offset as usize))?;
                        TyKind::Enum(inner)
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TyFunction::decode(buf.skip(offset as usize))?;
                        TyKind::Function(Box::new(inner))
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Path::decode(buf.skip(offset as usize))?;
                        TyKind::Ident(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for PrimitiveSet {
            type HeadPtr = ();
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<()> {
                Ok(match self {
                    Self::bool => {
                        w.write_all(&[0])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::int8 => {
                        w.write_all(&[1])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::int16 => {
                        w.write_all(&[2])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::int32 => {
                        w.write_all(&[3])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::int64 => {
                        w.write_all(&[4])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::uint8 => {
                        w.write_all(&[5])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::uint16 => {
                        w.write_all(&[6])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::uint32 => {
                        w.write_all(&[7])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::uint64 => {
                        w.write_all(&[8])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::float32 => {
                        w.write_all(&[9])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::float64 => {
                        w.write_all(&[10])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                    Self::text => {
                        w.write_all(&[11])?;
                        w.write_all(&[0u8, 0u8, 0u8, 0u8])?;
                    }
                })
            }
            fn encode_body(&self, head: (), w: &mut Vec<u8>) -> crate::Result<()> {
                Ok(())
            }
        }
        impl crate::Layout for PrimitiveSet {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for PrimitiveSet {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                Ok(match tag {
                    0 => PrimitiveSet::bool,
                    1 => PrimitiveSet::int8,
                    2 => PrimitiveSet::int16,
                    3 => PrimitiveSet::int32,
                    4 => PrimitiveSet::int64,
                    5 => PrimitiveSet::uint8,
                    6 => PrimitiveSet::uint16,
                    7 => PrimitiveSet::uint32,
                    8 => PrimitiveSet::uint64,
                    9 => PrimitiveSet::float32,
                    10 => PrimitiveSet::float64,
                    11 => PrimitiveSet::text,
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyTupleField {
            type HeadPtr = TyTupleFieldHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let name = self.name.encode_head(w)?;
                let ty = self.ty.encode_head(w)?;
                Ok(TyTupleFieldHeadPtr { name, ty })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.name.encode_body(head.name, w)?;
                self.ty.encode_body(head.ty, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyTupleFieldHeadPtr {
            name: <Option<String> as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyTupleField {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for TyTupleField {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = Option::<String>::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(5))?;
                Ok(TyTupleField { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyEnumVariant {
            type HeadPtr = TyEnumVariantHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let name = self.name.encode_head(w)?;
                let ty = self.ty.encode_head(w)?;
                Ok(TyEnumVariantHeadPtr { name, ty })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.name.encode_body(head.name, w)?;
                self.ty.encode_body(head.ty, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyEnumVariantHeadPtr {
            name: <String as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyEnumVariant {
            fn head_size() -> usize {
                184
            }
        }

        impl crate::Decode for TyEnumVariant {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = String::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(8))?;
                Ok(TyEnumVariant { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyLayout {
            type HeadPtr = TyLayoutHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let head_size = self.head_size.encode_head(w)?;
                let body_ptrs = self.body_ptrs.encode_head(w)?;
                let variants_recursive = self.variants_recursive.encode_head(w)?;
                Ok(TyLayoutHeadPtr {
                    head_size,
                    body_ptrs,
                    variants_recursive,
                })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.head_size.encode_body(head.head_size, w)?;
                self.body_ptrs.encode_body(head.body_ptrs, w)?;
                self.variants_recursive
                    .encode_body(head.variants_recursive, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyLayoutHeadPtr {
            head_size: <u32 as crate::Encode>::HeadPtr,
            body_ptrs: <Vec<u32> as crate::Encode>::HeadPtr,
            variants_recursive: <Vec<u16> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyLayout {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for TyLayout {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let head_size = u32::decode(buf.skip(0))?;
                let body_ptrs = Vec::<u32>::decode(buf.skip(4))?;
                let variants_recursive = Vec::<u16>::decode(buf.skip(12))?;
                Ok(TyLayout {
                    head_size,
                    body_ptrs,
                    variants_recursive,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyFunction {
            type HeadPtr = TyFunctionHeadPtr;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                let params = self.params.encode_head(w)?;
                let body = self.body.encode_head(w)?;
                Ok(TyFunctionHeadPtr { params, body })
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.params.encode_body(head.params, w)?;
                self.body.encode_body(head.body, w)?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyFunctionHeadPtr {
            params: <Vec<super::Ty> as crate::Encode>::HeadPtr,
            body: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyFunction {
            fn head_size() -> usize {
                184
            }
        }

        impl crate::Decode for TyFunction {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let params = Vec::<super::Ty>::decode(buf.skip(0))?;
                let body = super::Ty::decode(buf.skip(8))?;
                Ok(TyFunction { params, body })
            }
        }

        impl crate::Encode for Path {
            type HeadPtr = crate::ReversePointer;
            fn encode_head(&self, w: &mut Vec<u8>) -> crate::Result<Self::HeadPtr> {
                self.0.encode_head(w)
            }
            fn encode_body(&self, head: Self::HeadPtr, w: &mut Vec<u8>) -> crate::Result<()> {
                self.0.encode_body(head, w)
            }
        }
        impl crate::Layout for Path {
            fn head_size() -> usize {
                64
            }
        }

        impl crate::Decode for Path {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                Ok(Self(Vec::<String>::decode(buf)?))
            }
        }
    }
}
