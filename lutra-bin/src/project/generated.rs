//# Generated by lutra-codegen

pub mod rr {
    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Program {
        SqlPostgres(crate::boxed::Box<SqlProgram>),
        SqlDuckDB(crate::boxed::Box<SqlProgram>),
        BytecodeLt(super::br::Program),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ProgramType {
        pub input: super::ir::Ty,
        pub output: super::ir::Ty,
        pub defs: crate::vec::Vec<super::ir::TyDef>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct SqlProgram {
        pub sql: crate::string::String,
        pub input_ty: super::ir::Ty,
        pub output_ty: super::ir::Ty,
        pub defs: crate::vec::Vec<super::ir::TyDef>,
    }

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::ReaderExt;
        use crate::bytes::BufMut;

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> ProgramHeadPtr {
                match self {
                    Self::SqlPostgres(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ProgramHeadPtr::SqlPostgres(head_ptr);
                        r
                    }
                    Self::SqlDuckDB(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ProgramHeadPtr::SqlDuckDB(head_ptr);
                        r
                    }
                    Self::BytecodeLt(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ProgramHeadPtr::BytecodeLt(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: ProgramHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::SqlPostgres(inner) => {
                        let ProgramHeadPtr::SqlPostgres(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::SqlDuckDB(inner) => {
                        let ProgramHeadPtr::SqlDuckDB(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::BytecodeLt(inner) => {
                        let ProgramHeadPtr::BytecodeLt(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ProgramHeadPtr {
            None,
            SqlPostgres(crate::ReversePointer),
            SqlDuckDB(crate::ReversePointer),
            BytecodeLt(crate::ReversePointer),
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::SqlProgram::decode(buf.skip(offset as usize))?;
                        Program::SqlPostgres(crate::boxed::Box::new(inner))
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::SqlProgram::decode(buf.skip(offset as usize))?;
                        Program::SqlDuckDB(crate::boxed::Box::new(inner))
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::super::br::Program::decode(buf.skip(offset as usize))?;
                        Program::BytecodeLt(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ProgramType {
            type HeadPtr = ProgramTypeHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let input = self.input.encode_head(buf);
                let output = self.output.encode_head(buf);
                let defs = self.defs.encode_head(buf);
                ProgramTypeHeadPtr {
                    input,
                    output,
                    defs,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.input.encode_body(head.input, buf);
                self.output.encode_body(head.output, buf);
                self.defs.encode_body(head.defs, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramTypeHeadPtr {
            input: <super::super::ir::Ty as crate::Encode>::HeadPtr,
            output: <super::super::ir::Ty as crate::Encode>::HeadPtr,
            defs: <crate::vec::Vec<super::super::ir::TyDef> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ProgramType {
            fn head_size() -> usize {
                432
            }
        }

        impl crate::Decode for ProgramType {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let input = super::super::ir::Ty::decode(buf.skip(0))?;
                let output = super::super::ir::Ty::decode(buf.skip(23))?;
                let defs = crate::vec::Vec::<super::super::ir::TyDef>::decode(buf.skip(46))?;
                Ok(ProgramType {
                    input,
                    output,
                    defs,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for SqlProgram {
            type HeadPtr = SqlProgramHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let sql = self.sql.encode_head(buf);
                let input_ty = self.input_ty.encode_head(buf);
                let output_ty = self.output_ty.encode_head(buf);
                let defs = self.defs.encode_head(buf);
                SqlProgramHeadPtr {
                    sql,
                    input_ty,
                    output_ty,
                    defs,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.sql.encode_body(head.sql, buf);
                self.input_ty.encode_body(head.input_ty, buf);
                self.output_ty.encode_body(head.output_ty, buf);
                self.defs.encode_body(head.defs, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct SqlProgramHeadPtr {
            sql: <crate::string::String as crate::Encode>::HeadPtr,
            input_ty: <super::super::ir::Ty as crate::Encode>::HeadPtr,
            output_ty: <super::super::ir::Ty as crate::Encode>::HeadPtr,
            defs: <crate::vec::Vec<super::super::ir::TyDef> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for SqlProgram {
            fn head_size() -> usize {
                496
            }
        }

        impl crate::Decode for SqlProgram {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let sql = crate::string::String::decode(buf.skip(0))?;
                let input_ty = super::super::ir::Ty::decode(buf.skip(8))?;
                let output_ty = super::super::ir::Ty::decode(buf.skip(31))?;
                let defs = crate::vec::Vec::<super::super::ir::TyDef>::decode(buf.skip(54))?;
                Ok(SqlProgram {
                    sql,
                    input_ty,
                    output_ty,
                    defs,
                })
            }
        }
    }
}

pub mod layout {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumFormat {
        pub tag_bytes: u8,
        pub inner_bytes: u8,
        pub has_ptr: bool,
        pub variants: crate::vec::Vec<EnumVariantFormat>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumVariantFormat {
        pub is_unit: bool,
        pub padding_bytes: u8,
    }

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::ReaderExt;
        use crate::bytes::BufMut;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumFormat {
            type HeadPtr = EnumFormatHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let tag_bytes = self.tag_bytes.encode_head(buf);
                let inner_bytes = self.inner_bytes.encode_head(buf);
                let has_ptr = self.has_ptr.encode_head(buf);
                let variants = self.variants.encode_head(buf);
                EnumFormatHeadPtr {
                    tag_bytes,
                    inner_bytes,
                    has_ptr,
                    variants,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.tag_bytes.encode_body(head.tag_bytes, buf);
                self.inner_bytes.encode_body(head.inner_bytes, buf);
                self.has_ptr.encode_body(head.has_ptr, buf);
                self.variants.encode_body(head.variants, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumFormatHeadPtr {
            tag_bytes: <u8 as crate::Encode>::HeadPtr,
            inner_bytes: <u8 as crate::Encode>::HeadPtr,
            has_ptr: <bool as crate::Encode>::HeadPtr,
            variants: <crate::vec::Vec<super::EnumVariantFormat> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumFormat {
            fn head_size() -> usize {
                88
            }
        }

        impl crate::Decode for EnumFormat {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let tag_bytes = u8::decode(buf.skip(0))?;
                let inner_bytes = u8::decode(buf.skip(1))?;
                let has_ptr = bool::decode(buf.skip(2))?;
                let variants = crate::vec::Vec::<super::EnumVariantFormat>::decode(buf.skip(3))?;
                Ok(EnumFormat {
                    tag_bytes,
                    inner_bytes,
                    has_ptr,
                    variants,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumVariantFormat {
            type HeadPtr = EnumVariantFormatHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let is_unit = self.is_unit.encode_head(buf);
                let padding_bytes = self.padding_bytes.encode_head(buf);
                EnumVariantFormatHeadPtr {
                    is_unit,
                    padding_bytes,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.is_unit.encode_body(head.is_unit, buf);
                self.padding_bytes.encode_body(head.padding_bytes, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumVariantFormatHeadPtr {
            is_unit: <bool as crate::Encode>::HeadPtr,
            padding_bytes: <u8 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumVariantFormat {
            fn head_size() -> usize {
                16
            }
        }

        impl crate::Decode for EnumVariantFormat {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let is_unit = bool::decode(buf.skip(0))?;
                let padding_bytes = u8::decode(buf.skip(1))?;
                Ok(EnumVariantFormat {
                    is_unit,
                    padding_bytes,
                })
            }
        }
    }
}

pub mod ir {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Program {
        pub main: Expr,
        pub defs: crate::vec::Vec<TyDef>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Expr {
        pub kind: ExprKind,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum ExprKind {
        Pointer(Pointer),
        Literal(Literal),
        Call(crate::boxed::Box<Call>),
        Function(crate::boxed::Box<Function>),
        Tuple(crate::vec::Vec<TupleField>),
        Array(crate::vec::Vec<Expr>),
        EnumVariant(crate::boxed::Box<EnumVariant>),
        EnumEq(crate::boxed::Box<EnumEq>),
        EnumUnwrap(crate::boxed::Box<EnumUnwrap>),
        TupleLookup(crate::boxed::Box<TupleLookup>),
        Binding(crate::boxed::Box<Binding>),
        Switch(crate::vec::Vec<SwitchBranch>),
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Pointer {
        External(ExternalPtr),
        Binding(u32),
        Parameter(ParameterPtr),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ExternalPtr {
        pub id: crate::string::String,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ParameterPtr {
        pub function_id: u32,
        pub param_position: u8,
    }

    #[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum Literal {
        bool(bool),
        int8(i8),
        int16(i16),
        int32(i32),
        int64(i64),
        uint8(u8),
        uint16(u16),
        uint32(u32),
        uint64(u64),
        float32(f32),
        float64(f64),
        text(crate::string::String),
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Call {
        pub function: Expr,
        pub args: crate::vec::Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Function {
        pub id: u32,
        pub body: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleField {
        pub expr: Expr,
        pub unpack: bool,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumVariant {
        pub tag: u64,
        pub inner: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumEq {
        pub subject: Expr,
        pub tag: u64,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumUnwrap {
        pub subject: Expr,
        pub tag: u64,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleLookup {
        pub base: Expr,
        pub position: u16,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Binding {
        pub id: u32,
        pub expr: Expr,
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct SwitchBranch {
        pub condition: Expr,
        pub value: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TyDef {
        pub name: Path,
        pub ty: Ty,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Ty {
        pub kind: TyKind,
        pub layout: core::option::Option<TyLayout>,
        pub name: core::option::Option<crate::string::String>,
        pub variants_recursive: crate::vec::Vec<u16>,
    }

    #[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum TyKind {
        Primitive(TyPrimitive),
        Tuple(crate::vec::Vec<TyTupleField>),
        Array(crate::boxed::Box<Ty>),
        Enum(crate::vec::Vec<TyEnumVariant>),
        Function(crate::boxed::Box<TyFunction>),
        Ident(Path),
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum TyPrimitive {
        bool,
        int8,
        int16,
        int32,
        int64,
        uint8,
        uint16,
        uint32,
        uint64,
        float32,
        float64,
        text,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyTupleField {
        pub name: core::option::Option<crate::string::String>,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyEnumVariant {
        pub name: crate::string::String,
        pub ty: Ty,
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub struct TyLayout {
        pub head_size: u32,
        pub body_ptrs: crate::vec::Vec<u32>,
    }

    #[derive(Debug, Clone, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct TyFunction {
        pub params: crate::vec::Vec<Ty>,
        pub body: Ty,
    }

    #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Path(pub crate::vec::Vec<crate::string::String>);

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Module {
        pub decls: crate::vec::Vec<ModuledeclsItems>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct ModuledeclsItems {
        pub name: crate::string::String,
        pub decl: Decl,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub enum Decl {
        Module(crate::boxed::Box<Module>),
        Type(Ty),
        Var(Ty),
    }

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::ReaderExt;
        use crate::bytes::BufMut;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let main = self.main.encode_head(buf);
                let defs = self.defs.encode_head(buf);
                ProgramHeadPtr { main, defs }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.main.encode_body(head.main, buf);
                self.defs.encode_body(head.defs, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramHeadPtr {
            main: <super::Expr as crate::Encode>::HeadPtr,
            defs: <crate::vec::Vec<super::TyDef> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                288
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let main = super::Expr::decode(buf.skip(0))?;
                let defs = crate::vec::Vec::<super::TyDef>::decode(buf.skip(28))?;
                Ok(Program { main, defs })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Expr {
            type HeadPtr = ExprHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let kind = self.kind.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                ExprHeadPtr { kind, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.kind.encode_body(head.kind, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExprHeadPtr {
            kind: <super::ExprKind as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Expr {
            fn head_size() -> usize {
                224
            }
        }

        impl crate::Decode for Expr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::ExprKind::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(5))?;
                Ok(Expr { kind, ty })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExprKind {
            type HeadPtr = ExprKindHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> ExprKindHeadPtr {
                match self {
                    Self::Pointer(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Pointer(head_ptr);
                        r
                    }
                    Self::Literal(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Literal(head_ptr);
                        r
                    }
                    Self::Call(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Call(head_ptr);
                        r
                    }
                    Self::Function(inner) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Tuple(inner) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(inner) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::EnumVariant(inner) => {
                        w.put_slice(&[6]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::EnumVariant(head_ptr);
                        r
                    }
                    Self::EnumEq(inner) => {
                        w.put_slice(&[7]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::EnumEq(head_ptr);
                        r
                    }
                    Self::EnumUnwrap(inner) => {
                        w.put_slice(&[8]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::EnumUnwrap(head_ptr);
                        r
                    }
                    Self::TupleLookup(inner) => {
                        w.put_slice(&[9]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::TupleLookup(head_ptr);
                        r
                    }
                    Self::Binding(inner) => {
                        w.put_slice(&[10]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Binding(head_ptr);
                        r
                    }
                    Self::Switch(inner) => {
                        w.put_slice(&[11]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Switch(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: ExprKindHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Pointer(inner) => {
                        let ExprKindHeadPtr::Pointer(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Literal(inner) => {
                        let ExprKindHeadPtr::Literal(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Call(inner) => {
                        let ExprKindHeadPtr::Call(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Function(inner) => {
                        let ExprKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Tuple(inner) => {
                        let ExprKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Array(inner) => {
                        let ExprKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::EnumVariant(inner) => {
                        let ExprKindHeadPtr::EnumVariant(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::EnumEq(inner) => {
                        let ExprKindHeadPtr::EnumEq(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::EnumUnwrap(inner) => {
                        let ExprKindHeadPtr::EnumUnwrap(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::TupleLookup(inner) => {
                        let ExprKindHeadPtr::TupleLookup(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Binding(inner) => {
                        let ExprKindHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Switch(inner) => {
                        let ExprKindHeadPtr::Switch(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExprKindHeadPtr {
            None,
            Pointer(crate::ReversePointer),
            Literal(crate::ReversePointer),
            Call(crate::ReversePointer),
            Function(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            EnumVariant(crate::ReversePointer),
            EnumEq(crate::ReversePointer),
            EnumUnwrap(crate::ReversePointer),
            TupleLookup(crate::ReversePointer),
            Binding(crate::ReversePointer),
            Switch(crate::ReversePointer),
        }
        impl crate::Layout for ExprKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExprKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Pointer::decode(buf.skip(offset as usize))?;
                        ExprKind::Pointer(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Literal::decode(buf.skip(offset as usize))?;
                        ExprKind::Literal(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Call::decode(buf.skip(offset as usize))?;
                        ExprKind::Call(crate::boxed::Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Function::decode(buf.skip(offset as usize))?;
                        ExprKind::Function(crate::boxed::Box::new(inner))
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::TupleField>::decode(
                            buf.skip(offset as usize),
                        )?;
                        ExprKind::Tuple(inner)
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner =
                            crate::vec::Vec::<super::Expr>::decode(buf.skip(offset as usize))?;
                        ExprKind::Array(inner)
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::EnumVariant::decode(buf.skip(offset as usize))?;
                        ExprKind::EnumVariant(crate::boxed::Box::new(inner))
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::EnumEq::decode(buf.skip(offset as usize))?;
                        ExprKind::EnumEq(crate::boxed::Box::new(inner))
                    }
                    8 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::EnumUnwrap::decode(buf.skip(offset as usize))?;
                        ExprKind::EnumUnwrap(crate::boxed::Box::new(inner))
                    }
                    9 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TupleLookup::decode(buf.skip(offset as usize))?;
                        ExprKind::TupleLookup(crate::boxed::Box::new(inner))
                    }
                    10 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Binding::decode(buf.skip(offset as usize))?;
                        ExprKind::Binding(crate::boxed::Box::new(inner))
                    }
                    11 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::SwitchBranch>::decode(
                            buf.skip(offset as usize),
                        )?;
                        ExprKind::Switch(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Pointer {
            type HeadPtr = PointerHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> PointerHeadPtr {
                match self {
                    Self::External(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::External(head_ptr);
                        r
                    }
                    Self::Binding(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::Binding(head_ptr);
                        r
                    }
                    Self::Parameter(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = PointerHeadPtr::Parameter(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: PointerHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::External(inner) => {
                        let PointerHeadPtr::External(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Binding(inner) => {
                        let PointerHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Parameter(inner) => {
                        let PointerHeadPtr::Parameter(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum PointerHeadPtr {
            None,
            External(crate::ReversePointer),
            Binding(crate::ReversePointer),
            Parameter(crate::ReversePointer),
        }
        impl crate::Layout for Pointer {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Pointer {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::ExternalPtr::decode(buf.skip(offset as usize))?;
                        Pointer::External(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = u32::decode(buf.skip(offset as usize))?;
                        Pointer::Binding(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::ParameterPtr::decode(buf.skip(offset as usize))?;
                        Pointer::Parameter(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ExternalPtr {
            type HeadPtr = ExternalPtrHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                ExternalPtrHeadPtr { id }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExternalPtrHeadPtr {
            id: <crate::string::String as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ExternalPtr {
            fn head_size() -> usize {
                64
            }
        }

        impl crate::Decode for ExternalPtr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = crate::string::String::decode(buf.skip(0))?;
                Ok(ExternalPtr { id })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ParameterPtr {
            type HeadPtr = ParameterPtrHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let function_id = self.function_id.encode_head(buf);
                let param_position = self.param_position.encode_head(buf);
                ParameterPtrHeadPtr {
                    function_id,
                    param_position,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.function_id.encode_body(head.function_id, buf);
                self.param_position.encode_body(head.param_position, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ParameterPtrHeadPtr {
            function_id: <u32 as crate::Encode>::HeadPtr,
            param_position: <u8 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ParameterPtr {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ParameterPtr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function_id = u32::decode(buf.skip(0))?;
                let param_position = u8::decode(buf.skip(4))?;
                Ok(ParameterPtr {
                    function_id,
                    param_position,
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Literal {
            type HeadPtr = LiteralHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> LiteralHeadPtr {
                match self {
                    Self::bool(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::bool(head_ptr);
                        r
                    }
                    Self::int8(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::int8(head_ptr);
                        r
                    }
                    Self::int16(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::int16(head_ptr);
                        r
                    }
                    Self::int32(inner) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::int32(head_ptr);
                        r
                    }
                    Self::int64(inner) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::int64(head_ptr);
                        r
                    }
                    Self::uint8(inner) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::uint8(head_ptr);
                        r
                    }
                    Self::uint16(inner) => {
                        w.put_slice(&[6]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::uint16(head_ptr);
                        r
                    }
                    Self::uint32(inner) => {
                        w.put_slice(&[7]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::uint32(head_ptr);
                        r
                    }
                    Self::uint64(inner) => {
                        w.put_slice(&[8]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::uint64(head_ptr);
                        r
                    }
                    Self::float32(inner) => {
                        w.put_slice(&[9]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::float32(head_ptr);
                        r
                    }
                    Self::float64(inner) => {
                        w.put_slice(&[10]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::float64(head_ptr);
                        r
                    }
                    Self::text(inner) => {
                        w.put_slice(&[11]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = LiteralHeadPtr::text(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: LiteralHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::bool(inner) => {
                        let LiteralHeadPtr::bool(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::int8(inner) => {
                        let LiteralHeadPtr::int8(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::int16(inner) => {
                        let LiteralHeadPtr::int16(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::int32(inner) => {
                        let LiteralHeadPtr::int32(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::int64(inner) => {
                        let LiteralHeadPtr::int64(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::uint8(inner) => {
                        let LiteralHeadPtr::uint8(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::uint16(inner) => {
                        let LiteralHeadPtr::uint16(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::uint32(inner) => {
                        let LiteralHeadPtr::uint32(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::uint64(inner) => {
                        let LiteralHeadPtr::uint64(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::float32(inner) => {
                        let LiteralHeadPtr::float32(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::float64(inner) => {
                        let LiteralHeadPtr::float64(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::text(inner) => {
                        let LiteralHeadPtr::text(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum LiteralHeadPtr {
            None,
            bool(crate::ReversePointer),
            int8(crate::ReversePointer),
            int16(crate::ReversePointer),
            int32(crate::ReversePointer),
            int64(crate::ReversePointer),
            uint8(crate::ReversePointer),
            uint16(crate::ReversePointer),
            uint32(crate::ReversePointer),
            uint64(crate::ReversePointer),
            float32(crate::ReversePointer),
            float64(crate::ReversePointer),
            text(crate::ReversePointer),
        }
        impl crate::Layout for Literal {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Literal {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = bool::decode(buf.skip(offset as usize))?;
                        Literal::bool(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = i8::decode(buf.skip(offset as usize))?;
                        Literal::int8(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = i16::decode(buf.skip(offset as usize))?;
                        Literal::int16(inner)
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = i32::decode(buf.skip(offset as usize))?;
                        Literal::int32(inner)
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = i64::decode(buf.skip(offset as usize))?;
                        Literal::int64(inner)
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = u8::decode(buf.skip(offset as usize))?;
                        Literal::uint8(inner)
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = u16::decode(buf.skip(offset as usize))?;
                        Literal::uint16(inner)
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = u32::decode(buf.skip(offset as usize))?;
                        Literal::uint32(inner)
                    }
                    8 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = u64::decode(buf.skip(offset as usize))?;
                        Literal::uint64(inner)
                    }
                    9 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = f32::decode(buf.skip(offset as usize))?;
                        Literal::float32(inner)
                    }
                    10 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = f64::decode(buf.skip(offset as usize))?;
                        Literal::float64(inner)
                    }
                    11 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::string::String::decode(buf.skip(offset as usize))?;
                        Literal::text(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Call {
            type HeadPtr = CallHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let function = self.function.encode_head(buf);
                let args = self.args.encode_head(buf);
                CallHeadPtr { function, args }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.function.encode_body(head.function, buf);
                self.args.encode_body(head.args, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct CallHeadPtr {
            function: <super::Expr as crate::Encode>::HeadPtr,
            args: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Call {
            fn head_size() -> usize {
                288
            }
        }

        impl crate::Decode for Call {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function = super::Expr::decode(buf.skip(0))?;
                let args = crate::vec::Vec::<super::Expr>::decode(buf.skip(28))?;
                Ok(Call { function, args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Function {
            type HeadPtr = FunctionHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                let body = self.body.encode_head(buf);
                FunctionHeadPtr { id, body }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
                self.body.encode_body(head.body, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct FunctionHeadPtr {
            id: <u32 as crate::Encode>::HeadPtr,
            body: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Function {
            fn head_size() -> usize {
                256
            }
        }

        impl crate::Decode for Function {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = u32::decode(buf.skip(0))?;
                let body = super::Expr::decode(buf.skip(4))?;
                Ok(Function { id, body })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleField {
            type HeadPtr = TupleFieldHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let expr = self.expr.encode_head(buf);
                let unpack = self.unpack.encode_head(buf);
                TupleFieldHeadPtr { expr, unpack }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.expr.encode_body(head.expr, buf);
                self.unpack.encode_body(head.unpack, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleFieldHeadPtr {
            expr: <super::Expr as crate::Encode>::HeadPtr,
            unpack: <bool as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleField {
            fn head_size() -> usize {
                232
            }
        }

        impl crate::Decode for TupleField {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let expr = super::Expr::decode(buf.skip(0))?;
                let unpack = bool::decode(buf.skip(28))?;
                Ok(TupleField { expr, unpack })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumVariant {
            type HeadPtr = EnumVariantHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let tag = self.tag.encode_head(buf);
                let inner = self.inner.encode_head(buf);
                EnumVariantHeadPtr { tag, inner }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.tag.encode_body(head.tag, buf);
                self.inner.encode_body(head.inner, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumVariantHeadPtr {
            tag: <u64 as crate::Encode>::HeadPtr,
            inner: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumVariant {
            fn head_size() -> usize {
                288
            }
        }

        impl crate::Decode for EnumVariant {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let tag = u64::decode(buf.skip(0))?;
                let inner = super::Expr::decode(buf.skip(8))?;
                Ok(EnumVariant { tag, inner })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumEq {
            type HeadPtr = EnumEqHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let subject = self.subject.encode_head(buf);
                let tag = self.tag.encode_head(buf);
                EnumEqHeadPtr { subject, tag }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.subject.encode_body(head.subject, buf);
                self.tag.encode_body(head.tag, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumEqHeadPtr {
            subject: <super::Expr as crate::Encode>::HeadPtr,
            tag: <u64 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumEq {
            fn head_size() -> usize {
                288
            }
        }

        impl crate::Decode for EnumEq {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let subject = super::Expr::decode(buf.skip(0))?;
                let tag = u64::decode(buf.skip(28))?;
                Ok(EnumEq { subject, tag })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumUnwrap {
            type HeadPtr = EnumUnwrapHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let subject = self.subject.encode_head(buf);
                let tag = self.tag.encode_head(buf);
                EnumUnwrapHeadPtr { subject, tag }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.subject.encode_body(head.subject, buf);
                self.tag.encode_body(head.tag, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumUnwrapHeadPtr {
            subject: <super::Expr as crate::Encode>::HeadPtr,
            tag: <u64 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumUnwrap {
            fn head_size() -> usize {
                288
            }
        }

        impl crate::Decode for EnumUnwrap {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let subject = super::Expr::decode(buf.skip(0))?;
                let tag = u64::decode(buf.skip(28))?;
                Ok(EnumUnwrap { subject, tag })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleLookup {
            type HeadPtr = TupleLookupHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let base = self.base.encode_head(buf);
                let position = self.position.encode_head(buf);
                TupleLookupHeadPtr { base, position }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.base.encode_body(head.base, buf);
                self.position.encode_body(head.position, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleLookupHeadPtr {
            base: <super::Expr as crate::Encode>::HeadPtr,
            position: <u16 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleLookup {
            fn head_size() -> usize {
                240
            }
        }

        impl crate::Decode for TupleLookup {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let base = super::Expr::decode(buf.skip(0))?;
                let position = u16::decode(buf.skip(28))?;
                Ok(TupleLookup { base, position })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Binding {
            type HeadPtr = BindingHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                let expr = self.expr.encode_head(buf);
                let main = self.main.encode_head(buf);
                BindingHeadPtr { id, expr, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
                self.expr.encode_body(head.expr, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BindingHeadPtr {
            id: <u32 as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Binding {
            fn head_size() -> usize {
                480
            }
        }

        impl crate::Decode for Binding {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = u32::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(4))?;
                let main = super::Expr::decode(buf.skip(32))?;
                Ok(Binding { id, expr, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for SwitchBranch {
            type HeadPtr = SwitchBranchHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let condition = self.condition.encode_head(buf);
                let value = self.value.encode_head(buf);
                SwitchBranchHeadPtr { condition, value }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.condition.encode_body(head.condition, buf);
                self.value.encode_body(head.value, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct SwitchBranchHeadPtr {
            condition: <super::Expr as crate::Encode>::HeadPtr,
            value: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for SwitchBranch {
            fn head_size() -> usize {
                448
            }
        }

        impl crate::Decode for SwitchBranch {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let condition = super::Expr::decode(buf.skip(0))?;
                let value = super::Expr::decode(buf.skip(28))?;
                Ok(SwitchBranch { condition, value })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyDef {
            type HeadPtr = TyDefHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let name = self.name.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                TyDefHeadPtr { name, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.name.encode_body(head.name, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyDefHeadPtr {
            name: <super::Path as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyDef {
            fn head_size() -> usize {
                248
            }
        }

        impl crate::Decode for TyDef {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = super::Path::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(8))?;
                Ok(TyDef { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Ty {
            type HeadPtr = TyHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let kind = self.kind.encode_head(buf);
                let layout = self.layout.encode_head(buf);
                let name = self.name.encode_head(buf);
                let variants_recursive = self.variants_recursive.encode_head(buf);
                TyHeadPtr {
                    kind,
                    layout,
                    name,
                    variants_recursive,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.kind.encode_body(head.kind, buf);
                self.layout.encode_body(head.layout, buf);
                self.name.encode_body(head.name, buf);
                self.variants_recursive
                    .encode_body(head.variants_recursive, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyHeadPtr {
            kind: <super::TyKind as crate::Encode>::HeadPtr,
            layout: <core::option::Option<super::TyLayout> as crate::Encode>::HeadPtr,
            name: <core::option::Option<crate::string::String> as crate::Encode>::HeadPtr,
            variants_recursive: <crate::vec::Vec<u16> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Ty {
            fn head_size() -> usize {
                184
            }
        }

        impl crate::Decode for Ty {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::TyKind::decode(buf.skip(0))?;
                let layout = core::option::Option::<super::TyLayout>::decode(buf.skip(5))?;
                let name = core::option::Option::<crate::string::String>::decode(buf.skip(10))?;
                let variants_recursive = crate::vec::Vec::<u16>::decode(buf.skip(15))?;
                Ok(Ty {
                    kind,
                    layout,
                    name,
                    variants_recursive,
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for TyKind {
            type HeadPtr = TyKindHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> TyKindHeadPtr {
                match self {
                    Self::Primitive(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Primitive(head_ptr);
                        r
                    }
                    Self::Tuple(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::Enum(inner) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Enum(head_ptr);
                        r
                    }
                    Self::Function(inner) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Ident(inner) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = TyKindHeadPtr::Ident(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: TyKindHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Primitive(inner) => {
                        let TyKindHeadPtr::Primitive(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Tuple(inner) => {
                        let TyKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Array(inner) => {
                        let TyKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Enum(inner) => {
                        let TyKindHeadPtr::Enum(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Function(inner) => {
                        let TyKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Ident(inner) => {
                        let TyKindHeadPtr::Ident(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum TyKindHeadPtr {
            None,
            Primitive(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            Enum(crate::ReversePointer),
            Function(crate::ReversePointer),
            Ident(crate::ReversePointer),
        }
        impl crate::Layout for TyKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for TyKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TyPrimitive::decode(buf.skip(offset as usize))?;
                        TyKind::Primitive(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::TyTupleField>::decode(
                            buf.skip(offset as usize),
                        )?;
                        TyKind::Tuple(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Ty::decode(buf.skip(offset as usize))?;
                        TyKind::Array(crate::boxed::Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::TyEnumVariant>::decode(
                            buf.skip(offset as usize),
                        )?;
                        TyKind::Enum(inner)
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::TyFunction::decode(buf.skip(offset as usize))?;
                        TyKind::Function(crate::boxed::Box::new(inner))
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Path::decode(buf.skip(offset as usize))?;
                        TyKind::Ident(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for TyPrimitive {
            type HeadPtr = ();
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> () {
                match self {
                    Self::bool => {
                        w.put_slice(&[0]);
                    }
                    Self::int8 => {
                        w.put_slice(&[1]);
                    }
                    Self::int16 => {
                        w.put_slice(&[2]);
                    }
                    Self::int32 => {
                        w.put_slice(&[3]);
                    }
                    Self::int64 => {
                        w.put_slice(&[4]);
                    }
                    Self::uint8 => {
                        w.put_slice(&[5]);
                    }
                    Self::uint16 => {
                        w.put_slice(&[6]);
                    }
                    Self::uint32 => {
                        w.put_slice(&[7]);
                    }
                    Self::uint64 => {
                        w.put_slice(&[8]);
                    }
                    Self::float32 => {
                        w.put_slice(&[9]);
                    }
                    Self::float64 => {
                        w.put_slice(&[10]);
                    }
                    Self::text => {
                        w.put_slice(&[11]);
                    }
                }
            }
            fn encode_body(&self, head: (), w: &mut crate::bytes::BytesMut) {}
        }
        impl crate::Layout for TyPrimitive {
            fn head_size() -> usize {
                8
            }
        }

        impl crate::Decode for TyPrimitive {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                Ok(match tag {
                    0 => TyPrimitive::bool,
                    1 => TyPrimitive::int8,
                    2 => TyPrimitive::int16,
                    3 => TyPrimitive::int32,
                    4 => TyPrimitive::int64,
                    5 => TyPrimitive::uint8,
                    6 => TyPrimitive::uint16,
                    7 => TyPrimitive::uint32,
                    8 => TyPrimitive::uint64,
                    9 => TyPrimitive::float32,
                    10 => TyPrimitive::float64,
                    11 => TyPrimitive::text,
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyTupleField {
            type HeadPtr = TyTupleFieldHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let name = self.name.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                TyTupleFieldHeadPtr { name, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.name.encode_body(head.name, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyTupleFieldHeadPtr {
            name: <core::option::Option<crate::string::String> as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyTupleField {
            fn head_size() -> usize {
                224
            }
        }

        impl crate::Decode for TyTupleField {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = core::option::Option::<crate::string::String>::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(5))?;
                Ok(TyTupleField { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyEnumVariant {
            type HeadPtr = TyEnumVariantHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let name = self.name.encode_head(buf);
                let ty = self.ty.encode_head(buf);
                TyEnumVariantHeadPtr { name, ty }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.name.encode_body(head.name, buf);
                self.ty.encode_body(head.ty, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyEnumVariantHeadPtr {
            name: <crate::string::String as crate::Encode>::HeadPtr,
            ty: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyEnumVariant {
            fn head_size() -> usize {
                248
            }
        }

        impl crate::Decode for TyEnumVariant {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = crate::string::String::decode(buf.skip(0))?;
                let ty = super::Ty::decode(buf.skip(8))?;
                Ok(TyEnumVariant { name, ty })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyLayout {
            type HeadPtr = TyLayoutHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let head_size = self.head_size.encode_head(buf);
                let body_ptrs = self.body_ptrs.encode_head(buf);
                TyLayoutHeadPtr {
                    head_size,
                    body_ptrs,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.head_size.encode_body(head.head_size, buf);
                self.body_ptrs.encode_body(head.body_ptrs, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyLayoutHeadPtr {
            head_size: <u32 as crate::Encode>::HeadPtr,
            body_ptrs: <crate::vec::Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyLayout {
            fn head_size() -> usize {
                96
            }
        }

        impl crate::Decode for TyLayout {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let head_size = u32::decode(buf.skip(0))?;
                let body_ptrs = crate::vec::Vec::<u32>::decode(buf.skip(4))?;
                Ok(TyLayout {
                    head_size,
                    body_ptrs,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyFunction {
            type HeadPtr = TyFunctionHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let params = self.params.encode_head(buf);
                let body = self.body.encode_head(buf);
                TyFunctionHeadPtr { params, body }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.params.encode_body(head.params, buf);
                self.body.encode_body(head.body, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyFunctionHeadPtr {
            params: <crate::vec::Vec<super::Ty> as crate::Encode>::HeadPtr,
            body: <super::Ty as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyFunction {
            fn head_size() -> usize {
                248
            }
        }

        impl crate::Decode for TyFunction {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let params = crate::vec::Vec::<super::Ty>::decode(buf.skip(0))?;
                let body = super::Ty::decode(buf.skip(8))?;
                Ok(TyFunction { params, body })
            }
        }

        impl crate::Encode for Path {
            type HeadPtr = crate::ReversePointer;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                self.0.encode_head(buf)
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.0.encode_body(head, buf)
            }
        }
        impl crate::Layout for Path {
            fn head_size() -> usize {
                64
            }
        }

        impl crate::Decode for Path {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                Ok(Self(crate::vec::Vec::<crate::string::String>::decode(buf)?))
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Module {
            type HeadPtr = ModuleHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let decls = self.decls.encode_head(buf);
                ModuleHeadPtr { decls }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.decls.encode_body(head.decls, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ModuleHeadPtr {
            decls: <crate::vec::Vec<ModuledeclsItems> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Module {
            fn head_size() -> usize {
                64
            }
        }

        impl crate::Decode for Module {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let decls = crate::vec::Vec::<ModuledeclsItems>::decode(buf.skip(0))?;
                Ok(Module { decls })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ModuledeclsItems {
            type HeadPtr = ModuledeclsItemsHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let name = self.name.encode_head(buf);
                let decl = self.decl.encode_head(buf);
                ModuledeclsItemsHeadPtr { name, decl }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.name.encode_body(head.name, buf);
                self.decl.encode_body(head.decl, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ModuledeclsItemsHeadPtr {
            name: <crate::string::String as crate::Encode>::HeadPtr,
            decl: <super::Decl as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ModuledeclsItems {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for ModuledeclsItems {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let name = crate::string::String::decode(buf.skip(0))?;
                let decl = super::Decl::decode(buf.skip(8))?;
                Ok(ModuledeclsItems { name, decl })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for Decl {
            type HeadPtr = DeclHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> DeclHeadPtr {
                match self {
                    Self::Module(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = DeclHeadPtr::Module(head_ptr);
                        r
                    }
                    Self::Type(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = DeclHeadPtr::Type(head_ptr);
                        r
                    }
                    Self::Var(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = DeclHeadPtr::Var(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: DeclHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Module(inner) => {
                        let DeclHeadPtr::Module(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Type(inner) => {
                        let DeclHeadPtr::Type(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Var(inner) => {
                        let DeclHeadPtr::Var(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum DeclHeadPtr {
            None,
            Module(crate::ReversePointer),
            Type(crate::ReversePointer),
            Var(crate::ReversePointer),
        }
        impl crate::Layout for Decl {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Decl {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Module::decode(buf.skip(offset as usize))?;
                        Decl::Module(crate::boxed::Box::new(inner))
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Ty::decode(buf.skip(offset as usize))?;
                        Decl::Type(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Ty::decode(buf.skip(offset as usize))?;
                        Decl::Var(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }
    }
}

pub mod br {
    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Program {
        pub externals: crate::vec::Vec<ExternalSymbol>,
        pub main: Expr,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct ExternalSymbol {
        pub id: crate::string::String,
        pub layout_args: crate::vec::Vec<u32>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Expr {
        pub kind: ExprKind,
    }

    #[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
    #[allow(non_camel_case_types)]
    pub enum ExprKind {
        Pointer(Sid),
        Literal(crate::vec::Vec<u8>),
        Call(crate::boxed::Box<Call>),
        Function(crate::boxed::Box<Function>),
        Tuple(crate::boxed::Box<Tuple>),
        Array(crate::boxed::Box<Array>),
        EnumVariant(crate::boxed::Box<EnumVariant>),
        EnumEq(crate::boxed::Box<EnumEq>),
        Offset(crate::boxed::Box<Offset>),
        Deref(crate::boxed::Box<Deref>),
        Binding(crate::boxed::Box<Binding>),
        Switch(crate::vec::Vec<SwitchBranch>),
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub struct Sid(pub u32);

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Call {
        pub function: Expr,
        pub args: crate::vec::Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Function {
        pub symbol_ns: Sid,
        pub body: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Tuple {
        pub fields: crate::vec::Vec<TupleField>,
        pub field_layouts: crate::vec::Vec<TyLayout>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct TupleField {
        pub expr: Expr,
        pub unpack: u8,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Array {
        pub item_layout: TyLayout,
        pub items: crate::vec::Vec<Expr>,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumVariant {
        pub tag: crate::vec::Vec<u8>,
        pub inner_bytes: u8,
        pub has_ptr: bool,
        pub padding_bytes: u8,
        pub inner: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct EnumEq {
        pub tag: crate::vec::Vec<u8>,
        pub expr: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Offset {
        pub base: Expr,
        pub offset: u32,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Deref {
        pub ptr: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct Binding {
        pub symbol: Sid,
        pub expr: Expr,
        pub main: Expr,
    }

    #[derive(Debug, Clone)]
    #[allow(non_camel_case_types)]
    pub struct SwitchBranch {
        pub condition: Expr,
        pub value: Expr,
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub struct TyLayout {
        pub head_size: u32,
        pub body_ptrs: crate::vec::Vec<u32>,
    }

    mod impls {
        #![allow(unused_imports)]
        use super::*;
        use crate::ReaderExt;
        use crate::bytes::BufMut;

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Program {
            type HeadPtr = ProgramHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let externals = self.externals.encode_head(buf);
                let main = self.main.encode_head(buf);
                ProgramHeadPtr { externals, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.externals.encode_body(head.externals, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ProgramHeadPtr {
            externals: <crate::vec::Vec<super::ExternalSymbol> as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Program {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for Program {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let externals = crate::vec::Vec::<super::ExternalSymbol>::decode(buf.skip(0))?;
                let main = super::Expr::decode(buf.skip(8))?;
                Ok(Program { externals, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for ExternalSymbol {
            type HeadPtr = ExternalSymbolHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let id = self.id.encode_head(buf);
                let layout_args = self.layout_args.encode_head(buf);
                ExternalSymbolHeadPtr { id, layout_args }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.id.encode_body(head.id, buf);
                self.layout_args.encode_body(head.layout_args, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExternalSymbolHeadPtr {
            id: <crate::string::String as crate::Encode>::HeadPtr,
            layout_args: <crate::vec::Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for ExternalSymbol {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for ExternalSymbol {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let id = crate::string::String::decode(buf.skip(0))?;
                let layout_args = crate::vec::Vec::<u32>::decode(buf.skip(8))?;
                Ok(ExternalSymbol { id, layout_args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Expr {
            type HeadPtr = ExprHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let kind = self.kind.encode_head(buf);
                ExprHeadPtr { kind }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.kind.encode_body(head.kind, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ExprHeadPtr {
            kind: <super::ExprKind as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Expr {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Expr {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let kind = super::ExprKind::decode(buf.skip(0))?;
                Ok(Expr { kind })
            }
        }

        #[allow(unused_variables)]
        #[allow(clippy::all)]
        impl crate::Encode for ExprKind {
            type HeadPtr = ExprKindHeadPtr;
            fn encode_head(&self, w: &mut crate::bytes::BytesMut) -> ExprKindHeadPtr {
                match self {
                    Self::Pointer(inner) => {
                        w.put_slice(&[0]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Pointer(head_ptr);
                        r
                    }
                    Self::Literal(inner) => {
                        w.put_slice(&[1]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Literal(head_ptr);
                        r
                    }
                    Self::Call(inner) => {
                        w.put_slice(&[2]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Call(head_ptr);
                        r
                    }
                    Self::Function(inner) => {
                        w.put_slice(&[3]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Function(head_ptr);
                        r
                    }
                    Self::Tuple(inner) => {
                        w.put_slice(&[4]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Tuple(head_ptr);
                        r
                    }
                    Self::Array(inner) => {
                        w.put_slice(&[5]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Array(head_ptr);
                        r
                    }
                    Self::EnumVariant(inner) => {
                        w.put_slice(&[6]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::EnumVariant(head_ptr);
                        r
                    }
                    Self::EnumEq(inner) => {
                        w.put_slice(&[7]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::EnumEq(head_ptr);
                        r
                    }
                    Self::Offset(inner) => {
                        w.put_slice(&[8]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Offset(head_ptr);
                        r
                    }
                    Self::Deref(inner) => {
                        w.put_slice(&[9]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Deref(head_ptr);
                        r
                    }
                    Self::Binding(inner) => {
                        w.put_slice(&[10]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Binding(head_ptr);
                        r
                    }
                    Self::Switch(inner) => {
                        w.put_slice(&[11]);
                        let head_ptr = crate::ReversePointer::new(w);
                        let r = ExprKindHeadPtr::Switch(head_ptr);
                        r
                    }
                }
            }
            fn encode_body(&self, head: ExprKindHeadPtr, w: &mut crate::bytes::BytesMut) {
                match self {
                    Self::Pointer(inner) => {
                        let ExprKindHeadPtr::Pointer(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Literal(inner) => {
                        let ExprKindHeadPtr::Literal(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Call(inner) => {
                        let ExprKindHeadPtr::Call(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Function(inner) => {
                        let ExprKindHeadPtr::Function(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Tuple(inner) => {
                        let ExprKindHeadPtr::Tuple(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Array(inner) => {
                        let ExprKindHeadPtr::Array(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::EnumVariant(inner) => {
                        let ExprKindHeadPtr::EnumVariant(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::EnumEq(inner) => {
                        let ExprKindHeadPtr::EnumEq(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Offset(inner) => {
                        let ExprKindHeadPtr::Offset(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Deref(inner) => {
                        let ExprKindHeadPtr::Deref(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Binding(inner) => {
                        let ExprKindHeadPtr::Binding(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                    Self::Switch(inner) => {
                        let ExprKindHeadPtr::Switch(offset_ptr) = head else {
                            unreachable!()
                        };
                        offset_ptr.write_cur_len(w);
                        let inner_head_ptr = inner.encode_head(w);
                        inner.encode_body(inner_head_ptr, w);
                    }
                }
            }
        }
        #[allow(non_camel_case_types, dead_code)]
        pub enum ExprKindHeadPtr {
            None,
            Pointer(crate::ReversePointer),
            Literal(crate::ReversePointer),
            Call(crate::ReversePointer),
            Function(crate::ReversePointer),
            Tuple(crate::ReversePointer),
            Array(crate::ReversePointer),
            EnumVariant(crate::ReversePointer),
            EnumEq(crate::ReversePointer),
            Offset(crate::ReversePointer),
            Deref(crate::ReversePointer),
            Binding(crate::ReversePointer),
            Switch(crate::ReversePointer),
        }
        impl crate::Layout for ExprKind {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for ExprKind {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let mut tag_bytes = buf.read_n(1).to_vec();
                tag_bytes.resize(8, 0);
                let tag = u64::from_le_bytes(tag_bytes.try_into().unwrap()) as usize;
                let buf = buf.skip(1);
                Ok(match tag {
                    0 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Sid::decode(buf.skip(offset as usize))?;
                        ExprKind::Pointer(inner)
                    }
                    1 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<u8>::decode(buf.skip(offset as usize))?;
                        ExprKind::Literal(inner)
                    }
                    2 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Call::decode(buf.skip(offset as usize))?;
                        ExprKind::Call(crate::boxed::Box::new(inner))
                    }
                    3 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Function::decode(buf.skip(offset as usize))?;
                        ExprKind::Function(crate::boxed::Box::new(inner))
                    }
                    4 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Tuple::decode(buf.skip(offset as usize))?;
                        ExprKind::Tuple(crate::boxed::Box::new(inner))
                    }
                    5 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Array::decode(buf.skip(offset as usize))?;
                        ExprKind::Array(crate::boxed::Box::new(inner))
                    }
                    6 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::EnumVariant::decode(buf.skip(offset as usize))?;
                        ExprKind::EnumVariant(crate::boxed::Box::new(inner))
                    }
                    7 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::EnumEq::decode(buf.skip(offset as usize))?;
                        ExprKind::EnumEq(crate::boxed::Box::new(inner))
                    }
                    8 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Offset::decode(buf.skip(offset as usize))?;
                        ExprKind::Offset(crate::boxed::Box::new(inner))
                    }
                    9 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Deref::decode(buf.skip(offset as usize))?;
                        ExprKind::Deref(crate::boxed::Box::new(inner))
                    }
                    10 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = super::Binding::decode(buf.skip(offset as usize))?;
                        ExprKind::Binding(crate::boxed::Box::new(inner))
                    }
                    11 => {
                        let offset = u32::from_le_bytes(buf.read_const::<4>());
                        let inner = crate::vec::Vec::<super::SwitchBranch>::decode(
                            buf.skip(offset as usize),
                        )?;
                        ExprKind::Switch(inner)
                    }
                    _ => return Err(crate::Error::InvalidData),
                })
            }
        }

        impl crate::Encode for Sid {
            type HeadPtr = ();
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) {
                self.0.encode_head(buf)
            }
            fn encode_body(&self, _: (), _: &mut crate::bytes::BytesMut) {}
        }
        impl crate::Layout for Sid {
            fn head_size() -> usize {
                32
            }
        }

        impl crate::Decode for Sid {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                Ok(Self(u32::decode(buf)?))
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Call {
            type HeadPtr = CallHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let function = self.function.encode_head(buf);
                let args = self.args.encode_head(buf);
                CallHeadPtr { function, args }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.function.encode_body(head.function, buf);
                self.args.encode_body(head.args, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct CallHeadPtr {
            function: <super::Expr as crate::Encode>::HeadPtr,
            args: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Call {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for Call {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let function = super::Expr::decode(buf.skip(0))?;
                let args = crate::vec::Vec::<super::Expr>::decode(buf.skip(5))?;
                Ok(Call { function, args })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Function {
            type HeadPtr = FunctionHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let symbol_ns = self.symbol_ns.encode_head(buf);
                let body = self.body.encode_head(buf);
                FunctionHeadPtr { symbol_ns, body }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.symbol_ns.encode_body(head.symbol_ns, buf);
                self.body.encode_body(head.body, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct FunctionHeadPtr {
            symbol_ns: <super::Sid as crate::Encode>::HeadPtr,
            body: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Function {
            fn head_size() -> usize {
                72
            }
        }

        impl crate::Decode for Function {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let symbol_ns = super::Sid::decode(buf.skip(0))?;
                let body = super::Expr::decode(buf.skip(4))?;
                Ok(Function { symbol_ns, body })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Tuple {
            type HeadPtr = TupleHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let fields = self.fields.encode_head(buf);
                let field_layouts = self.field_layouts.encode_head(buf);
                TupleHeadPtr {
                    fields,
                    field_layouts,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.fields.encode_body(head.fields, buf);
                self.field_layouts.encode_body(head.field_layouts, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleHeadPtr {
            fields: <crate::vec::Vec<super::TupleField> as crate::Encode>::HeadPtr,
            field_layouts: <crate::vec::Vec<super::TyLayout> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Tuple {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for Tuple {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let fields = crate::vec::Vec::<super::TupleField>::decode(buf.skip(0))?;
                let field_layouts = crate::vec::Vec::<super::TyLayout>::decode(buf.skip(8))?;
                Ok(Tuple {
                    fields,
                    field_layouts,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TupleField {
            type HeadPtr = TupleFieldHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let expr = self.expr.encode_head(buf);
                let unpack = self.unpack.encode_head(buf);
                TupleFieldHeadPtr { expr, unpack }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.expr.encode_body(head.expr, buf);
                self.unpack.encode_body(head.unpack, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TupleFieldHeadPtr {
            expr: <super::Expr as crate::Encode>::HeadPtr,
            unpack: <u8 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TupleField {
            fn head_size() -> usize {
                48
            }
        }

        impl crate::Decode for TupleField {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let expr = super::Expr::decode(buf.skip(0))?;
                let unpack = u8::decode(buf.skip(5))?;
                Ok(TupleField { expr, unpack })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Array {
            type HeadPtr = ArrayHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let item_layout = self.item_layout.encode_head(buf);
                let items = self.items.encode_head(buf);
                ArrayHeadPtr { item_layout, items }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.item_layout.encode_body(head.item_layout, buf);
                self.items.encode_body(head.items, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct ArrayHeadPtr {
            item_layout: <super::TyLayout as crate::Encode>::HeadPtr,
            items: <crate::vec::Vec<super::Expr> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Array {
            fn head_size() -> usize {
                160
            }
        }

        impl crate::Decode for Array {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let item_layout = super::TyLayout::decode(buf.skip(0))?;
                let items = crate::vec::Vec::<super::Expr>::decode(buf.skip(12))?;
                Ok(Array { item_layout, items })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumVariant {
            type HeadPtr = EnumVariantHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let tag = self.tag.encode_head(buf);
                let inner_bytes = self.inner_bytes.encode_head(buf);
                let has_ptr = self.has_ptr.encode_head(buf);
                let padding_bytes = self.padding_bytes.encode_head(buf);
                let inner = self.inner.encode_head(buf);
                EnumVariantHeadPtr {
                    tag,
                    inner_bytes,
                    has_ptr,
                    padding_bytes,
                    inner,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.tag.encode_body(head.tag, buf);
                self.inner_bytes.encode_body(head.inner_bytes, buf);
                self.has_ptr.encode_body(head.has_ptr, buf);
                self.padding_bytes.encode_body(head.padding_bytes, buf);
                self.inner.encode_body(head.inner, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumVariantHeadPtr {
            tag: <crate::vec::Vec<u8> as crate::Encode>::HeadPtr,
            inner_bytes: <u8 as crate::Encode>::HeadPtr,
            has_ptr: <bool as crate::Encode>::HeadPtr,
            padding_bytes: <u8 as crate::Encode>::HeadPtr,
            inner: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumVariant {
            fn head_size() -> usize {
                128
            }
        }

        impl crate::Decode for EnumVariant {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let tag = crate::vec::Vec::<u8>::decode(buf.skip(0))?;
                let inner_bytes = u8::decode(buf.skip(8))?;
                let has_ptr = bool::decode(buf.skip(9))?;
                let padding_bytes = u8::decode(buf.skip(10))?;
                let inner = super::Expr::decode(buf.skip(11))?;
                Ok(EnumVariant {
                    tag,
                    inner_bytes,
                    has_ptr,
                    padding_bytes,
                    inner,
                })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for EnumEq {
            type HeadPtr = EnumEqHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let tag = self.tag.encode_head(buf);
                let expr = self.expr.encode_head(buf);
                EnumEqHeadPtr { tag, expr }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.tag.encode_body(head.tag, buf);
                self.expr.encode_body(head.expr, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct EnumEqHeadPtr {
            tag: <crate::vec::Vec<u8> as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for EnumEq {
            fn head_size() -> usize {
                104
            }
        }

        impl crate::Decode for EnumEq {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let tag = crate::vec::Vec::<u8>::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(8))?;
                Ok(EnumEq { tag, expr })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Offset {
            type HeadPtr = OffsetHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let base = self.base.encode_head(buf);
                let offset = self.offset.encode_head(buf);
                OffsetHeadPtr { base, offset }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.base.encode_body(head.base, buf);
                self.offset.encode_body(head.offset, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct OffsetHeadPtr {
            base: <super::Expr as crate::Encode>::HeadPtr,
            offset: <u32 as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Offset {
            fn head_size() -> usize {
                72
            }
        }

        impl crate::Decode for Offset {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let base = super::Expr::decode(buf.skip(0))?;
                let offset = u32::decode(buf.skip(5))?;
                Ok(Offset { base, offset })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Deref {
            type HeadPtr = DerefHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let ptr = self.ptr.encode_head(buf);
                DerefHeadPtr { ptr }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.ptr.encode_body(head.ptr, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct DerefHeadPtr {
            ptr: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Deref {
            fn head_size() -> usize {
                40
            }
        }

        impl crate::Decode for Deref {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let ptr = super::Expr::decode(buf.skip(0))?;
                Ok(Deref { ptr })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for Binding {
            type HeadPtr = BindingHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let symbol = self.symbol.encode_head(buf);
                let expr = self.expr.encode_head(buf);
                let main = self.main.encode_head(buf);
                BindingHeadPtr { symbol, expr, main }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.symbol.encode_body(head.symbol, buf);
                self.expr.encode_body(head.expr, buf);
                self.main.encode_body(head.main, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BindingHeadPtr {
            symbol: <super::Sid as crate::Encode>::HeadPtr,
            expr: <super::Expr as crate::Encode>::HeadPtr,
            main: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for Binding {
            fn head_size() -> usize {
                112
            }
        }

        impl crate::Decode for Binding {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let symbol = super::Sid::decode(buf.skip(0))?;
                let expr = super::Expr::decode(buf.skip(4))?;
                let main = super::Expr::decode(buf.skip(9))?;
                Ok(Binding { symbol, expr, main })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for SwitchBranch {
            type HeadPtr = SwitchBranchHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let condition = self.condition.encode_head(buf);
                let value = self.value.encode_head(buf);
                SwitchBranchHeadPtr { condition, value }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.condition.encode_body(head.condition, buf);
                self.value.encode_body(head.value, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct SwitchBranchHeadPtr {
            condition: <super::Expr as crate::Encode>::HeadPtr,
            value: <super::Expr as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for SwitchBranch {
            fn head_size() -> usize {
                80
            }
        }

        impl crate::Decode for SwitchBranch {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let condition = super::Expr::decode(buf.skip(0))?;
                let value = super::Expr::decode(buf.skip(5))?;
                Ok(SwitchBranch { condition, value })
            }
        }

        #[allow(clippy::all, unused_variables)]
        impl crate::Encode for TyLayout {
            type HeadPtr = TyLayoutHeadPtr;
            fn encode_head(&self, buf: &mut crate::bytes::BytesMut) -> Self::HeadPtr {
                let head_size = self.head_size.encode_head(buf);
                let body_ptrs = self.body_ptrs.encode_head(buf);
                TyLayoutHeadPtr {
                    head_size,
                    body_ptrs,
                }
            }
            fn encode_body(&self, head: Self::HeadPtr, buf: &mut crate::bytes::BytesMut) {
                self.head_size.encode_body(head.head_size, buf);
                self.body_ptrs.encode_body(head.body_ptrs, buf);
            }
        }
        #[allow(non_camel_case_types)]
        pub struct TyLayoutHeadPtr {
            head_size: <u32 as crate::Encode>::HeadPtr,
            body_ptrs: <crate::vec::Vec<u32> as crate::Encode>::HeadPtr,
        }
        impl crate::Layout for TyLayout {
            fn head_size() -> usize {
                96
            }
        }

        impl crate::Decode for TyLayout {
            fn decode(buf: &[u8]) -> crate::Result<Self> {
                let head_size = u32::decode(buf.skip(0))?;
                let body_ptrs = crate::vec::Vec::<u32>::decode(buf.skip(4))?;
                Ok(TyLayout {
                    head_size,
                    body_ptrs,
                })
            }
        }
    }
}
