//# Generated by lutra-codegen

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct Program {
    pub externals: Vec<ExternalSymbol>,
    pub main: Expr,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct ExternalSymbol {
    pub id: String,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct Expr {
    pub kind: ExprKind,
    pub ty: Ty,
}

#[derive(Debug, Clone, enum_as_inner::EnumAsInner)]
#[allow(non_camel_case_types)]
pub enum ExprKind {
    Pointer(Sid),
    Literal(Literal),
    Call(Box<Call>),
    Function(Box<Function>),
    Tuple(Vec<Expr>),
    Array(Vec<Expr>),
    TupleLookup(Box<TupleLookup>),
    ArrayLookup(Box<ArrayLookup>),
    Binding(Box<Binding>),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct Sid(pub u32);

#[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
#[allow(non_camel_case_types)]
pub enum Literal {
    Int(i64),
    Float(f64),
    Bool(bool),
    Text(String),
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct Call {
    pub function: Expr,
    pub args: Vec<Expr>,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct Function {
    pub symbol_ns: Sid,
    pub body: Expr,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct TupleLookup {
    pub base: Expr,
    pub offset: u16,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct ArrayLookup {
    pub base: Expr,
    pub offset: u32,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct Binding {
    pub symbol: Sid,
    pub expr: Expr,
    pub main: Expr,
}

#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub struct Ty {
    pub kind: TyKind,
    pub layout: Option<TyLayout>,
    pub name: Option<String>,
}

#[derive(Debug, Clone, PartialEq, enum_as_inner::EnumAsInner)]
#[allow(non_camel_case_types)]
pub enum TyKind {
    Primitive(PrimitiveSet),
    Tuple(Vec<TyTupleField>),
    Array(Box<Ty>),
    Enum(Vec<TyEnumVariant>),
    Function(Box<TyFunction>),
    Ident(Path),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum PrimitiveSet {
    bool,
    int8,
    int16,
    int32,
    int64,
    uint8,
    uint16,
    uint32,
    uint64,
    float32,
    float64,
    text,
}

#[derive(Debug, Clone, PartialEq)]
#[allow(non_camel_case_types)]
pub struct TyTupleField {
    pub name: Option<String>,
    pub ty: Ty,
}

#[derive(Debug, Clone, PartialEq)]
#[allow(non_camel_case_types)]
pub struct TyEnumVariant {
    pub name: String,
    pub ty: Ty,
}

#[derive(Debug, Clone, PartialEq, Default)]
#[allow(non_camel_case_types)]
pub struct TyLayout {
    pub head_size: u32,
    pub body_ptr_offset: Option<u32>,
    pub variants_recursive: Vec<u16>,
}

#[derive(Debug, Clone, PartialEq)]
#[allow(non_camel_case_types)]
pub struct TyFunction {
    pub params: Vec<Ty>,
    pub body: Ty,
}

#[derive(Debug, Clone, PartialEq)]
#[allow(non_camel_case_types)]
pub struct Path(pub Vec<String>);

pub mod std {}
