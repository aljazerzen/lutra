# Utils

func default(): T
where T


# Casts

func to_int8(x: T): int8
where
  T: number

func to_int16(x: T): int16
where
  T: number

func to_int32(x: T): int32
where
  T: number

func to_int64(x: T): int64
where
  T: number

func to_uint8(x: T): uint8
where
  T: number

func to_uint16(x: T): uint16
where
  T: number

func to_uint32(x: T): uint32
where
  T: number

func to_uint64(x: T): uint64
where
  T: number

func to_float32(x: T): float32
where
  T: number

func to_float64(x: T): float64
where
  T: number

# Operators

func mul(left: T, right: T): T
where
  T: number

func div(left: T, right: T): T
where
  T: number

func mod(left: T, right: T): T
where
  T: number

func add(left: T, right: T): T
where
  T: number

func sub(left: T, right: T): T
where
  T: number

func neg(x: T): T
where
  T: int8 | int16 | int32 | int64 | float32 | float64

func eq(left: T, right: T): bool
where
  T: primitive

func ne(left: T, right: T): bool
where
  T: primitive

func gt(left: T, right: T): bool
where
  T: number

func lt(left: T, right: T): bool
where
  T: number

func gte(left: T, right: T): bool
where
  T: number

func lte(left: T, right: T): bool
where
  T: number

func and(left: bool, right: bool): bool

func or(left: bool, right: bool): bool

func not(expr: bool): bool

func regex_search(text: text, pattern: text): bool

func or_else(value: enum { None, Some: T }, fallback: T): T
where T
-> (
  match value {
    .Some(x) => x,
    .None => fallback,
  }
)

func or_default(value: enum { None, Some: T }): T
where T
-> (
  match value {
    .Some(x) => x,
    .None => std::default(),
  }
)

func is_some(value: enum { None, Some: T }): bool
where T
-> (
  match value {
    .Some(x) => true,
    .None => false,
  }
)

func is_none(value: enum { None, Some: T }): bool
where T
-> (
  match value {
    .Some(x) => false,
    .None => true,
  }
)

# Array functions

func index(array: [T], position: int64): enum { None, Some: T }
where T

func map(array: [I], mapper: func (I): O): [O]
where I, O

func flat_map(array: [I], mapper: func (I): [O]): [O]
where I, O

func filter(array: [T], condition: func (T): bool): [T]
where T

func find(array: [T], condition: func (T): bool): enum { None, Some: T }
where T
-> (
  array | filter(condition) | index(0)
)

func slice(array: [T], start: int64, end: int64): [T]
where T

func sort(array: [I], key: func (I): int64): [I]
where I

func to_columnar(rows: [T]): {for f: F in T do f: [F]}
where T: {..}

func from_columnar(columnar: {for f: F in T do f: [F]}): [T]
where T: {..}

func map_columnar(
  x: [I],
  mapper: func ({for f: F in I do f: [F]}): {for f: F in O do f: [F]}
): [O]
where I: {..}, O: {..}
-> (
  x | to_columnar | mapper | from_columnar
)

func aggregate(x: [T], mapper: func ({for f: F in T do f: [F]}): O): O
where T: {..}, O
-> (
  x | to_columnar | mapper
)

# func join<A, B>(
#   with: [B],
#   condition: bool,
#   side: text,
#   tbl: [A],
# ): [{A, B}]

func group(input: [I], key: func (I): K): [{key: K, values: [I]}]
where I, K

func append(top: [T], bottom: [T]): [T]
where T

# Aggregation functions

func min(column: [int64]): int64

func max(column: [int64]): int64

func sum(column: [int64]): int64

func count(column: [T]): int64
where T

func average(column: [T]): float64
where T: int64

func all(column: [bool]): bool

func any(column: [bool]): bool

func contains(value: [int64], pattern: int64): bool

func join(column: [text], separator: text): text

# Window functions

func lag(array: [T], offset: int64): [T]
where T

func lead(array: [T], offset: int64): [T]
where T

func row_number(array: [T]): [int64]
where T


## Mathematical functions
module math {
  ## Absolute value
  func abs(val: T): T
  where T: number

  func sqrt(val: int64): int64
  func ceil(val: int64): int64
  func floor(val: int64): int64
  func round(val: int64, n_digits: int64): int64

  const pi32: float32 = 3.1415927
  const pi64: float64 = 3.141592653589793

  func pow(val: int64, exponent: int64): int64
  func exp(val: int64): int64
  func ln(val: int64): int64
  func log10(val: int64): int64
  func log(base: int64, val: int64): int64

  func degrees(val: int64): int64
  func radians(val: int64): int64
  func cos(val: int64): int64
  func acos(val: int64): int64
  func sin(val: int64): int64
  func asin(val: int64): int64
  func tan(val: int64): int64
  func atan(val: int64): int64
}

## Text functions
module text {
  func concat(left: text, right: text): text

  func lower(value: text): text
  func upper(value: text): text

  func ltrim(value: text): text
  func rtrim(value: text): text
  func trim(value: text): text

  func length(value: text): uint32

  func substring(value: text, offset: int64, length: int64): text
  func replace(value: text, pattern: text, replacement: text): text

  func starts_with(value: text, prefix: text): bool
  func contains(value: text, substr: text): bool
  func ends_with(value: text, suffix: text): bool
}

module fs {
  func read_parquet(file_name: text): [R]
  where R: {..}

  func write_parquet(data: [R], file_name: text): {}
  where R: {..}
}

module sql {

  ## Reads data from a table.
  ##
  ## The order of table rows is unknown and might change over repeated invocations.
  ##
  ## Table identifier can contain slashes to denote table namespaces.
  ## Any additional slashes will remain in table name verbatim.
  ## For example:
  ## - `from("my_schema/invoices")` will read from `my_schema.invoices`,
  ## - `from("my_schema/hello/world")` will read from `my_schema."hello/world"`.
  func from(const table_identifier: text): [R]
  where R: {..}

  ## Inserts rows into a table.
  ##
  ## For table identifier format, see documentation of [std::sql::from].
  func insert(rows: [R], const table_identifier: text): {}
  where R: {..}

  ## Evaluates an SQL expression.
  ##
  ## This function is an escape hatch for accessing SQL directly.
  ## It should be used as a last resort, because it circumvents type checking
  ## and can cause program panic on malformed SQL or incorrect resulting type.
  ## 
  ## Resulting type of the expression must match the "SQL relationalal representation"
  ## of the Lutra type:
  ## - primitives expect a single column,
  ## - tuples expect one column for each tuple field,
  ## - nested tuples are unpacked into parent relation,
  ## - arrays expect one index column, followed by columns of inner object,
  ## - enums expect one tag columns, followed by columns of each of the possible variants,
  ## - enums that are the Maybe, exprect one nullable column.
  func expr(const sql_source: text): R
  where R
}
