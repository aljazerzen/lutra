# Utils

func default(): T
where T


# Casts

func to_int8(x: T): int8
where
  T: number

func to_int16(x: T): int16
where
  T: number

func to_int32(x: T): int32
where
  T: number

func to_int64(x: T): int64
where
  T: number

func to_uint8(x: T): uint8
where
  T: number

func to_uint16(x: T): uint16
where
  T: number

func to_uint32(x: T): uint32
where
  T: number

func to_uint64(x: T): uint64
where
  T: number

func to_float32(x: T): float32
where
  T: number

func to_float64(x: T): float64
where
  T: number

# Operators

func mul(left: T, right: T): T
where
  T: number

func div(left: T, right: T): T
where
  T: number

func mod(left: T, right: T): T
where
  T: number

func add(left: T, right: T): T
where
  T: number

func sub(left: T, right: T): T
where
  T: number

func neg(x: T): T
where
  T: int8 | int16 | int32 | int64 | float32 | float64

func eq(left: T, right: T): bool
where
  T: primitive

func ne(left: T, right: T): bool
where
  T: primitive

func gt(left: T, right: T): bool
where
  T: number

func lt(left: T, right: T): bool
where
  T: number

func gte(left: T, right: T): bool
where
  T: number

func lte(left: T, right: T): bool
where
  T: number

func and(left: bool, right: bool): bool

func or(left: bool, right: bool): bool

func not(expr: bool): bool

func regex_search(text: text, pattern: text): bool

func or_else(value: enum { None, Some: T }, fallback: T): T
where T
-> (
  match value {
    .Some(x) => x,
    .None => fallback,
  }
)

func or_default(value: enum { None, Some: T }): T
where T
-> (
  match value {
    .Some(x) => x,
    .None => default(),
  }
)

func is_some(value: enum { None, Some: T }): bool
where T
-> (
  match value {
    .Some => true,
    .None => false,
  }
)

func is_none(value: enum { None, Some: T }): bool
where T
-> (
  match value {
    .Some => false,
    .None => true,
  }
)

# Array functions

func index(array: [T], position: int64): enum { None, Some: T }
where T

func map(array: [I], mapper: func (I): O): [O]
where I, O

func flat_map(array: [I], mapper: func (I): [O]): [O]
where I, O

func filter(array: [T], condition: func (T): bool): [T]
where T

func find(array: [T], condition: func (T): bool): enum { None, Some: T }
where T
-> (
  array | filter(condition) | index(0)
)

func slice(array: [T], start: int64, end: int64): [T]
where T

func sort(array: [I], key: func (I): int64): [I]
where I

func to_columnar(rows: [T]): {for f: F in T do f: [F]}
where T: {..}

func from_columnar(columnar: {for f: F in T do f: [F]}): [T]
where T: {..}

func map_columnar(
  x: [I], mapper: func ({for f: F in I do f: [F]}): {for f: F in O do f: [F]}
): [O]
where I: {..}, O: {..}
-> (
  x | to_columnar | mapper | from_columnar
)

func aggregate(x: [T], mapper: func ({for f: F in T do f: [F]}): O): O
where T: {..}, O
-> (
  x | to_columnar | mapper
)

# func join<A, B>(
#   with: [B],
#   condition: bool,
#   side: text,
#   tbl: [A],
# ): [{A, B}]

func group(input: [I], key: func (I): K): [{key: K, values: [I]}]
where I, K

func append(top: [T], bottom: [T]): [T]
where T

## Folds every input into the an accumulator value by applying an operation,
## returning the final result.
##
## The `operation` takes two arguments: accumulator and an input.
## It returns the value that the accumulator should have in next iteration.
##
## The `initial` value is the accumulator for the first call.
##
## After folding all inputs, the last accumulator is returned.
##
## This function is sometimes also called "reduce" or "inject".
## This function is similar to [std::scan], but it returns only the final
## accumulator.
func fold(
  inputs: [I],
  initial: A,
  operation: func (A, I): A,
): A
where I, A

## Applies an operation to each input, using the output from the previous
## iteration.
##
## The `operation` takes two arguments: accumulator and an input.
## It returns the value that the accumulator should have in next iteration.
##
## The `initial` value is the accumulator for the first call.
##
## Returns values of all produced accumulators.
##
## This function is similar to [std::fold], but it returns all accumulators,
## instead of only the final one.
func scan(
  inputs: [I],
  initial: A,
  operation: func (A, I): A,
): [A]
where I, A

# Aggregation functions

func min(inputs: [T]): enum {None, Some: T}
where T: number

func max(inputs: [T]): enum {None, Some: T}
where T: number

func sum(column: [int64]): int64

func count(column: [T]): int64
where T

func average(column: [T]): float64
where T: int64

func all(column: [bool]): bool

func any(column: [bool]): bool

func contains(value: [int64], pattern: int64): bool

func join(column: [text], separator: text): text

# Window functions

func lag(array: [T], offset: int64): [T]
where T

func lead(array: [T], offset: int64): [T]
where T

func row_number(array: [T]): [int64]
where T


## Mathematical functions
module math {
  ## Absolute value
  func abs(val: T): T
  where T: number

  func sqrt(val: int64): int64
  func ceil(val: int64): int64
  func floor(val: int64): int64
  func round(val: int64, n_digits: int64): int64

  const pi32: float32 = 3.1415927
  const pi64: float64 = 3.141592653589793

  # TODO: exponent should probably always be uint32
  func pow(val: T, exponent: T): T
  where T: int64 | float64

  func exp(val: int64): int64
  func ln(val: int64): int64
  func log10(val: int64): int64
  func log(base: int64, val: int64): int64

  func degrees(val: int64): int64
  func radians(val: int64): int64
  func cos(val: int64): int64
  func acos(val: int64): int64
  func sin(val: int64): int64
  func asin(val: int64): int64
  func tan(val: int64): int64
  func atan(val: int64): int64
}

## Text functions
module text {
  func concat(left: text, right: text): text

  func lower(value: text): text
  func upper(value: text): text

  func ltrim(value: text): text
  func rtrim(value: text): text
  func trim(value: text): text

  func length(value: text): uint32

  func substring(value: text, offset: int64, length: int64): text
  func replace(value: text, pattern: text, replacement: text): text

  func starts_with(value: text, prefix: text): bool
  func contains(value: text, substr: text): bool
  func ends_with(value: text, suffix: text): bool
}

module fs {
  func read_parquet(file_name: text): [R]
  where R: {..}

  func write_parquet(data: [R], file_name: text): {}
  where R: {..}
}

module sql {

  ## Reads data from a table.
  ##
  ## The order of table rows is unknown and might change over repeated invocations.
  ##
  ## Table identifier can contain slashes to denote table namespaces.
  ## Any additional slashes will remain in table name verbatim.
  ## For example:
  ## - `from("my_schema/invoices")` will read from `my_schema.invoices`,
  ## - `from("my_schema/hello/world")` will read from `my_schema."hello/world"`.
  func from(const table_identifier: text): [R]
  where R: {..}

  ## Inserts rows into a table.
  ##
  ## For table identifier format, see documentation of [std::sql::from].
  func insert(rows: [R], const table_identifier: text): {}
  where R: {..}

  ## Evaluates an SQL expression.
  ##
  ## This function is an escape hatch for accessing SQL directly.
  ## It should be used as a last resort, because it circumvents type checking
  ## and can cause program panic on malformed SQL or incorrect resulting type.
  ##
  ## Resulting type of the expression must match the "SQL relational representation"
  ## of the Lutra type:
  ## - primitives expect a single column,
  ## - tuples expect one column for each tuple field,
  ## - nested tuples are unpacked into parent relation,
  ## - arrays expect one index column, followed by columns of inner object,
  ## - enums expect one tag columns, followed by columns of each of the possible variants,
  ## - enums that are the Maybe, expect one nullable column.
  func expr(const sql_source: text): R
  where R
}

## A timestamp without a timezone.
##
## Backed by a signed 64-bit integer, indicating microseconds since the Unix
## epoch (1970-01-01T00:00:00.000), excluding leap seconds.
# TODO: support for timezone and other time units.
type Timestamp(int64)

## Elapsed days since Unix Epoch (1970-01-01).
##
## Backed by a signed 32-bit integer, representing number of days.
type Date(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 32-bit integer, representing number of seconds.
# type Time32Second(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 32-bit integer, representing number of milliseconds.
# type Time32Millisecond(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 32-bit integer, representing number of microseconds.
# type Time32Microsecond(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 64-bit integer, representing number of seconds.
# type Time64Second(int64)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 64-bit integer, representing number of milliseconds.
# type Time64Millisecond(int64)

## Length of time, unrelated to calendar events.
##
## Backed by a signed 64-bit integer, representing number of microseconds.
type Time(int64)

## Compute time duration between two dates.
## Dates are assumed to be in the same timezone, and duration is measured from
## one midnight to another.
func sub_date(a: Date, b: Date): Time -> (
  sub(a.0, b.0) | to_int64 | mul(86400000000) | Time
)

# func to_time64_second(x: D): Time64Second
# where D: Time32Second -> x.0 | to_int64 | Time64Second
# where D: Time32Millisecond -> x.0 | to_int64 | mul(1000) | Time64Second
# where D: Time32Microsecond -> x.0 | to_int64 | mul(1000000) | Time64Second
# where D: Time64Second -> x
# where D: Time64Millisecond -> x.0 | mul(1000) | Time64Second
# where D: Time64Microsecond -> x.0 | mul(1000000) | Time64Second

# func to_time64_millisecond(x: D): Time64Millisecond
# where D: Time32Second -> x.0 | to_int64 | div(1000) | Time64Millisecond
# where D: Time32Millisecond -> x.0 | to_int64 | Time64Millisecond
# where D: Time32Microsecond -> x.0 | to_int64 | mul(1000) | Time64Millisecond
# where D: Time64Second -> x.0 | div(1000) | Time64Millisecond
# where D: Time64Millisecond -> x
# where D: Time64Microsecond -> x.0 | mul(1000) | Time64Millisecond

# func to_time64_microsecond(x: D): Time64Microsecond
# where D: Time32Second -> x.0 | to_int64 | div(1000000) | Time64Microsecond
# where D: Time32Millisecond -> x.0 | to_int64 | div(1000) | Time64Microsecond
# where D: Time32Microsecond -> x.0 | to_int64 | Time64Microsecond
# where D: Time64Second -> x.0 | div(1000000) | Time64Microsecond
# where D: Time64Millisecond -> x.0 | div(1000) | Time64Microsecond
# where D: Time64Microsecond -> x

func add_duration(a: Time, b: Time): Time -> (
  add(a.0, b.0) | Time
)
