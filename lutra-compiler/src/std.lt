# --- Utils ---

## Constructs the usual "default" value
##
## For `bool` it is false.
## For numbers, this is zero.
## For `text` it is an empty text.
## For tuples, it a tuple with every field set to default value.
## For arrays, it is an empty array.
## For enums, it the first variant.
func default(): T
where T


# --- Casts ---

## Converts a number to `int8`.
func to_int8(x: T): int8
where T: number

## Converts a number to `int16`.
func to_int16(x: T): int16
where T: number

## Converts a number to `int32`
func to_int32(x: T): int32
where T: number

## Converts a number to `int64`
func to_int64(x: T): int64
where T: number

## Converts a number to `uint8`
func to_uint8(x: T): uint8
where T: number

## Converts a number to `uint16`
func to_uint16(x: T): uint16
where T: number

## Converts a number to `uint32`
func to_uint32(x: T): uint32
where T: number

## Converts a number to `uint64`
func to_uint64(x: T): uint64
where T: number

## Converts a number to `float32`
func to_float32(x: T): float32
where T: number

## Converts a number to `float64`
func to_float64(x: T): float64
where T: number

# --- Operators ---

## Multiplies two numbers.
func mul(left: T, right: T): T
where T: number

## Divides two numbers.
func div(left: T, right: T): T
where T: number

## Division remainder.
func mod(left: T, right: T): T
where T: number

## Adds two numbers.
func add(left: T, right: T): T
where T: number

## Subtracts two numbers.
func sub(left: T, right: T): T
where T: number

## Negates a number.
func neg(x: T): T
where
  T: int8 | int16 | int32 | int64 | float32 | float64

## Compare two values to determine if the first is less, equal, or greater than
## the second.
func cmp(a: T, b: T): Ordering
where T: primitive

type Ordering: enum { Less, Equal, Greater }

## Tests if values are equal. Used by `==` operator.
func eq(left: T, right: T): bool
where T: primitive -> (
  match cmp(left, right) {
    .Equal => true,
    _ => false,
  }
)

## Tests if values are not equal. Used by `!=` operator.
func ne(left: T, right: T): bool
where T: primitive  -> (
  match cmp(left, right) {
    .Equal => false,
    _ => true,
  }
)

## Tests if left value is greater than the right. Used by `>` operator.
func gt(left: T, right: T): bool
where T: primitive -> (
  match cmp(left, right) {
    .Greater => true,
    _ => false,
  }
)

## Tests if left value is less than the right. Used by `<` operator.
func lt(left: T, right: T): bool
where T: primitive -> (
  match cmp(left, right) {
    .Less => true,
    _ => false,
  }
)

## Tests if left value is greater or equal to the right. Used by `>=` operator.
func gte(left: T, right: T): bool
where T: primitive -> (
  match cmp(left, right) {
    .Less => false,
    _ => true,
  }
)

## Tests if left value is less or equal to the right. Used by `<=` operator.
func lte(left: T, right: T): bool
where T: primitive -> (
  match cmp(left, right) {
    .Greater => false,
    _ => true,
  }
)

## Tests if both values are true. Used by `&&` operator.
func and(left: bool, right: bool): bool

## Tests if either of the values is true. Used by `||` operator.
func or(left: bool, right: bool): bool

## Inverts a boolean. Used by `!` operator.
func not(expr: bool): bool

# --- Option functions ---

func or_else(value: enum { None, Some: T }, fallback: T): T
where T
-> (
  match value {
    .Some(x) => x,
    .None => fallback,
  }
)

func or_default(value: enum { None, Some: T }): T
where T
-> (
  match value {
    .Some(x) => x,
    .None => default(),
  }
)

func is_some(value: enum { None, Some: T }): bool
where T
-> (
  match value {
    .Some => true,
    .None => false,
  }
)

func is_none(value: enum { None, Some: T }): bool
where T
-> (
  match value {
    .Some => false,
    .None => true,
  }
)

# --- Array functions ---

func index(array: [T], position: int64): enum { None, Some: T }
where T

func count(array: [T]): int64
where T

func is_empty(array: [T]): bool
where T
-> eq(count(array), 0)

func map(array: [I], mapper: func (I): O): [O]
where I, O

func flat_map(array: [I], mapper: func (I): [O]): [O]
where I, O

func filter(array: [T], condition: func (T): bool): [T]
where T

func find(array: [T], condition: func (T): bool): enum { None, Some: T }
where T
-> (
  array | filter(condition) | index(0)
)

func slice(array: [T], start: int64, end: int64): [T]
where T

func sort(array: [I], key: func (I): K): [I]
where I, K: primitive

func to_columnar(rows: [T]): {for f: F in T do f: [F]}
where T: {..}

func from_columnar(columnar: {for f: F in T do f: [F]}): [T]
where T: {..}

func map_columnar(
  x: [I], mapper: func ({for f: F in I do f: [F]}): {for f: F in O do f: [F]}
): [O]
where I: {..}, O: {..}
-> (
  x | to_columnar | mapper | from_columnar
)

func aggregate(x: [T], mapper: func ({for f: F in T do f: [F]}): O): O
where T: {..}, O
-> (
  x | to_columnar | mapper
)

func zip(left: [L], right: [R]): [{L, R}]
where L, R

func group(input: [I], key: func (I): K): [{key: K, values: [I]}]
where I, K

func append(top: [T], bottom: [T]): [T]
where T

## Folds every input into the an accumulator value by applying an operation,
## returning the final result.
##
## The `operation` takes two arguments: accumulator and an input.
## It returns the value that the accumulator should have in next iteration.
##
## The `initial` value is the accumulator for the first call.
##
## After folding all inputs, the last accumulator is returned.
##
## This function is sometimes also called "reduce" or "inject".
## This function is similar to [std::scan], but it returns only the final
## accumulator.
func fold(
  inputs: [I],
  initial: A,
  operation: func (A, I): A,
): A
where I, A

## Applies an operation to each input, using the output from the previous
## iteration.
##
## The `operation` takes two arguments: accumulator and an input.
## It returns the value that the accumulator should have in next iteration.
##
## The `initial` value is the accumulator for the first call.
##
## Returns values of all produced accumulators.
##
## This function is similar to [std::fold], but it returns all accumulators,
## instead of only the final one.
func scan(
  inputs: [I],
  initial: A,
  operation: func (A, I): A,
): [A]
where I, A

# func apply(
#   value: I,
#   function: func (I): O
# ): O
# where I, O -> function(value)

## Applies an operation to an array, until it returns an empty array.
## First operation is supplied with the initial array.
## Each following operation is supplied with result of previous operation.
##
## Returns all produced arrays concatenated together, including initial array.
##
## In SQL, this is known as "RECURSIVE CTE" or "recursive join".
func apply_until_empty(
  initial: [T],
  operation: func ([T]): [T]
): [T]
where T

# --- Aggregation functions ---

## Find the minimum value in the array.
## Returns `None` when array is empty.
func min(array: [T]): enum {None, Some: T}
where T: number

## Find the maximum value in the array.
## Returns `None` when array is empty.
func max(array: [T]): enum {None, Some: T}
where T: number

## Compute sum of all number in an array.
## Returns zero when array is empty.
func sum(column: [T]): T
where T: number

## Compute arithmetic mean of an array of numbers.
func mean(array: [T]): float64
where T: number

## Returns `true` if all items in the array are `true`.
func all(values: [bool]): bool

## Returns `true` if any value in the array is `true`.
func any(values: [bool]): bool

## Returns `true` if the haystack array contains an item equal to `needle`.
func contains(haystack: [T], needle: T): bool
where T: primitive -> (
  haystack | filter(func (x) -> eq(x, needle)) | is_empty | not
)

## Joins text parts, placing separator between each pair.
func join(parts: [text], separator: text): text

# --- Window functions ---

## Shifts array items backwards by an offset.
## Items in front are set to their default value.
##
## For example, `lag(["a", "b", "c"], 1)` is `["", "a", "b"]`.
func lag(array: [T], offset: int64): [T]
where T

## Shifts array items forwards by an offset.
## Items in back are set to their default value.
##
## For example, `lead(["a", "b", "c"], 1)` is `["b", "c", ""]`.
func lead(array: [T], offset: int64): [T]
where T

## Returns a sequence of numbers starting from 0, for each array item.
func row_number(array: [T]): [int64]
where T

## Computes rolling arithmetic mean over an array of numbers.
## Also known as moving average.
##
## Returns an array of same length as the input,
## where each item is the mean of the corresponding input item and
## a number of preceding and following items.
##
## For example, `rolling_mean(..., 1, 2)` computes mean of each item, along with
## 1 preceding and 2 following items, which is 4 items total.
func rolling_mean(array: [T], preceding: uint32, following: uint32): [float64]
where T: number

## Computes rank of each array item.
##
## Rank is the number of items that are less than current item, plus one.
##
## The values range from `1` to `n` (number of items).
## Also known as "min rank".
##
## For example, `rank(["a", "b", "b", "c"])` is `[1, 2, 2, 4]`.
func rank(array: [T]): [int32]
where T: primitive

## Computes dense rank of each array item.
##
## Dense rank is the number of unique items that are less than current item,
## plus one.
##
## The values range from `1` to `n` (number of unique items).
##
## For example, `rank_dense(["a", "b", "b", "c"])` is `[1, 2, 2, 3]`.
func rank_dense(array: [T]): [int32]
where T: primitive

## Computes percentile rank of each array item.
##
## Percentile rank is the item rank rescaled to range from 0.0 to 1.0.
##
## The values range from 0.0 to 1.0.
##
## For example, `rank_percentile(["a", "b", "b", "c"])` is
## `[0.0, 0.33333, 0.25, 1.0]`.
func rank_percentile(array: [T]): [float64]
where T: primitive

## Computes ECDF (Empirical Cumulative Density Function) of array items.
##
## Value of each item i is the number of items that are less than or equal to i,
## divided by the total number of items.
##
## The values range from `1.0/n` to `1.0`.
##
## For example, `cume_dist(["a", "b", "b", "c"])` is
## `[0.25, 0.75, 0.75, 1.0]`.
func cume_dist(array: [T]): [float64]
where T: primitive

## Mathematical functions
module math {
  ## Absolute value
  func abs(val: T): T
  where T: number

  func sqrt(val: int64): int64
  func ceil(val: int64): int64
  func floor(val: int64): int64
  func round(val: int64, n_digits: int64): int64

  const pi32: float32 = 3.1415927
  const pi64: float64 = 3.141592653589793

  # TODO: exponent should probably always be uint32
  func pow(val: T, exponent: T): T
  where T: int64 | float64

  func exp(val: int64): int64
  func ln(val: int64): int64
  func log10(val: int64): int64
  func log(base: int64, val: int64): int64

  func degrees(val: int64): int64
  func radians(val: int64): int64
  func cos(val: int64): int64
  func acos(val: int64): int64
  func sin(val: int64): int64
  func asin(val: int64): int64
  func tan(val: int64): int64
  func atan(val: int64): int64
}

## Text functions
module text {
  func concat(left: text, right: text): text

  func lower(value: text): text
  func upper(value: text): text

  func ltrim(value: text): text
  func rtrim(value: text): text
  func trim(value: text): text

  func length(value: text): uint32

  func substring(value: text, offset: int64, length: int64): text
  func replace(value: text, pattern: text, replacement: text): text

  func starts_with(value: text, prefix: text): bool
  func contains(value: text, substr: text): bool
  func ends_with(value: text, suffix: text): bool

  ## Converts ASCII code to its corresponding Unicode character.
  ## This function always succeeds, because ASCII is a subset of Unicode.
  func from_ascii(ascii: uint8): text

  ## Joins parts together, placing separator between each pair.
  func join(parts: [text], delimiter: text): text

  func regex_search(haystack: text, pattern: text): bool
}

module fs {
  func read_parquet(file_name: text): [R]
  where R: {..}

  func write_parquet(data: [R], file_name: text): {}
  where R: {..}
}

## Module available only when targeting SQL databases.
## Currently this includes only `sql-pg` format.
module sql {

  ## Reads rows from a table.
  ##
  ## The order of table rows is unknown and might change over repeated invocations.
  ##
  ## Table identifier can contain slashes to denote table namespaces.
  ## Any additional slashes will remain in table name verbatim.
  ## For example:
  ## - `from("my_schema/invoices")` will read from `my_schema.invoices`,
  ## - `from("my_schema/hello/world")` will read from `my_schema."hello/world"`.
  func from(const table_identifier: text): [R]
  where R: {..}

  ## Inserts rows into a table.
  ##
  ## For table identifier format, see documentation of [std::sql::from].
  func insert(rows: [R], const table_identifier: text): {}
  where R: {..}

  ## Evaluates an SQL expression.
  ##
  ## This function is an escape hatch for accessing SQL directly.
  ## It should be used as a last resort, because it circumvents type checking
  ## and can cause program panic on malformed SQL or incorrect resulting type.
  ##
  ## Resulting type of the expression must match the "SQL representation"
  ## of the Lutra type:
  ## - primitives expect a single column,
  ## - tuples expect one column for each tuple field,
  ## - nested tuples are unpacked into parent relation,
  ## - arrays expect columns of the inner object,
  ## - enums expect one tag columns, followed by columns of each of the possible variants,
  ## - enums that are the Maybe, expect one nullable column.
  func expr(const sql_source: text): R
  where R
}

## A timestamp without a timezone.
##
## Backed by a signed 64-bit integer, indicating microseconds since the Unix
## epoch (1970-01-01T00:00:00.000), excluding leap seconds.
# TODO: support for timezone and other time units.
type Timestamp(int64)

## Elapsed days since Unix Epoch (1970-01-01).
##
## Backed by a signed 32-bit integer, representing number of days.
type Date(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 32-bit integer, representing number of seconds.
# type Time32Second(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 32-bit integer, representing number of milliseconds.
# type Time32Millisecond(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 32-bit integer, representing number of microseconds.
# type Time32Microsecond(int32)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 64-bit integer, representing number of seconds.
# type Time64Second(int64)

# ## Length of time, unrelated to calendar events.
# ##
# ## Backed by a signed 64-bit integer, representing number of milliseconds.
# type Time64Millisecond(int64)

## Length of time, unrelated to calendar events.
##
## Backed by a signed 64-bit integer, representing number of microseconds.
type Time(int64)

## Compute time duration between two dates.
## Dates are assumed to be in the same timezone, and duration is measured from
## one midnight to another.
func sub_date(a: Date, b: Date): Time -> (
  sub(a.0, b.0) | to_int64 | mul(86400000000) | Time
)

# func to_time64_second(x: D): Time64Second
# where D: Time32Second -> x.0 | to_int64 | Time64Second
# where D: Time32Millisecond -> x.0 | to_int64 | mul(1000) | Time64Second
# where D: Time32Microsecond -> x.0 | to_int64 | mul(1000000) | Time64Second
# where D: Time64Second -> x
# where D: Time64Millisecond -> x.0 | mul(1000) | Time64Second
# where D: Time64Microsecond -> x.0 | mul(1000000) | Time64Second

# func to_time64_millisecond(x: D): Time64Millisecond
# where D: Time32Second -> x.0 | to_int64 | div(1000) | Time64Millisecond
# where D: Time32Millisecond -> x.0 | to_int64 | Time64Millisecond
# where D: Time32Microsecond -> x.0 | to_int64 | mul(1000) | Time64Millisecond
# where D: Time64Second -> x.0 | div(1000) | Time64Millisecond
# where D: Time64Millisecond -> x
# where D: Time64Microsecond -> x.0 | mul(1000) | Time64Millisecond

# func to_time64_microsecond(x: D): Time64Microsecond
# where D: Time32Second -> x.0 | to_int64 | div(1000000) | Time64Microsecond
# where D: Time32Millisecond -> x.0 | to_int64 | div(1000) | Time64Microsecond
# where D: Time32Microsecond -> x.0 | to_int64 | Time64Microsecond
# where D: Time64Second -> x.0 | div(1000000) | Time64Microsecond
# where D: Time64Millisecond -> x.0 | div(1000) | Time64Microsecond
# where D: Time64Microsecond -> x

func add_duration(a: Time, b: Time): Time -> (
  add(a.0, b.0) | Time
)
