use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::{env, sync, time};

use lutra_compiler::{ProgramFormat, SourceTree};
use lutra_runner::Run;
use lutra_runner_postgres::RunnerAsync;
use tokio::io::{AsyncRead, AsyncWrite};

use crate::POSTGRES_URL_SHARED;

#[track_caller]
#[tokio::main(flavor = "current_thread")]
pub async fn _run(source: &str, input: lutra_bin::Value) -> (String, String) {
    let mut client = run_connection(
        tokio_postgres::connect(POSTGRES_URL_SHARED, tokio_postgres::NoTls)
            .await
            .unwrap(),
    );

    let tran = client.transaction().await.unwrap();

    let mut runner = RunnerAsync::new(tran);
    _run_on(&mut runner, source, input).await
}

pub async fn _run_on(
    runner: &mut impl lutra_runner::Run,
    source: &str,
    input: lutra_bin::Value,
) -> (String, String) {
    crate::init_logger();

    // compile
    let source = SourceTree::single("".into(), source.to_string());
    let project = match lutra_compiler::check(source, Default::default()) {
        Ok(p) => p,
        Err(e) => return (String::new(), format!("check error:\n{e}")),
    };

    // compile to sql
    let res = lutra_compiler::compile(&project, "main", None, ProgramFormat::SqlPg);
    let (program, ty) = match res {
        Ok(x) => x,
        Err(e) => return (String::new(), format!("compile error:\n{e}")),
    };

    // format sql
    let formatted_sql = {
        let program = program.as_sql_pg().unwrap();
        let options = sqlformat::FormatOptions::default();
        sqlformat::format(&program.sql, &sqlformat::QueryParams::None, &options)
    };

    let input = input.encode(&ty.input, &ty.defs).unwrap();

    // execute
    let program = runner.prepare(program).await.unwrap();
    let output = runner.execute(&program, &input).await.unwrap();

    // decode and print source
    let output = lutra_bin::print_source(&output, &ty.output, &ty.defs).unwrap();

    (formatted_sql, output)
}

pub fn _sql_and_output((sql, output): (String, String)) -> String {
    format!("{sql}\n---\n{output}")
}

static RUN_ID: sync::LazyLock<u64> = sync::LazyLock::new(|| {
    let mut h = std::hash::DefaultHasher::new();
    if let Ok(run_id) = env::var("NEXTEST_RUN_ID") {
        run_id.hash(&mut h);
    } else {
        time::SystemTime::now().hash(&mut h);
    }
    h.finish()
});

pub async fn _get_test_db_client() -> Result<tokio_postgres::Client, tokio_postgres::Error> {
    let run_id = *RUN_ID as i64;
    let db_name = format!("l-test-{run_id:016x}");

    let config_shared = POSTGRES_URL_SHARED.parse::<tokio_postgres::Config>()?;
    let mut config_test = config_shared.clone();
    config_test.dbname(&db_name);

    let client_main = run_connection(config_shared.connect(tokio_postgres::NoTls).await?);
    client_main
        .execute("SELECT pg_advisory_lock($1)", &[&run_id])
        .await?;

    let databases: HashSet<String> = client_main
        .query("SELECT datname FROM pg_database", &[])
        .await?
        .iter()
        .map(|r| r.get::<_, String>(0))
        .filter(|d| d.starts_with("l-test-"))
        .collect();

    if !databases.contains(&db_name) {
        // cleanup old test dbs
        for d in databases {
            client_main
                .execute(&format!("DROP DATABASE \"{d}\""), &[])
                .await?;
        }

        // create test db
        client_main
            .execute(&format!("CREATE DATABASE \"{db_name}\""), &[])
            .await?;

        let client_test = run_connection(config_test.connect(tokio_postgres::NoTls).await?);
        client_test.batch_execute(MOVIES_SETUP).await?;

        drop(client_main); // this will release the lock
        Ok(client_test)
    } else {
        drop(client_main);

        Ok(run_connection(
            config_test.connect(tokio_postgres::NoTls).await?,
        ))
    }
}

pub fn run_connection<S, T>(
    (client, conn): (tokio_postgres::Client, tokio_postgres::Connection<S, T>),
) -> tokio_postgres::Client
where
    S: AsyncWrite + AsyncRead + Unpin + Send + 'static,
    T: AsyncWrite + AsyncRead + Unpin + Send + 'static,
{
    tokio::task::spawn(async {
        if let Err(e) = conn.await {
            eprintln!("{e}");
        }
    });
    client
}

const MOVIES_SETUP: &str = r#"
CREATE TABLE persons (
    id int4 primary key generated by default as identity,
    first_name text not null,
    last_name text
);

CREATE TABLE movies (
    id int4 primary key generated by default as identity,
    title text not null,
    premiere_date date,
    director_id int2 references persons(id)
);
CREATE INDEX ON movies (premiere_date);

CREATE TABLE movie_actors (
    source int4 references movies(id),
    target int4 references persons(id),
    role text
);

CREATE SCHEMA another;
CREATE TABLE another.days (
    id int4 primary key generated by default as identity,
    name text
);
CREATE TABLE another."proj/days" (
    id int4 primary key generated by default as identity,
    name text
);

INSERT INTO persons (first_name, last_name) VALUES ('Tom', 'Hanks');
INSERT INTO persons (first_name) VALUES ('Robin');
INSERT INTO persons (first_name, last_name) VALUES ('Steven', 'Spielberg');

INSERT INTO movies (title, premiere_date, director_id)
  SELECT
    'Forrest Gump',
    '1994-04-22',
    (SELECT id FROM persons WHERE first_name = 'Steven');
INSERT INTO movie_actors (source, target)
  SELECT
    (SELECT id FROM movies WHERE title = 'Forrest Gump'),
    p.id
  FROM (
    SELECT id FROM persons WHERE first_name in ('Tom', 'Robin')
  ) p;
INSERT INTO movies (title, premiere_date, director_id)
  SELECT
    'The Prestige',
    '2006-06-14',
    NULL;

INSERT INTO another.days (name) VALUES ('Monday'), ('Tuesday');
INSERT INTO another."proj/days" (name) VALUES ('Wednesday'), ('Thursday'), ('Friday');
"#;

#[test]
fn prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = 3: int16
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      3::int2 AS value
    ---
    3
    ");
}

#[test]
fn tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {3: int16, false}
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      3::int2 AS _0,
      FALSE AS _1
    ---
    {
      3,
      false,
    }
    ");
}

#[test]
fn array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [3, 6, 12]: [int16]
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r0.value
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int2 AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          6::int2 AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          12::int2 AS value
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      3,
      6,
      12,
    ]
    ");
}

#[test]
fn array_empty() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = []: [bool]
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r0.value
    FROM
      (
        SELECT
          0 AS index,
          NULL::bool AS value
        WHERE
          FALSE
      ) AS r0
    ORDER BY
      r0.index
    ---
    []
    ");
}

#[test]
fn array_enum() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          Pending, InProgress: {started_at: text, owner: text}, Done: text
        }
        const main = [Status::Pending, Status::InProgress({"today", "me"}), Status::Done("ok")]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r0._t,
      r0._1_0,
      r0._1_1,
      r0._2
    FROM
      (
        SELECT
          0::int8 AS index,
          0::int2 AS _t,
          NULL::text AS _1_0,
          NULL::text AS _1_1,
          NULL::text AS _2
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::int2 AS _t,
          'today' AS _1_0,
          'me' AS _1_1,
          NULL::text AS _2
        UNION
        ALL
        SELECT
          2::int8 AS index,
          2::int2 AS _t,
          NULL::text AS _1_0,
          NULL::text AS _1_1,
          'ok' AS _2
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      Pending,
      InProgress({
        started_at = "today",
        owner = "me",
      }),
      Done("ok"),
    ]
    "#);
}

#[test]
fn enum_array() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          Pending, InProgress: [text], Done: text
        }
        const main = {
          "statuses:",
          [Status::Pending, Status::InProgress(["today", "me"]), Status::Done("ok")],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'statuses:' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                r1._t
                WHEN 0 THEN json_build_object('0', jsonb_build_array())
                WHEN 1 THEN json_build_object('1', r1._1)
                WHEN 2 THEN json_build_object('2', r1._2)
              END
              ORDER BY
                r1.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::int2 AS _t,
              NULL::jsonb AS _1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::int2 AS _t,
              (
                SELECT
                  COALESCE(
                    jsonb_agg(
                      r0.value
                      ORDER BY
                        r0.index
                    ),
                    '[]'::jsonb
                  ) AS value
                FROM
                  (
                    SELECT
                      0::int8 AS index,
                      'today' AS value
                    UNION
                    ALL
                    SELECT
                      1::int8 AS index,
                      'me' AS value
                  ) AS r0
              ) AS _1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              2::int8 AS index,
              2::int2 AS _t,
              NULL::jsonb AS _1,
              'ok' AS _2
          ) AS r1
      ) AS _1
    ---
    {
      "statuses:",
      [
        Pending,
        InProgress([
          "today",
          "me",
        ]),
        Done("ok"),
      ],
    }
    "#);
}

#[test]
fn tuple_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {3: int16, {false, true, {"hello"}, 4: int32}}
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      3::int2 AS _0,
      FALSE AS _1_0,
      TRUE AS _1_1,
      'hello' AS _1_2_0,
      4::int4 AS _1_3
    ---
    {
      3,
      {
        false,
        true,
        {
          "hello",
        },
        4,
      },
    }
    "#);
}

#[test]
fn tuple_array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {true, [1, 2, 3]: [int64], [4]: [int32], false}
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      TRUE AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int8 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              2::int8 AS value
            UNION
            ALL
            SELECT
              2::int8 AS index,
              3::int8 AS value
          ) AS r0
      ) AS _1,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r1.value
              ORDER BY
                r1.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              4::int4 AS value
          ) AS r1
      ) AS _2,
      FALSE AS _3
    ---
    {
      true,
      [
        1,
        2,
        3,
      ],
      [
        4,
      ],
      false,
    }
    ");
}

#[test]
fn tuple_array_enum() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          Pending, InProgress: {started_at: text, owner: text}, Done: text
        }
        const main = {
          "statuses:",
          [Status::Pending, Status::InProgress({"today", "me"}), Status::Done("ok")],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'statuses:' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                r0._t
                WHEN 0 THEN json_build_object('0', jsonb_build_array())
                WHEN 1 THEN json_build_object('1', jsonb_build_array(r0._1_0, r0._1_1))
                WHEN 2 THEN json_build_object('2', r0._2)
              END
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::int2 AS _t,
              NULL::text AS _1_0,
              NULL::text AS _1_1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::int2 AS _t,
              'today' AS _1_0,
              'me' AS _1_1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              2::int8 AS index,
              2::int2 AS _t,
              NULL::text AS _1_0,
              NULL::text AS _1_1,
              'ok' AS _2
          ) AS r0
      ) AS _1
    ---
    {
      "statuses:",
      [
        Pending,
        InProgress({
          started_at = "today",
          owner = "me",
        }),
        Done("ok"),
      ],
    }
    "#);
}

#[test]
fn tuple_array_empty() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {true, []: [int64], false}
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      TRUE AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0 AS index,
              NULL::int8 AS value
            WHERE
              FALSE
          ) AS r0
      ) AS _1,
      FALSE AS _2
    ---
    {
      true,
      [],
      false,
    }
    ");
}

#[test]
fn array_array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [[1, 2, 3], [4, 5]]: [[int64]]
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r2.value
    FROM
      (
        SELECT
          0::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r0.value
                  ORDER BY
                    r0.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  1::int8 AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  2::int8 AS value
                UNION
                ALL
                SELECT
                  2::int8 AS index,
                  3::int8 AS value
              ) AS r0
          ) AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r1.value
                  ORDER BY
                    r1.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  4::int8 AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  5::int8 AS value
              ) AS r1
          ) AS value
      ) AS r2
    ORDER BY
      r2.index
    ---
    [
      [
        1,
        2,
        3,
      ],
      [
        4,
        5,
      ],
    ]
    ");
}

#[test]
fn array_array_array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [[[{1: int32, "hello", 2: int16}]]]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r2.value
    FROM
      (
        SELECT
          0::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r1.value
                  ORDER BY
                    r1.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  (
                    SELECT
                      COALESCE(
                        jsonb_agg(
                          jsonb_build_array(r0._0, r0._1, r0._2)
                          ORDER BY
                            r0.index
                        ),
                        '[]'::jsonb
                      ) AS value
                    FROM
                      (
                        SELECT
                          0::int8 AS index,
                          1::int4 AS _0,
                          'hello' AS _1,
                          2::int2 AS _2
                      ) AS r0
                  ) AS value
              ) AS r1
          ) AS value
      ) AS r2
    ORDER BY
      r2.index
    ---
    [
      [
        [
          {
            1,
            "hello",
            2,
          },
        ],
      ],
    ]
    "#);
}

#[test]
fn tuple_array_tuple_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main =
          {
            1: int32,
            [
              {
                1: int32,
                {
                  1: int32, true, 2: int16
                },
                2: int16
              }
            ],
            2: int16
          }
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      1::int4 AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              jsonb_build_array(
                r0._0,
                jsonb_build_array(r0._1_0, r0._1_1, r0._1_2),
                r0._2
              )
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int4 AS _0,
              1::int4 AS _1_0,
              TRUE AS _1_1,
              2::int2 AS _1_2,
              2::int2 AS _2
          ) AS r0
      ) AS _1,
      2::int2 AS _2
    ---
    {
      1,
      [
        {
          1,
          {
            1,
            true,
            2,
          },
          2,
        },
      ],
      2,
    }
    ");
}

#[test]
fn array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [{3: int64, false}, {6, true}, {12, false}]
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r0._0,
      r0._1
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int8 AS _0,
          FALSE AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          6::int8 AS _0,
          TRUE AS _1
        UNION
        ALL
        SELECT
          2::int8 AS index,
          12::int8 AS _0,
          FALSE AS _1
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      {
        3,
        false,
      },
      {
        6,
        true,
      },
      {
        12,
        false,
      },
    ]
    ");
}

#[test]
fn tuple_array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {
            "hello",
            [{3: int16, false}, {6, true}, {12, false}],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'hello' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              jsonb_build_array(r0._0, r0._1)
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              3::int2 AS _0,
              FALSE AS _1
            UNION
            ALL
            SELECT
              1::int8 AS index,
              6::int2 AS _0,
              TRUE AS _1
            UNION
            ALL
            SELECT
              2::int8 AS index,
              12::int2 AS _0,
              FALSE AS _1
          ) AS r0
      ) AS _1
    ---
    {
      "hello",
      [
        {
          3,
          false,
        },
        {
          6,
          true,
        },
        {
          12,
          false,
        },
      ],
    }
    "#);
}

#[test]
fn param_00() {
    insta::assert_snapshot!(_run(r#"
    func main(x: int64) -> x + 1
    "#,
    lutra_bin::Value::Prim64(3)
    ).1, @"4");
}

#[test]
fn param_01() {
    insta::assert_snapshot!(_run(r#"
    func main(x: int64, y: text) -> {y, x}
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Prim64(3),
        lutra_bin::Value::Text("hello".into())
    ])
    ).1, @r#"
    {
      "hello",
      3,
    }
    "#);
}

#[test]
fn param_02() {
    insta::assert_snapshot!(_run(r#"
    func main(x: {int64, {text, bool}, int32}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Prim64(3),
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Text("hello".into()),
            lutra_bin::Value::Prim8(1),
        ]),
        lutra_bin::Value::Prim32(5),
    ])
    ).1, @r#"
    {
      3,
      {
        "hello",
        true,
      },
      5,
    }
    "#);
}

#[test]
fn param_03() {
    insta::assert_snapshot!(_run(r#"
    func main(x: {int64, [text], int32}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Prim64(3),
        lutra_bin::Value::Array(vec![
            lutra_bin::Value::Text("hello".into()),
            lutra_bin::Value::Text("world".into()),
        ]),
        lutra_bin::Value::Prim32(5),
    ])
    ).1, @r#"
    {
      3,
      [
        "hello",
        "world",
      ],
      5,
    }
    "#);
}

#[test]
fn param_04() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int64, text}]) -> std::index(x, 1)
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim64(5),
            lutra_bin::Value::Text("hello".into()),
        ]),
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim64(7),
            lutra_bin::Value::Text("world".into()),
        ]),
    ])
    ).1, @r#"
    Some({
      7,
      "world",
    })
    "#);
}

#[test]
fn param_05() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int32, {int32, int16}, int16}]) -> x
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(5),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Prim32(7),
                lutra_bin::Value::Prim16(7),
            ]),
            lutra_bin::Value::Prim16(1212),
        ])
    ])
    ).1, @r"
    [
      {
        5,
        {
          7,
          7,
        },
        1212,
      },
    ]
    ");
}

#[test]
fn param_06() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int32, {int32, int16}, int16}]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(5),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Prim32(7),
                lutra_bin::Value::Prim16(7),
            ]),
            lutra_bin::Value::Prim16(1212),
        ])
    ])
    ).1, @r#"
    {
      "hello",
      [
        {
          5,
          {
            7,
            7,
          },
          1212,
        },
      ],
    }
    "#);
}

#[test]
fn param_07() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Status: enum {
      Pending, InProgress: {started_at: text, owner: text}, Done: text
    }
    func main(x: Status) -> {"hello", x}
    "#,
    lutra_bin::Value::Enum(
        1,
        Box::new(lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Text("today".into()),
            lutra_bin::Value::Text("me".into())
        ]))
    )
    )), @r#"
    SELECT
      'hello' AS _0,
      $1::int2 AS _1_t,
      $2::text AS _1_1_0,
      $3::text AS _1_1_1,
      $4::text AS _1_2
    ---
    {
      "hello",
      InProgress({
        started_at = "today",
        owner = "me",
      }),
    }
    "#);
}

#[test]
fn param_08() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Status: enum {
      Pending, InProgress: {started_at: text, owner: text}, Done: text
    }
    func main(x: [Status]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Enum(
            1,
            Box::new(lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Text("today".into()),
                lutra_bin::Value::Text("me".into())
            ]))
        ),
        lutra_bin::Value::Enum(
            0,
            Box::new(lutra_bin::Value::Tuple(vec![]))
        ),
        lutra_bin::Value::Enum(
            2,
            Box::new(lutra_bin::Value::Text("ok".into()))
        ),
    ])
    )), @r#"
    SELECT
      'hello' AS _0,
      $1::jsonb AS _1
    ---
    {
      "hello",
      [
        InProgress({
          started_at = "today",
          owner = "me",
        }),
        Pending,
        Done("ok"),
      ],
    }
    "#);
}

#[test]
fn param_09() {
    insta::assert_snapshot!(_run(r#"
    type Status: enum {
      Pending, InProgress: {started_at: text, owner: text}, Done: text
    }
    func main(x: {text, Status}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Text("hello".into()),
        lutra_bin::Value::Enum(
            2,
            Box::new(lutra_bin::Value::Text("ok".into()))
        ),
    ])
    ).1, @r#"
    {
      "hello",
      Done("ok"),
    }
    "#);
}

#[test]
fn param_10() {
    insta::assert_snapshot!(_run(r#"
    func main(x: std::Date) -> x
    "#,
    lutra_bin::Value::Prim32(10000)
    ).1, @"@1997-05-19");
}

#[test]
fn tuple_unpacking_00() {
    insta::assert_snapshot!(_run(r#"
    func main() -> {
      4: int16,
      ([{id = 3: int32, title = "Hello world!"}] | std::index(0)),
    }
    "#,
    lutra_bin::Value::unit(),
    ).1, @r#"
    {
      4,
      Some({
        id = 3,
        title = "Hello world!",
      }),
    }
    "#);
}

#[test]
fn json_pack_00() {
    // Having array in a tuple forces serialization to JSON.
    // Applying an operation of that array then forces deserialization.

    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [2, 5, 4, 3, 1, 2]: [int32]}

    func main() -> (
      get_data().a
      | std::map(func (y: int32) -> -y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      -2,
      -5,
      -4,
      -3,
      -1,
      -2,
    ]
    "#);
}

#[test]
fn json_pack_01() {
    // Having array in a tuple forces serialization to JSON.
    // Applying an operation of that array then forces deserialization.

    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [{2: int32, false}, {5, true}, {4, false}]}

    func main() -> (
      get_data().a
      | std::map(func (y: {int32, bool}) -> {-y.0, !y.1})
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        -2,
        true,
      },
      {
        -5,
        false,
      },
      {
        -4,
        true,
      },
    ]
    "#);
}

#[test]
fn json_pack_02() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> [[1: int16, 2, 3], [4, 5, 6]]

    func main() -> (
      get_data() | std::map(func (y: [int16]) -> (
        std::index(y, 1)
      ))
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      Some(2),
      Some(5),
    ]
    ");
}

#[test]
fn json_pack_03() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> [[1: int64, 2, 3], [4, 5, 6]]

    func main() -> (
      get_data()
      | std::map(func (y: [int64]) -> (
        y | std::map(func (z: int64) -> 6-z)
      ))
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      [
        5,
        4,
        3,
      ],
      [
        2,
        1,
        0,
      ],
    ]
    "#);
}

#[test]
fn json_pack_04() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [false, true, true]}

    func main() -> (
      get_data().a
      | std::map(func (y: bool) -> !y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      true,
      false,
      false,
    ]
    "#);
}

#[test]
fn json_pack_05() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = ["no", "yes", "neither"]}

    func main() -> (
      get_data().a
      | std::map(func (y: text) -> y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      "no",
      "yes",
      "neither",
    ]
    "#);
}

#[test]
fn json_pack_06() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      {"hello", [[true]]}.1
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      [
        true,
      ],
    ]
    ");
}

#[test]
fn json_pack_07() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      {
        "hello",
        [
          {
            "hello",
            [{1: int32, {1: int32, [5: int32], 2: int16}, 2: int16}]
          }.1
        ]
      }.1
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      [
        {
          1,
          {
            1,
            [
              5,
            ],
            2,
          },
          2,
        },
      ],
    ]
    ");
}

#[test]
fn json_pack_08() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      std::index([["hello"]], 0)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    Some([
      "hello",
    ])
    "#);
}

#[test]
fn json_pack_09() {
    // JsonUnpack(JsonPack(_)) should be optimized away

    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(x: [int8]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Prim8(1),
        lutra_bin::Value::Prim8(2),
        lutra_bin::Value::Prim8(3),
    ]))), @r#"
    SELECT
      'hello' AS _0,
      $1::jsonb AS _1
    ---
    {
      "hello",
      [
        1,
        2,
        3,
      ],
    }
    "#);
}

#[test]
fn json_pack_10() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main() -> {"hello", [1: int8, 2]}
    "#,
    lutra_bin::Value::unit())), @r#"
    SELECT
      'hello' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int2 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              2::int2 AS value
          ) AS r0
      ) AS _1
    ---
    {
      "hello",
      [
        1,
        2,
      ],
    }
    "#);
}

#[test]
fn if_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const en = ["yes", "no"]
    const sl = ["da", "ne"]
    const lang = "sl"

    func main() -> if lang == "en" then en else sl
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r5.value
    FROM
      (
        WITH r0 AS (
          SELECT
            CASE
              WHEN ('sl' = 'en') THEN 0::int2
              ELSE 1::int2
            END AS value
        )
        SELECT
          r1.index,
          r1.value
        FROM
          (
            SELECT
              0::int8 AS index,
              'yes' AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              'no' AS value
          ) AS r1
        WHERE
          (
            (
              SELECT
                r2.value AS value
              FROM
                r0 AS r2
            ) = 0::int2
          )
        UNION
        ALL
        SELECT
          r3.index,
          r3.value
        FROM
          (
            SELECT
              0::int8 AS index,
              'da' AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              'ne' AS value
          ) AS r3
        WHERE
          (
            (
              SELECT
                r4.value AS value
              FROM
                r0 AS r4
            ) = 1::int2
          )
      ) AS r5
    ORDER BY
      r5.index
    ---
    [
      "da",
      "ne",
    ]
    "#);
}

#[test]
fn match_04() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Animal: enum {
      Cat: text,
      Dog: enum {Collie: text, Generic},
    }

    func main() -> (
      [
        Animal::Cat("Whiskers"),
        Animal::Dog(Animal::Dog::Collie("Belie")),
        Animal::Dog(Animal::Dog::Generic),
      ]
      | std::map(func (animal: Animal) -> match animal {
        .Cat(name) => f"Hello {name}",
        .Dog(.Generic) => "Who's a good boy?",
        .Dog(.Collie(name)) => f"Come here {name}",
      })
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      (
        SELECT
          CASE
            WHEN (r1._t = 0::int2) THEN ('Hello ' || r1._0)
            WHEN (
              (r1._t = 1::int2)
              AND (r1._1_t = 1::int2)
            ) THEN 'Who''s a good boy?'
            ELSE ('Come here ' || r1._1_0)
          END AS value
        FROM
          (
            SELECT
              r0._t AS _t,
              r0._0 AS _0,
              r0._1_t AS _1_t,
              r0._1_0 AS _1_0
          ) AS r1
      ) AS value
    FROM
      (
        SELECT
          0::int8 AS index,
          0::int2 AS _t,
          'Whiskers' AS _0,
          NULL::int2 AS _1_t,
          NULL::text AS _1_0
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::int2 AS _t,
          NULL::text AS _0,
          0::int2 AS _1_t,
          'Belie' AS _1_0
        UNION
        ALL
        SELECT
          2::int8 AS index,
          1::int2 AS _t,
          NULL::text AS _0,
          1::int2 AS _1_t,
          NULL::text AS _1_0
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      "Hello Whiskers",
      "Come here Belie",
      "Who's a good boy?",
    ]
    "#);
}
#[test]
fn match_05() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const name = "Tom"

    func main() -> match name {
      "world" => "Hello world!",
      n => f"Hello {n}"
    }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      CASE
        WHEN (r0.value = 'world') THEN 'Hello world!'
        ELSE ('Hello ' || r0.value)
      END AS value
    FROM
      (
        SELECT
          'Tom' AS value
      ) AS r0
    ---
    "Hello Tom"
    "#);
}

#[tokio::test(flavor = "current_thread")]
async fn sql_from_00() {
    let client = _get_test_db_client().await.unwrap();
    let mut runner = RunnerAsync::new(client);

    insta::assert_snapshot!(_sql_and_output(_run_on(&mut runner, r#"
    type Movie: {
      id: int32,
      title: text,
      premiere_date: std::Date,
      director_id: enum {None, Some: int16},
    }

    func main(): [Movie] -> std::sql::from("movies")
    "#, lutra_bin::Value::unit()).await), @r#"
    SELECT
      id::int4 AS _0,
      title::text AS _1,
      (premiere_date::date - '1970-01-01'::date) AS _2,
      director_id::int2 AS _3
    FROM
      movies
    ORDER BY
      NULL::int4
    ---
    [
      {
        id = 1,
        title = "Forrest Gump",
        premiere_date = @1994-04-22,
        director_id = Some(3),
      },
      {
        id = 2,
        title = "The Prestige",
        premiere_date = @2006-06-14,
        director_id = None,
      },
    ]
    "#);
}

#[tokio::test(flavor = "current_thread")]
async fn sql_from_01() {
    // test schema names

    let client = _get_test_db_client().await.unwrap();
    let mut runner = RunnerAsync::new(client);

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    type Movie: {title: text}

    func main(): [Movie] -> std::sql::from("public/movies")
    "#, lutra_bin::Value::unit()).await.1, @r#"
    [
      {
        title = "Forrest Gump",
      },
      {
        title = "The Prestige",
      },
    ]
    "#);

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    type Day: {name: text}

    func main(): [Day] -> std::sql::from("another/days")
    "#, lutra_bin::Value::unit()).await.1, @r#"
    [
      {
        name = "Monday",
      },
      {
        name = "Tuesday",
      },
    ]
    "#);

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    type Day: {name: text}

    func main(): [Day] -> std::sql::from("another/proj/days")
    "#, lutra_bin::Value::unit()).await.1, @r#"
    [
      {
        name = "Wednesday",
      },
      {
        name = "Thursday",
      },
      {
        name = "Friday",
      },
    ]
    "#);
}

#[tokio::test(flavor = "current_thread")]
async fn sql_insert_00() {
    let mut client = _get_test_db_client().await.unwrap();
    let tran = client.transaction().await.unwrap();
    let mut runner = RunnerAsync::new(tran);

    insta::assert_snapshot!(_sql_and_output(_run_on(&mut runner, r#"
    type Movie: {
      title: text,
      premiere_date: std::Date,
    }
    const two_movies: [Movie] = [
      {title = "Memento", premiere_date = @2000-02-29},
      {title = "Inception", premiere_date = @2010-10-12}
    ]

    func main(): {} -> std::sql::insert(two_movies, "movies")
    "#, lutra_bin::Value::unit()).await), @r"
    INSERT INTO
      movies (title, premiere_date)
    SELECT
      r0._0,
      ('1970-01-01'::date + r0._1)
    FROM
      (
        SELECT
          0::int8 AS index,
          'Memento' AS _0,
          11016::int4 AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          'Inception' AS _0,
          14894::int4 AS _1
      ) AS r0
    ---
    {
    }
    ");

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    type Movie: {
      id: int32,
      title: text,
      premiere_date: std::Date,
    }
    func main() -> (
      (std::sql::from("movies"): [Movie])
      | std::sort(func (m) -> m.id | std::to_int64)
      | std::map(func (m) -> {m.title, m.premiere_date: std::Date})
    )
    "#, lutra_bin::Value::unit()).await.1, @r#"
    [
      {
        title = "Forrest Gump",
        @1994-04-22,
      },
      {
        title = "The Prestige",
        @2006-06-14,
      },
      {
        title = "Memento",
        @2000-02-29,
      },
      {
        title = "Inception",
        @2010-10-12,
      },
    ]
    "#);
}

#[test]
fn group_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const values: [int64] = [1, 1, 1, 3, 2, 3]

    func main() -> (
      values
      | std::group(func (x) -> x)
      | std::map(func (this) -> {
        value = this.key,
        sum = std::sum(this.values),
      })
    )
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r0.value AS _0,
      (
        SELECT
          COALESCE(SUM(r0.value), 0)::int8 AS value
      ) AS _1
    FROM
      (
        SELECT
          0::int8 AS index,
          1::int8 AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::int8 AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          1::int8 AS value
        UNION
        ALL
        SELECT
          3::int8 AS index,
          3::int8 AS value
        UNION
        ALL
        SELECT
          4::int8 AS index,
          2::int8 AS value
        UNION
        ALL
        SELECT
          5::int8 AS index,
          3::int8 AS value
      ) AS r0
    GROUP BY
      r0.value
    ORDER BY
      (ROW_NUMBER() OVER ())::int4
    ---
    [
      {
        value = 1,
        sum = 3,
      },
      {
        value = 3,
        sum = 6,
      },
      {
        value = 2,
        sum = 2,
      },
    ]
    ");
}

#[test]
fn opt_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type OptText: enum {
      None,
      Some: text,
    }
    func main() -> {
      OptText::Some("hello"),
      OptText::None,
      std::is_some(OptText::Some("hello")),
      std::is_none(OptText::Some("hello")),
    }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'hello' AS _0,
      NULL::text AS _1,
      (
        SELECT
          CASE
            WHEN r0.value IS NOT NULL THEN TRUE
            ELSE FALSE
          END AS value
        FROM
          (
            SELECT
              'hello' AS value
          ) AS r0
      ) AS _2,
      (
        SELECT
          CASE
            WHEN r1.value IS NOT NULL THEN FALSE
            ELSE TRUE
          END AS value
        FROM
          (
            SELECT
              'hello' AS value
          ) AS r1
      ) AS _3
    ---
    {
      Some("hello"),
      None,
      true,
      false,
    }
    "#);
}

#[test]
fn opt_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type OptText: enum {
      None,
      Some: text,
    }
    func main() -> (
      [OptText::Some("hello"), OptText::None, OptText::Some("world")]
      | std::map(func (x) -> match x {
          .Some(x) => x,
          .None => "none",
        })
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      (
        SELECT
          CASE
            WHEN r1.value IS NOT NULL THEN r1.value
            ELSE 'none'
          END AS value
        FROM
          (
            SELECT
              r0.value AS value
          ) AS r1
      ) AS value
    FROM
      (
        SELECT
          0::int8 AS index,
          'hello' AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          NULL::text AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          'world' AS value
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      "hello",
      "none",
      "world",
    ]
    "#);
}

#[test]
fn std_sql_expr() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(): [{hello: text, world: bool, x: std::Date}]
    -> std::sql::expr(
      "select 'a' as hello, TRUE as world, '2025-11-14'::date as x"
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r0.hello::text AS _0,
      r0.world::bool AS _1,
      (r0.x::date - '1970-01-01'::date) AS _2
    FROM
      (
        select
          'a' as hello,
          TRUE as world,
          '2025-11-14'::date as x
      ) AS r0
    ORDER BY
      NULL::int4
    ---
    [
      {
        hello = "a",
        world = true,
        x = @2025-11-14,
      },
    ]
    "#);
}

#[tokio::test(flavor = "current_thread")]
async fn pull_interface() {
    let client = _get_test_db_client().await.unwrap();
    let runner = RunnerAsync::new(client);

    insta::assert_snapshot!(runner.get_interface().await.unwrap(), @r#"
    type Person: {id: int32, first_name: text, last_name: text}
    func from_persons(): [Person] -> std::sql::from("persons")
    func insert_persons(values: [Person]) -> std::sql::insert(values, "persons")

    ## Lookup Person using persons_pkey index
    func get_persons_by_id(id: int32): Person -> (
      from_persons() | std::find(func (x) -> x.id == id)
    )

    type Movie: {id: int32, title: text, premiere_date: std::Date, director_id: int16}
    func from_movies(): [Movie] -> std::sql::from("movies")
    func insert_movies(values: [Movie]) -> std::sql::insert(values, "movies")

    ## Lookup Movie using movies_pkey index
    func get_movies_by_id(id: int32): Movie -> (
      from_movies() | std::find(func (x) -> x.id == id)
    )

    ## Lookup Movie using movies_premiere_date_idx index
    func get_movies_by_premiere_date(premiere_date: int32): [Movie] -> (
      from_movies() | std::filter(func (x) -> x.premiere_date == premiere_date)
    )

    type MovieActor: {source: int32, target: int32, role: text}
    func from_movie_actors(): [MovieActor] -> std::sql::from("movie_actors")
    func insert_movie_actors(values: [MovieActor]) -> std::sql::insert(values, "movie_actors")

    module another {

      type Day: {id: int32, name: text}
      func from_days(): [Day] -> std::sql::from("days")
      func insert_days(values: [Day]) -> std::sql::insert(values, "days")

      ## Lookup Day using days_pkey index
      func get_days_by_id(id: int32): Day -> (
        from_days() | std::find(func (x) -> x.id == id)
      )

      type Proj/day: {id: int32, name: text}
      func from_proj/days(): [Proj/day] -> std::sql::from("proj/days")
      func insert_proj/days(values: [Proj/day]) -> std::sql::insert(values, "proj/days")

      ## Lookup Proj/day using proj/days_pkey index
      func get_proj/days_by_id(id: int32): Proj/day -> (
        from_proj/days() | std::find(func (x) -> x.id == id)
      )
    }
    "#);
}
