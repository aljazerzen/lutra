use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::{env, sync, time};

use lutra_compiler::{ProgramFormat, SourceTree};
use lutra_runner::Run;
use lutra_runner_postgres::RunnerAsync;
use tokio::io::{AsyncRead, AsyncWrite};

use crate::POSTGRES_URL_SHARED;

#[track_caller]
#[tokio::main(flavor = "current_thread")]
pub async fn _run(source: &str, input: lutra_bin::Value) -> (String, String) {
    let mut client = run_connection(
        tokio_postgres::connect(POSTGRES_URL_SHARED, tokio_postgres::NoTls)
            .await
            .unwrap(),
    );

    let tran = client.transaction().await.unwrap();

    let mut runner = RunnerAsync::new(tran);
    let r = _run_on(&mut runner, source, input).await;
    runner.into_inner().rollback().await.unwrap();
    r
}

pub async fn _run_on(
    runner: &mut impl lutra_runner::Run,
    source: &str,
    input: lutra_bin::Value,
) -> (String, String) {
    crate::init_logger();

    // compile
    let source = SourceTree::single("".into(), source.to_string());
    let project = match lutra_compiler::check(source, Default::default()) {
        Ok(p) => p,
        Err(e) => return (String::new(), format!("check error:\n{e}")),
    };

    // compile to sql
    let res = lutra_compiler::compile(&project, "main", None, ProgramFormat::SqlPg);
    let (program, ty) = match res {
        Ok(x) => x,
        Err(e) => return (String::new(), format!("compile error:\n{e}")),
    };

    // format sql
    let formatted_sql = {
        let program = program.as_sql_postgres().unwrap();
        let options = sqlformat::FormatOptions::default();
        sqlformat::format(&program.sql, &sqlformat::QueryParams::None, &options)
    };

    let input = input.encode(&ty.input, &ty.defs).unwrap();

    // execute
    let program = runner.prepare(program).await.unwrap();
    let output = runner.execute(&program, &input).await.unwrap();

    // decode and print source
    let output = lutra_bin::print_source(&output, &ty.output, &ty.defs).unwrap();

    (formatted_sql, output)
}

pub fn _sql_and_output((sql, output): (String, String)) -> String {
    format!("{sql}\n---\n{output}")
}

static RUN_ID: sync::LazyLock<u64> = sync::LazyLock::new(|| {
    let mut h = std::hash::DefaultHasher::new();
    if let Ok(run_id) = env::var("NEXTEST_RUN_ID") {
        run_id.hash(&mut h);
    } else {
        time::SystemTime::now().hash(&mut h);
    }
    h.finish()
});

pub async fn _get_test_db_client() -> Result<tokio_postgres::Client, tokio_postgres::Error> {
    let run_id = *RUN_ID as i64;
    let db_name = format!("l-test-{run_id:016x}");

    let config_shared = POSTGRES_URL_SHARED.parse::<tokio_postgres::Config>()?;
    let mut config_test = config_shared.clone();
    config_test.dbname(&db_name);

    let client_main = run_connection(config_shared.connect(tokio_postgres::NoTls).await?);
    client_main
        .execute("SELECT pg_advisory_lock($1)", &[&run_id])
        .await?;

    let databases: HashSet<String> = client_main
        .query("SELECT datname FROM pg_database", &[])
        .await?
        .iter()
        .map(|r| r.get::<_, String>(0))
        .filter(|d| d.starts_with("l-test-"))
        .collect();

    if !databases.contains(&db_name) {
        // cleanup old test dbs
        for d in databases {
            client_main
                .execute(&format!("DROP DATABASE \"{d}\""), &[])
                .await?;
        }

        // create test db
        client_main
            .execute(&format!("CREATE DATABASE \"{db_name}\""), &[])
            .await?;
    }
    drop(client_main); // this will release the lock

    Ok(run_connection(
        config_test.connect(tokio_postgres::NoTls).await?,
    ))
}

pub fn run_connection<S, T>(
    (client, conn): (tokio_postgres::Client, tokio_postgres::Connection<S, T>),
) -> tokio_postgres::Client
where
    S: AsyncWrite + AsyncRead + Unpin + Send + 'static,
    T: AsyncWrite + AsyncRead + Unpin + Send + 'static,
{
    tokio::task::spawn(async {
        if let Err(e) = conn.await {
            eprintln!("{e}");
        }
    });
    client
}

const MOVIES_SETUP: &str = r#"
CREATE TABLE persons (
    id int4 primary key generated by default as identity,
    first_name text not null,
    last_name text
);

CREATE TABLE movies (
    id int4 primary key generated by default as identity,
    title text not null,
    premiere_date date,
    director_id int2 references persons(id)
);
CREATE INDEX ON movies (premiere_date);

CREATE TABLE movie_actors (
    source int4 references movies(id),
    target int4 references persons(id),
    role text
);

CREATE SCHEMA another;
CREATE TABLE another.days (
    id int4 primary key generated by default as identity,
    name text
);
CREATE TABLE another."proj/days" (
    id int4 primary key generated by default as identity,
    name text
);

INSERT INTO persons (first_name, last_name) VALUES ('Tom', 'Hanks');
INSERT INTO persons (first_name) VALUES ('Robin');
INSERT INTO persons (first_name, last_name) VALUES ('Steven', 'Spielberg');

INSERT INTO movies (title, premiere_date, director_id)
  SELECT
    'Forrest Gump',
    '1994-04-22',
    (SELECT id FROM persons WHERE first_name = 'Steven');
INSERT INTO movie_actors (source, target)
  SELECT
    (SELECT id FROM movies WHERE title = 'Forrest Gump'),
    p.id
  FROM (
    SELECT id FROM persons WHERE first_name in ('Tom', 'Robin')
  ) p;
INSERT INTO movies (title, premiere_date, director_id)
  SELECT
    'The Prestige',
    '2006-06-14',
    NULL;

INSERT INTO another.days (name) VALUES ('Monday'), ('Tuesday');
INSERT INTO another."proj/days" (name) VALUES ('Wednesday'), ('Thursday'), ('Friday');
"#;

#[test]
fn prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = 3: int16
    "#, lutra_bin::Value::unit())), @"
    SELECT
      3::int2 AS value
    ---
    3
    ");
}

#[test]
fn tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {3: int16, false}
    "#, lutra_bin::Value::unit())), @"
    SELECT
      3::int2 AS _0,
      FALSE AS _1
    ---
    {
      3,
      false,
    }
    ");
}

#[test]
fn array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [3, 6, 12]: [int16]
    "#, lutra_bin::Value::unit())), @"
    SELECT
      r0.value
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int2 AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          6::int2 AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          12::int2 AS value
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      3,
      6,
      12,
    ]
    ");
}

#[test]
fn array_empty() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = []: [bool]
    "#, lutra_bin::Value::unit())), @"
    SELECT
      NULL::bool AS value
    WHERE
      FALSE
    ---
    []
    ");
}

#[test]
fn array_enum() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          pending, in_progress: {started_at: text, owner: text}, done: text
        }
        const main: [Status] = [.pending, .in_progress({"today", "me"}), .done("ok")]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r0._t,
      r0._1_0,
      r0._1_1,
      r0._2
    FROM
      (
        SELECT
          0::int8 AS index,
          0::int2 AS _t,
          NULL::text AS _1_0,
          NULL::text AS _1_1,
          NULL::text AS _2
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::int2 AS _t,
          'today'::text AS _1_0,
          'me'::text AS _1_1,
          NULL::text AS _2
        UNION
        ALL
        SELECT
          2::int8 AS index,
          2::int2 AS _t,
          NULL::text AS _1_0,
          NULL::text AS _1_1,
          'ok'::text AS _2
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      pending,
      in_progress({
        started_at = "today",
        owner = "me",
      }),
      done("ok"),
    ]
    "#);
}

#[test]
fn enum_array() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          pending, in_progress: [text], done: text
        }
        const main = {
          "statuses:",
          [.pending, .in_progress(["today", "me"]), .done("ok"): Status],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'statuses:'::text AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                r1._t
                WHEN 0 THEN jsonb_build_object('0', jsonb_build_array())
                WHEN 1 THEN jsonb_build_object('1', r1._1)
                WHEN 2 THEN jsonb_build_object('2', r1._2)
              END
              ORDER BY
                r1.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::int2 AS _t,
              NULL::jsonb AS _1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::int2 AS _t,
              (
                SELECT
                  COALESCE(
                    jsonb_agg(
                      r0.value
                      ORDER BY
                        r0.index
                    ),
                    '[]'::jsonb
                  ) AS value
                FROM
                  (
                    SELECT
                      0::int8 AS index,
                      'today'::text AS value
                    UNION
                    ALL
                    SELECT
                      1::int8 AS index,
                      'me'::text AS value
                  ) AS r0
              ) AS _1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              2::int8 AS index,
              2::int2 AS _t,
              NULL::jsonb AS _1,
              'ok'::text AS _2
          ) AS r1
      ) AS _1
    ---
    {
      "statuses:",
      [
        pending,
        in_progress([
          "today",
          "me",
        ]),
        done("ok"),
      ],
    }
    "#);
}

#[test]
fn tuple_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {3: int16, {false, true, {"hello"}, 4: int32}}
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      3::int2 AS _0,
      FALSE AS _1_0,
      TRUE AS _1_1,
      'hello'::text AS _1_2_0,
      4::int4 AS _1_3
    ---
    {
      3,
      {
        false,
        true,
        {
          "hello",
        },
        4,
      },
    }
    "#);
}

#[test]
fn tuple_array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {true, [1, 2, 3]: [int64], [4]: [int32], false}
    "#, lutra_bin::Value::unit())), @"
    SELECT
      TRUE AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int8 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              2::int8 AS value
            UNION
            ALL
            SELECT
              2::int8 AS index,
              3::int8 AS value
          ) AS r0
      ) AS _1,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r1.value
              ORDER BY
                r1.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              4::int4 AS value
          ) AS r1
      ) AS _2,
      FALSE AS _3
    ---
    {
      true,
      [
        1,
        2,
        3,
      ],
      [
        4,
      ],
      false,
    }
    ");
}

#[test]
fn tuple_array_enum() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          pending, in_progress: {started_at: text, owner: text}, done: text
        }
        const main = {
          "statuses:",
          [.pending, .in_progress({"today", "me"}), .done("ok")]: [Status],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'statuses:'::text AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                r0._t
                WHEN 0 THEN jsonb_build_object('0', jsonb_build_array())
                WHEN 1 THEN jsonb_build_object('1', jsonb_build_array(r0._1_0, r0._1_1))
                WHEN 2 THEN jsonb_build_object('2', r0._2)
              END
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::int2 AS _t,
              NULL::text AS _1_0,
              NULL::text AS _1_1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::int2 AS _t,
              'today'::text AS _1_0,
              'me'::text AS _1_1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              2::int8 AS index,
              2::int2 AS _t,
              NULL::text AS _1_0,
              NULL::text AS _1_1,
              'ok'::text AS _2
          ) AS r0
      ) AS _1
    ---
    {
      "statuses:",
      [
        pending,
        in_progress({
          started_at = "today",
          owner = "me",
        }),
        done("ok"),
      ],
    }
    "#);
}

#[test]
fn tuple_array_option() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {
          "ids:",
          [.none, .some(5)]: [enum { none, some: int32 }],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'ids:'::text AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                WHEN r0.value IS NULL THEN jsonb '{"0": []}'
                ELSE jsonb_build_object('1', r0.value)
              END
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              NULL::int4 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              5::int4 AS value
          ) AS r0
      ) AS _1
    ---
    {
      "ids:",
      [
        none,
        some(5),
      ],
    }
    "#);
}

#[test]
fn tuple_array_empty() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {true, []: [int64], false}
    "#, lutra_bin::Value::unit())), @"
    SELECT
      TRUE AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0 AS index,
              NULL::int8 AS value
            WHERE
              FALSE
          ) AS r0
      ) AS _1,
      FALSE AS _2
    ---
    {
      true,
      [],
      false,
    }
    ");
}

#[test]
fn array_array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [[1, 2, 3], [4, 5]]: [[int64]]
    "#, lutra_bin::Value::unit())), @"
    SELECT
      r2.value
    FROM
      (
        SELECT
          0::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r0.value
                  ORDER BY
                    r0.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  1::int8 AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  2::int8 AS value
                UNION
                ALL
                SELECT
                  2::int8 AS index,
                  3::int8 AS value
              ) AS r0
          ) AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r1.value
                  ORDER BY
                    r1.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  4::int8 AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  5::int8 AS value
              ) AS r1
          ) AS value
      ) AS r2
    ORDER BY
      r2.index
    ---
    [
      [
        1,
        2,
        3,
      ],
      [
        4,
        5,
      ],
    ]
    ");
}

#[test]
fn array_array_array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [[[{1: int32, "hello", 2: int16}]]]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r1.value
              ORDER BY
                r1.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              (
                SELECT
                  COALESCE(
                    jsonb_agg(
                      jsonb_build_array(r0._0, r0._1, r0._2)
                      ORDER BY
                        r0.index
                    ),
                    '[]'::jsonb
                  ) AS value
                FROM
                  (
                    SELECT
                      0::int8 AS index,
                      1::int4 AS _0,
                      'hello'::text AS _1,
                      2::int2 AS _2
                  ) AS r0
              ) AS value
          ) AS r1
      ) AS value
    ORDER BY
      0::int8
    ---
    [
      [
        [
          {
            1,
            "hello",
            2,
          },
        ],
      ],
    ]
    "#);
}

#[test]
fn tuple_array_tuple_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main =
          {
            1: int32,
            [
              {
                1: int32,
                {
                  1: int32, true, 2: int16
                },
                2: int16
              }
            ],
            2: int16
          }
    "#, lutra_bin::Value::unit())), @"
    SELECT
      1::int4 AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              jsonb_build_array(
                r0._0,
                jsonb_build_array(r0._1_0, r0._1_1, r0._1_2),
                r0._2
              )
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int4 AS _0,
              1::int4 AS _1_0,
              TRUE AS _1_1,
              2::int2 AS _1_2,
              2::int2 AS _2
          ) AS r0
      ) AS _1,
      2::int2 AS _2
    ---
    {
      1,
      [
        {
          1,
          {
            1,
            true,
            2,
          },
          2,
        },
      ],
      2,
    }
    ");
}

#[test]
fn array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [{3: int64, false}, {6, true}, {12, false}]
    "#, lutra_bin::Value::unit())), @"
    SELECT
      r0._0,
      r0._1
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int8 AS _0,
          FALSE AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          6::int8 AS _0,
          TRUE AS _1
        UNION
        ALL
        SELECT
          2::int8 AS index,
          12::int8 AS _0,
          FALSE AS _1
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      {
        3,
        false,
      },
      {
        6,
        true,
      },
      {
        12,
        false,
      },
    ]
    ");
}

#[test]
fn tuple_array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {
            "hello",
            [{3: int16, false}, {6, true}, {12, false}],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'hello'::text AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              jsonb_build_array(r0._0, r0._1)
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              3::int2 AS _0,
              FALSE AS _1
            UNION
            ALL
            SELECT
              1::int8 AS index,
              6::int2 AS _0,
              TRUE AS _1
            UNION
            ALL
            SELECT
              2::int8 AS index,
              12::int2 AS _0,
              FALSE AS _1
          ) AS r0
      ) AS _1
    ---
    {
      "hello",
      [
        {
          3,
          false,
        },
        {
          6,
          true,
        },
        {
          12,
          false,
        },
      ],
    }
    "#);
}

#[test]
fn param_00() {
    insta::assert_snapshot!(_run(r#"
    func main(x: int64) -> x + 1
    "#,
    lutra_bin::Value::Prim64(3)
    ).1, @"4");
}

#[test]
fn param_01() {
    insta::assert_snapshot!(_run(r#"
    func main(x: int64, y: text) -> {y, x}
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Prim64(3),
        lutra_bin::Value::Text("hello".into())
    ])
    ).1, @r#"
    {
      y = "hello",
      x = 3,
    }
    "#);
}

#[test]
fn param_02() {
    insta::assert_snapshot!(_run(r#"
    func main(x: {int64, {text, bool}, int32}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Prim64(3),
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Text("hello".into()),
            lutra_bin::Value::Prim8(1),
        ]),
        lutra_bin::Value::Prim32(5),
    ])
    ).1, @r#"
    {
      3,
      {
        "hello",
        true,
      },
      5,
    }
    "#);
}

#[test]
fn param_03() {
    insta::assert_snapshot!(_run(r#"
    func main(x: {int64, [text], int32}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Prim64(3),
        lutra_bin::Value::Array(vec![
            lutra_bin::Value::Text("hello".into()),
            lutra_bin::Value::Text("world".into()),
        ]),
        lutra_bin::Value::Prim32(5),
    ])
    ).1, @r#"
    {
      3,
      [
        "hello",
        "world",
      ],
      5,
    }
    "#);
}

#[test]
fn param_04() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int64, text}]) -> std::index(x, 1)
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim64(5),
            lutra_bin::Value::Text("hello".into()),
        ]),
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim64(7),
            lutra_bin::Value::Text("world".into()),
        ]),
    ])
    ).1, @r#"
    some({
      7,
      "world",
    })
    "#);
}

#[test]
fn param_05() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int32, {int32, int16}, int16}]) -> x
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(5),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Prim32(7),
                lutra_bin::Value::Prim16(7),
            ]),
            lutra_bin::Value::Prim16(1212),
        ])
    ])
    ).1, @r"
    [
      {
        5,
        {
          7,
          7,
        },
        1212,
      },
    ]
    ");
}

#[test]
fn param_06() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int32, {int32, int16}, int16}]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(5),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Prim32(7),
                lutra_bin::Value::Prim16(7),
            ]),
            lutra_bin::Value::Prim16(1212),
        ])
    ])
    ).1, @r#"
    {
      "hello",
      x = [
        {
          5,
          {
            7,
            7,
          },
          1212,
        },
      ],
    }
    "#);
}

#[test]
fn param_07() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Status: enum {
      pending, in_progress: {started_at: text, owner: text}, done: text
    }
    func main(x: Status) -> {"hello", x}
    "#,
    lutra_bin::Value::Enum(
        1,
        Box::new(lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Text("today".into()),
            lutra_bin::Value::Text("me".into())
        ]))
    )
    )), @r#"
    SELECT
      'hello'::text AS _0,
      $1::int2 AS _1_t,
      $2::text AS _1_1_0,
      $3::text AS _1_1_1,
      $4::text AS _1_2
    ---
    {
      "hello",
      x = in_progress({
        started_at = "today",
        owner = "me",
      }),
    }
    "#);
}

#[test]
fn param_08() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Status: enum {
      pending, in_progress: {started_at: text, owner: text}, done: text
    }
    func main(x: [Status]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Enum(
            1,
            Box::new(lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Text("today".into()),
                lutra_bin::Value::Text("me".into())
            ]))
        ),
        lutra_bin::Value::Enum(
            0,
            Box::new(lutra_bin::Value::Tuple(vec![]))
        ),
        lutra_bin::Value::Enum(
            2,
            Box::new(lutra_bin::Value::Text("ok".into()))
        ),
    ])
    )), @r#"
    SELECT
      'hello'::text AS _0,
      $1::jsonb AS _1
    ---
    {
      "hello",
      x = [
        in_progress({
          started_at = "today",
          owner = "me",
        }),
        pending,
        done("ok"),
      ],
    }
    "#);
}

#[test]
fn param_09() {
    insta::assert_snapshot!(_run(r#"
    type Status: enum {
      pending, in_progress: {started_at: text, owner: text}, done: text
    }
    func main(x: {text, Status}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Text("hello".into()),
        lutra_bin::Value::Enum(
            2,
            Box::new(lutra_bin::Value::Text("ok".into()))
        ),
    ])
    ).1, @r#"
    {
      "hello",
      done("ok"),
    }
    "#);
}

#[test]
fn param_10() {
    insta::assert_snapshot!(_run(r#"
    func main(x: std::Date) -> x
    "#,
    lutra_bin::Value::Prim32(10000)
    ).1, @"@1997-05-19");
}

#[test]
fn param_11() {
    // option enum
    insta::assert_snapshot!(_run(r#"
    type OptInt: enum { none, some: int32 }
    func main(x: [OptInt]) -> x
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Enum(0, Box::new(lutra_bin::Value::Tuple(vec![]))),
        lutra_bin::Value::Enum(1, Box::new(lutra_bin::Value::Prim32(5))),
    ])
    ).1, @r"
    [
      none,
      some(5),
    ]
    ");
}

#[test]
fn tuple_unpacking_00() {
    insta::assert_snapshot!(_run(r#"
    func main() -> {
      4: int16,
      ([{id = 3: int32, title = "Hello world!"}] | std::index(0)),
    }
    "#,
    lutra_bin::Value::unit(),
    ).1, @r#"
    {
      4,
      some({
        id = 3,
        title = "Hello world!",
      }),
    }
    "#);
}

#[test]
fn serialize_00() {
    // Having array in a tuple forces serialization to JSON.
    // Applying an operation of that array then forces deserialization.

    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [2, 5, 4, 3, 1, 2]: [int32]}

    func main() -> (
      get_data().a
      | std::map(func (y: int32) -> -y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      -2,
      -5,
      -4,
      -3,
      -1,
      -2,
    ]
    "#);
}

#[test]
fn serialize_01() {
    // Having array in a tuple forces serialization to JSON.
    // Applying an operation of that array then forces deserialization.

    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [{2: int32, false}, {5, true}, {4, false}]}

    func main() -> (
      get_data().a
      | std::map(func (y: {int32, bool}) -> {-y.0, !y.1})
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        -2,
        true,
      },
      {
        -5,
        false,
      },
      {
        -4,
        true,
      },
    ]
    "#);
}

#[test]
fn serialize_02() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> [[1: int16, 2, 3], [4, 5, 6]]

    func main() -> (
      get_data() | std::map(func (y: [int16]) -> (
        std::index(y, 1)
      ))
    )
    "#, lutra_bin::Value::unit()).1, @"
    [
      some(2),
      some(5),
    ]
    ");
}

#[test]
fn serialize_03() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> [[1: int64, 2, 3], [4, 5, 6]]

    func main() -> (
      get_data()
      | std::map(func (y: [int64]) -> (
        y | std::map(func (z: int64) -> 6-z)
      ))
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      [
        5,
        4,
        3,
      ],
      [
        2,
        1,
        0,
      ],
    ]
    "#);
}

#[test]
fn serialize_04() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [false, true, true]}

    func main() -> (
      get_data().a
      | std::map(func (y: bool) -> !y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      true,
      false,
      false,
    ]
    "#);
}

#[test]
fn serialize_05() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = ["no", "yes", "neither"]}

    func main() -> (
      get_data().a
      | std::map(func (y: text) -> y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      "no",
      "yes",
      "neither",
    ]
    "#);
}

#[test]
fn serialize_06() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      {"hello", [[true]]}.1
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      [
        true,
      ],
    ]
    ");
}

#[test]
fn serialize_07() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      {
        "hello",
        [
          {
            "hello",
            [{1: int32, {1: int32, [5: int32], 2: int16}, 2: int16}]
          }.1
        ]
      }.1
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      [
        {
          1,
          {
            1,
            [
              5,
            ],
            2,
          },
          2,
        },
      ],
    ]
    ");
}

#[test]
fn serialize_08() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      std::index([["hello"]], 0)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    some([
      "hello",
    ])
    "#);
}

#[test]
fn serialize_09() {
    // JsonUnpack(JsonPack(_)) should be optimized away

    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(x: [int8]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Prim8(1),
        lutra_bin::Value::Prim8(2),
        lutra_bin::Value::Prim8(3),
    ]))), @r#"
    SELECT
      'hello'::text AS _0,
      $1::jsonb AS _1
    ---
    {
      "hello",
      x = [
        1,
        2,
        3,
      ],
    }
    "#);
}

#[test]
fn serialize_10() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main() -> {"hello", [1: int8, 2]}
    "#,
    lutra_bin::Value::unit())), @r#"
    SELECT
      'hello'::text AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int2 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              2::int2 AS value
          ) AS r0
      ) AS _1
    ---
    {
      "hello",
      [
        1,
        2,
      ],
    }
    "#);
}

#[test]
fn if_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const en = ["yes", "no"]
    const sl = ["da", "ne"]
    const lang = "sl"

    func main() -> if lang == "en" then en else sl
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r5.value
    FROM
      (
        WITH r0 AS (
          SELECT
            CASE
              WHEN ('sl'::text = 'en'::text) THEN 0::int2
              ELSE 1::int2
            END AS value
        )
        SELECT
          r1.index,
          r1.value
        FROM
          (
            SELECT
              0::int8 AS index,
              'yes'::text AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              'no'::text AS value
          ) AS r1
        WHERE
          (
            (
              SELECT
                r2.value AS value
              FROM
                r0 AS r2
            ) = 0::int2
          )
        UNION
        ALL
        SELECT
          r3.index,
          r3.value
        FROM
          (
            SELECT
              0::int8 AS index,
              'da'::text AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              'ne'::text AS value
          ) AS r3
        WHERE
          (
            (
              SELECT
                r4.value AS value
              FROM
                r0 AS r4
            ) = 1::int2
          )
      ) AS r5
    ORDER BY
      r5.index
    ---
    [
      "da",
      "ne",
    ]
    "#);
}

#[test]
fn match_04() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Animal: enum {
      cat: text,
      dog: enum {collie: text, generic},
    }

    func main() -> (
      [
        .cat("Whiskers"),
        .dog(.collie("Belie")),
        .dog(.generic),
      ]
      | std::map(func (animal: Animal) -> match animal {
        .cat(name) => f"Hello {name}",
        .dog(.generic) => "Who's a good boy?",
        .dog(.collie(name)) => f"Come here {name}",
      })
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      (
        SELECT
          CASE
            WHEN (r1._t = 0::int2) THEN ('Hello '::text || r1._0)
            WHEN (
              (r1._t = 1::int2)
              AND (r1._1_t = 1::int2)
            ) THEN 'Who''s a good boy?'::text
            ELSE ('Come here '::text || r1._1_0)
          END AS value
        FROM
          (
            SELECT
              r0._t AS _t,
              r0._0 AS _0,
              r0._1_t AS _1_t,
              r0._1_0 AS _1_0
          ) AS r1
      ) AS value
    FROM
      (
        SELECT
          0::int8 AS index,
          0::int2 AS _t,
          'Whiskers'::text AS _0,
          NULL::int2 AS _1_t,
          NULL::text AS _1_0
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::int2 AS _t,
          NULL::text AS _0,
          0::int2 AS _1_t,
          'Belie'::text AS _1_0
        UNION
        ALL
        SELECT
          2::int8 AS index,
          1::int2 AS _t,
          NULL::text AS _0,
          1::int2 AS _1_t,
          NULL::text AS _1_0
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      "Hello Whiskers",
      "Come here Belie",
      "Who's a good boy?",
    ]
    "#);
}
#[test]
fn match_05() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const name = "Tom"

    func main() -> match name {
      "world" => "Hello world!",
      n => f"Hello {n}"
    }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      CASE
        WHEN (r0.value = 'world'::text) THEN 'Hello world!'::text
        ELSE ('Hello '::text || r0.value)
      END AS value
    FROM
      (
        SELECT
          'Tom'::text AS value
      ) AS r0
    ---
    "Hello Tom"
    "#);
}

#[test]
fn cmp_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func compare(a: int16, b: int16) -> {
        a == b,
        a != b,
        a < b,
        a > b,
        a <= b,
        a >= b,
    }
    func main() -> (
      [{3, 3}, {3, 5}, {5, 3}]
      | std::map(x -> compare(x.0, x.1))
    )
    "#, lutra_bin::Value::unit())), @"
    SELECT
      r4._0 AS _0,
      r4._1 AS _1,
      r4._2 AS _2,
      r4._3 AS _3,
      r4._4 AS _4,
      r4._5 AS _5
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int2 AS _0,
          3::int2 AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          3::int2 AS _0,
          5::int2 AS _1
        UNION
        ALL
        SELECT
          2::int8 AS index,
          5::int2 AS _0,
          3::int2 AS _1
      ) AS r0,
      LATERAL (
        SELECT
          r0.index AS value
      ) AS r1,
      LATERAL (
        SELECT
          (r3.value = r2.value) AS _0,
          (NOT (r3.value = r2.value)) AS _1,
          (r3.value < r2.value) AS _2,
          (r2.value < r3.value) AS _3,
          (r3.value <= r2.value) AS _4,
          (r2.value <= r3.value) AS _5
        FROM
          (
            SELECT
              r0._1 AS value
          ) AS r2,
          LATERAL (
            SELECT
              r0._0 AS value
          ) AS r3
      ) AS r4
    ORDER BY
      r1.value
    ---
    [
      {
        true,
        false,
        false,
        false,
        true,
        true,
      },
      {
        false,
        true,
        true,
        false,
        true,
        false,
      },
      {
        false,
        true,
        false,
        true,
        false,
        true,
      },
    ]
    ");
}

#[tokio::test(flavor = "current_thread")]
async fn sql_from_00() {
    let mut client = _get_test_db_client().await.unwrap();
    let tran = client.transaction().await.unwrap();
    tran.batch_execute(MOVIES_SETUP).await.unwrap();
    let mut runner = RunnerAsync::new(tran);

    insta::assert_snapshot!(_sql_and_output(_run_on(&mut runner, r#"
    type Movie: {
      id: int32,
      title: text,
      premiere_date: std::Date,
      director_id: enum {none, some: int16},
    }

    func main(): [Movie] -> std::sql::from("movies")
    "#, lutra_bin::Value::unit()).await), @r#"
    SELECT
      id::int4 AS _0,
      title::text AS _1,
      (premiere_date::date - '1970-01-01'::date) AS _2,
      director_id::int2 AS _3
    FROM
      movies
    ---
    [
      {
        id = 1,
        title = "Forrest Gump",
        premiere_date = @1994-04-22,
        director_id = some(3),
      },
      {
        id = 2,
        title = "The Prestige",
        premiere_date = @2006-06-14,
        director_id = none,
      },
    ]
    "#);

    runner.into_inner().rollback().await.unwrap();
}

#[tokio::test(flavor = "current_thread")]
async fn sql_insert_00() {
    let mut client = _get_test_db_client().await.unwrap();
    let tran = client.transaction().await.unwrap();
    tran.batch_execute(MOVIES_SETUP).await.unwrap();
    let mut runner = RunnerAsync::new(tran);

    insta::assert_snapshot!(_sql_and_output(_run_on(&mut runner, r#"
    type Movie: {
      title: text,
      premiere_date: std::Date,
    }
    const two_movies: [Movie] = [
      {title = "Memento", premiere_date = @2000-02-29},
      {title = "Inception", premiere_date = @2010-10-12}
    ]

    func main(): {} -> std::sql::insert(two_movies, "movies")
    "#, lutra_bin::Value::unit()).await), @"
    INSERT INTO
      movies (title, premiere_date)
    SELECT
      r0._0,
      ('1970-01-01'::date + r0._1)
    FROM
      (
        SELECT
          0::int8 AS index,
          'Memento'::text AS _0,
          11016::int4 AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          'Inception'::text AS _0,
          14894::int4 AS _1
      ) AS r0
    ---
    {}
    ");

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    type Movie: {
      id: int32,
      title: text,
      premiere_date: std::Date,
    }
    func main() -> (
      (std::sql::from("movies"): [Movie])
      | std::sort(m -> m.id | std::to_int64)
      | std::map(m -> {m.title, m.premiere_date: std::Date})
    )
    "#, lutra_bin::Value::unit()).await.1, @r#"
    [
      {
        title = "Forrest Gump",
        @1994-04-22,
      },
      {
        title = "The Prestige",
        @2006-06-14,
      },
      {
        title = "Memento",
        @2000-02-29,
      },
      {
        title = "Inception",
        @2010-10-12,
      },
    ]
    "#);
    runner.into_inner().rollback().await.unwrap();
}

#[test]
fn group_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const values: [int64] = [1, 1, 1, 3, 2, 3]

    func main() -> (
      values
      | std::group(x -> x)
      | std::map(this -> {
        value = this.key,
        sum = std::sum(this.values),
      })
    )
    "#, lutra_bin::Value::unit())), @"
    SELECT
      r0.value AS _0,
      COALESCE(SUM(r0.value), 0)::int8 AS _1
    FROM
      (
        SELECT
          0::int8 AS index,
          1::int8 AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::int8 AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          1::int8 AS value
        UNION
        ALL
        SELECT
          3::int8 AS index,
          3::int8 AS value
        UNION
        ALL
        SELECT
          4::int8 AS index,
          2::int8 AS value
        UNION
        ALL
        SELECT
          5::int8 AS index,
          3::int8 AS value
      ) AS r0,
      LATERAL (
        SELECT
          r0.index,
          r0.value
      ) AS r1
    GROUP BY
      r0.value
    ---
    [
      {
        value = 1,
        sum = 3,
      },
      {
        value = 3,
        sum = 6,
      },
      {
        value = 2,
        sum = 2,
      },
    ]
    ");
}

#[test]
fn group_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    import std::(map, group, to_int64, sum)

    const gifts: [{child_id: int32, price: float64}] = []

    func main() -> (
      gifts
      | group(g -> g.child_id)
      | map(
        p -> {
          p.values | map(g -> g.price | to_int64) | sum()
        },
      )
    )
    "#, lutra_bin::Value::unit())), @"
    SELECT
      COALESCE(SUM(r1.value), 0)::int8 AS _0
    FROM
      (
        SELECT
          0 AS index,
          NULL::int4 AS _0,
          NULL::float8 AS _1
        WHERE
          FALSE
      ) AS r0,
      LATERAL (
        SELECT
          r0.index AS index,
          trunc(r0._1)::int8 AS value
      ) AS r1
    GROUP BY
      r0._0
    ---
    []
    ");
}

#[test]
fn opt_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main() -> {
      .some("hello"): enum {none, some: text},
      .none: enum {none, some: text},
      std::option::is_some(.some("hello")),
      std::option::is_none(.some("hello")),
    }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'hello'::text AS _0,
      NULL::text AS _1,
      'hello'::text IS NOT NULL AS _2,
      (NOT 'hello'::text IS NOT NULL) AS _3
    ---
    {
      some("hello"),
      none,
      true,
      false,
    }
    "#);
}

#[test]
fn opt_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type OptText: enum {none, some: text}
    func main() -> (
      [.some("hello"), .none, .some("world")]: [OptText]
      | std::map(x -> match x {
        .some(x) => x,
        .none => "none",
      })
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      (
        SELECT
          CASE
            WHEN r1.value IS NOT NULL THEN r1.value
            ELSE 'none'::text
          END AS value
        FROM
          (
            SELECT
              r0.value AS value
          ) AS r1
      ) AS value
    FROM
      (
        SELECT
          0::int8 AS index,
          'hello'::text AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          NULL::text AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          'world'::text AS value
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      "hello",
      "none",
      "world",
    ]
    "#);
}

#[test]
fn std_sql_raw_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(): [{hello: text, world: bool, x: std::Date}]
    -> std::sql::raw(
      "select 'a' as hello, TRUE as world, '2025-11-14'::date as x"
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      hello::text AS _0,
      world::bool AS _1,
      (x::date - '1970-01-01'::date) AS _2
    FROM
      (
        select
          'a' as hello,
          TRUE as world,
          '2025-11-14'::date as x
      ) AS r0
    ---
    [
      {
        hello = "a",
        world = true,
        x = @2025-11-14,
      },
    ]
    "#);
}

#[test]
fn std_sql_raw_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func sequence(): [int32] -> std::sql::raw("(
      SELECT 2 as value UNION SELECT 3 UNION SELECT 4 ORDER BY value
    )")

    func main() -> sequence() | std::scan(1, func (a, c) -> a * c)
    "#, lutra_bin::Value::unit())), @"
    SELECT
      r7.value
    FROM
      (
        WITH r0 AS (
          SELECT
            (ROW_NUMBER() OVER () -1)::int4 AS index,
            value::int4 AS value
          FROM
            (
              (
                SELECT
                  2 as value
                UNION
                SELECT
                  3
                UNION
                SELECT
                  4
                ORDER BY
                  value
              )
            ) AS r1
        )
        SELECT
          r6.index,
          r6.value
        FROM
          (
            WITH RECURSIVE r2 AS (
              SELECT
                0::int8 AS index,
                1::int4 AS value
              UNION
              ALL
              SELECT
                (r3.index + 1::int8) AS index,
                (r3.value * r5.value) AS value
              FROM
                r2 AS r3,
                LATERAL (
                  SELECT
                    r4.index,
                    r4.value
                  FROM
                    r0 AS r4
                  WHERE
                    (r4.index = r3.index)
                ) AS r5
            )
            SELECT
              index,
              value
            FROM
              r2
          ) AS r6
        WHERE
          (0::int8 < r6.index)
      ) AS r7
    ORDER BY
      r7.index
    ---
    [
      2,
      6,
      24,
    ]
    ");
}

#[test]
fn date_time_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(): {a: std::Date, b: std::Time, c: std::Timestamp}
    -> std::sql::raw(
      "select
        '2025-11-14'::date as a,
        '04:05:06.789'::time as b,
        '2025-11-14T04:05:06.789'::timestamp as c"
    )
    "#, lutra_bin::Value::unit())), @"
    SELECT
      (a::date - '1970-01-01'::date) AS _0,
      (
        EXTRACT(
          EPOCH
          FROM
            b
        ) * 1000000
      )::int8 AS _1,
      (
        EXTRACT(
          EPOCH
          FROM
            c
        ) * 1000000
      )::int8 AS _2
    FROM
      (
        select
          '2025-11-14'::date as a,
          '04:05:06.789'::time as b,
          '2025-11-14T04:05:06.789'::timestamp as c
      ) AS r0
    ---
    {
      a = @2025-11-14,
      b = @04:05:06.789000,
      c = @2025-11-14T04:05:06.789000,
    }
    ");
}

#[tokio::test(flavor = "current_thread")]
async fn date_time_01() {
    // test export pg repr

    // TODO: decide if current behavior of "modulo 24-hours" is what we want

    let client = _get_test_db_client().await.unwrap();
    client
        .execute(
            r#"CREATE TEMPORARY TABLE test(d date, t time, ts timestamp)"#,
            &[],
        )
        .await
        .unwrap();
    let mut runner = RunnerAsync::new(client);

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    func main() -> (
      [
        {@2025-12-29, @16:07:44.12, @2025-12-22T16:07:44.12},
        {@-100-12-29, @-16:07:44.12, @-100-12-29T-16:07:44.12},
        {@10000-12-29, @25:07:44.12, @10000-12-29T25:07:44.12},
      ]: [{d: std::Date, t: std::Time, ts: std::Timestamp}]
      | std::sql::insert("test")
    )
    "#, lutra_bin::Value::unit()).await.1, @"{}");

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    func main() -> (
      std::sql::from("test"): [{d: std::Date, t: std::Time, ts: std::Timestamp}]
    )
    "#, lutra_bin::Value::unit()).await.1, @"
    [
      {
        d = @2025-12-29,
        t = @16:07:44.120000,
        ts = @2025-12-22T16:07:44.120000,
      },
      {
        d = @-0100-12-29,
        t = @07:52:15.880000,
        ts = @-0100-12-28T07:52:15.880000,
      },
      {
        d = @+10000-12-29,
        t = @01:07:44.120000,
        ts = @+10000-12-30T01:07:44.120000,
      },
    ]
    ");
}

#[test]
fn decimal_00() {
    // import pg repr for std::Decimal

    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(): {a: std::Decimal}
    -> std::sql::raw(
      "select
        '123123.05'::decimal(10, 2) as a"
    )
    "#, lutra_bin::Value::unit())), @"
    SELECT
      (a * 100)::int8 AS _0
    FROM
      (
        select
          '123123.05'::decimal(10, 2) as a
      ) AS r0
    ---
    {
      a = 123123.05,
    }
    ");
}

#[tokio::test(flavor = "current_thread")]
async fn decimal_01() {
    // export pg repr for std::Decimal

    // TODO: decide if current behavior of "modulo 24-hours" is what we want

    let client = _get_test_db_client().await.unwrap();
    client
        .execute(
            r#"CREATE TEMPORARY TABLE test(a decimal(10, 2), b decimal(19, 3))"#,
            &[],
        )
        .await
        .unwrap();
    let mut runner = RunnerAsync::new(client);

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    func main() -> (
      [
        {1234567.89, 1234567.89},
        {0.09, 0.9},
        {1, -987643210987654.32},
        {2, 987643210987654.32},
      ]: [{a: std::Decimal, b: std::Decimal}]
      | std::sql::insert("test")
    )
    "#, lutra_bin::Value::unit()).await.1, @"{}");

    insta::assert_snapshot!(_run_on(&mut runner, r#"
    func main() -> (
      std::sql::from("test"): [{a: std::Decimal, b: std::Decimal}]
    )
    "#, lutra_bin::Value::unit()).await.1, @"
    [
      {
        a = 1234567.89,
        b = 1234567.89,
      },
      {
        a = 0.09,
        b = 0.90,
      },
      {
        a = 1.00,
        b = -987643210987654.32,
      },
      {
        a = 2.00,
        b = 987643210987654.32,
      },
    ]
    ");
}

#[tokio::test(flavor = "current_thread")]
async fn pull_interface() {
    let mut client = _get_test_db_client().await.unwrap();
    let tran = client.transaction().await.unwrap();
    tran.batch_execute(MOVIES_SETUP).await.unwrap();
    let runner = RunnerAsync::new(tran);

    insta::assert_snapshot!(runner.get_interface().await.unwrap(), @r#"
    ## Row of table persons
    type Person: {id: int32, first_name: text, last_name: text}
    ## Read from table persons
    func from_persons(): [Person] -> std::sql::from("persons")
    ## Write into table persons
    func insert_persons(values: [Person]) -> std::sql::insert(values, "persons")
    ## Lookup in persons by index persons_pkey
    func from_persons_by_id(id: int32): enum {none, some: Person} -> (
      from_persons() | std::find(x -> x.id == id)
    )

    ## Row of table movies
    type Movie: {id: int32, title: text, premiere_date: std::Date, director_id: int16}
    ## Read from table movies
    func from_movies(): [Movie] -> std::sql::from("movies")
    ## Write into table movies
    func insert_movies(values: [Movie]) -> std::sql::insert(values, "movies")
    ## Lookup in movies by index movies_pkey
    func from_movies_by_id(id: int32): enum {none, some: Movie} -> (
      from_movies() | std::find(x -> x.id == id)
    )
    ## Lookup in movies by index movies_premiere_date_idx
    func from_movies_by_premiere_date(premiere_date: int32): [Movie] -> (
      from_movies() | std::filter(x -> x.premiere_date == premiere_date)
    )

    ## Row of table movie_actors
    type MovieActor: {source: int32, target: int32, role: text}
    ## Read from table movie_actors
    func from_movie_actors(): [MovieActor] -> std::sql::from("movie_actors")
    ## Write into table movie_actors
    func insert_movie_actors(values: [MovieActor]) -> std::sql::insert(values, "movie_actors")

    module another {

      ## Row of table days
      type Day: {id: int32, name: text}
      ## Read from table days
      func from_days(): [Day] -> std::sql::from("days")
      ## Write into table days
      func insert_days(values: [Day]) -> std::sql::insert(values, "days")
      ## Lookup in days by index days_pkey
      func from_days_by_id(id: int32): enum {none, some: Day} -> (
        from_days() | std::find(x -> x.id == id)
      )

      ## Row of table proj/days
      type Proj/day: {id: int32, name: text}
      ## Read from table proj/days
      func from_proj/days(): [Proj/day] -> std::sql::from("proj/days")
      ## Write into table proj/days
      func insert_proj/days(values: [Proj/day]) -> std::sql::insert(values, "proj/days")
      ## Lookup in proj/days by index proj/days_pkey
      func from_proj/days_by_id(id: int32): enum {none, some: Proj/day} -> (
        from_proj/days() | std::find(x -> x.id == id)
      )
    }
    "#);
}

/// Tests round trip of types:
/// 0. send as param <--> retrieve as relational result
/// 1. code gen SQL and apply to postgres <--> pull interface from postgres
/// 2. write to table <--> read from table
async fn _type_round_trip(ty: &str, ty_reflected: &str, value: lutra_bin::Value) {
    crate::init_logger();

    // --- [ 0 ] ---

    let client = _get_test_db_client().await.unwrap();
    let runner = RunnerAsync::new(client);

    // compile
    let source = SourceTree::single("".into(), format!("func main(x: {ty}) -> x"));
    let project = lutra_compiler::check(source, Default::default()).unwrap();
    let (program, p_ty) =
        lutra_compiler::compile(&project, "main", None, ProgramFormat::SqlPg).unwrap();

    // execute
    let input = value.encode(&p_ty.input, &p_ty.defs).unwrap();
    let p = runner.prepare(program).await.unwrap();
    let output = runner.execute(&p, &input).await.unwrap();

    similar_asserts::assert_eq!(
        lutra_bin::print_source(&input, &p_ty.input, &p_ty.defs).unwrap(),
        lutra_bin::print_source(&output, &p_ty.output, &p_ty.defs).unwrap(),
    );

    let mut client = runner.into_inner();

    // --- [ 1 ] ---

    // compile
    let ty_def = format!("type Row: {ty}");
    let source = SourceTree::single("".into(), ty_def.to_string());
    let project = match lutra_compiler::check(source, Default::default()) {
        Ok(p) => p,
        Err(e) => panic!("check: {e}"),
    };

    // code gen SQL
    let code_dir = temp_dir::TempDir::new().unwrap();
    let code_path = code_dir.path().join("schema.sql");
    lutra_codegen::generate(
        &project,
        lutra_codegen::Target::Sql,
        &code_path,
        Default::default(),
    )
    .unwrap();
    let sql_schema = std::fs::read_to_string(&code_path).unwrap();
    tracing::debug!("sql_schema:\n{sql_schema}");

    // apply to PostgreSQL
    let tran = client.transaction().await.unwrap();
    tran.batch_execute(&sql_schema).await.unwrap();

    // pull
    let runner = RunnerAsync::new(tran);
    let interface = runner.get_interface().await.unwrap();
    tracing::debug!("interface:\n{interface}");

    // compare with original type
    let interface_ty_def = interface.lines().find(|l| l.starts_with("type ")).unwrap();
    let interface_ty = interface_ty_def.strip_prefix("type Row: ").unwrap();
    similar_asserts::assert_eq!(ty_reflected, interface_ty);

    // --- [ 2 ] ---

    let source = SourceTree::single(
        "".into(),
        format!(
            r#"func insert_row(x: {ty}) -> std::sql::insert([x], "rows")
               func from_row() -> (
                 std::sql::from("rows"): [{ty}] | std::index(0) | std::option::or_default()
               )"#
        ),
    );
    let project = match lutra_compiler::check(source, Default::default()) {
        Ok(p) => p,
        Err(e) => panic!("check: {e}"),
    };

    // insert
    let (insert, insert_ty) =
        lutra_compiler::compile(&project, "x -> insert_row(x)", None, ProgramFormat::SqlPg)
            .unwrap_or_else(|e| panic!("{e}"));
    let input = value.encode(&insert_ty.input, &insert_ty.defs).unwrap();
    let p = runner.prepare(insert).await.unwrap();
    runner.execute(&p, &input).await.unwrap();

    // from
    let (from, from_ty) =
        lutra_compiler::compile(&project, "from_row", None, ProgramFormat::SqlPg).unwrap();
    let p = runner.prepare(from).await.unwrap();
    let output = runner.execute(&p, &[]).await.unwrap();

    // compare
    similar_asserts::assert_eq!(
        lutra_bin::print_source(&input, &insert_ty.input, &insert_ty.defs).unwrap(),
        lutra_bin::print_source(&output, &from_ty.output, &from_ty.defs).unwrap(),
    );

    runner.into_inner().rollback().await.unwrap();
}

#[tokio::test(flavor = "current_thread")]
async fn type_round_trip_00() {
    // basic tuple

    _type_round_trip(
        "{id: int32, is_online: bool}",
        "{id: int32, is_online: bool}",
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(10),
            lutra_bin::Value::Prim8(1),
        ]),
    )
    .await;
}

#[tokio::test(flavor = "current_thread")]
async fn type_round_trip_01() {
    // nested tuple

    _type_round_trip(
        "{id: int32, address: {street: text, number: int16}}",
        "{id: int32, address: {street: text, number: int16}}",
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(10),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Text("Grand Ave".into()),
                lutra_bin::Value::Prim16(22),
            ]),
        ]),
    )
    .await;
}

#[tokio::test(flavor = "current_thread")]
async fn type_round_trip_02() {
    // date, time, timestamp

    _type_round_trip(
        "{d: std::Date, t: std::Time, ts: std::Timestamp}",
        "{d: std::Date, t: std::Time, ts: std::Timestamp}",
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Prim32(0),
            lutra_bin::Value::Prim64(0),
            lutra_bin::Value::Prim64(0),
        ]),
    )
    .await;
}

#[tokio::test(flavor = "current_thread")]
async fn type_round_trip_03() {
    // enum

    _type_round_trip(
        "{status: enum {pending, in_progress: int16, done: text}}",
        // enums get reflected as:
        // - tag column of type text
        // - inner fields, but optional and without unit fields
        "{status: text, status: {in_progress: int16, done: text}}",
        lutra_bin::Value::Tuple(vec![lutra_bin::Value::Enum(
            1,
            Box::new(lutra_bin::Value::Prim16(22)),
        )]),
    )
    .await;
}
