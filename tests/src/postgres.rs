use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::{env, sync, time};

use lutra_compiler::{ProgramFormat, SourceTree};
use postgres::GenericClient;

use crate::POSTGRES_URL_SHARED;

#[track_caller]
pub fn _run(source: &str, input: lutra_bin::Value) -> (String, String) {
    let mut client = postgres::Client::connect(POSTGRES_URL_SHARED, postgres::NoTls).unwrap();
    let mut tran = client.transaction().unwrap();
    _run_on(&mut tran, source, input)
}

#[track_caller]
pub fn _run_on(
    client: &mut impl GenericClient,
    source: &str,
    input: lutra_bin::Value,
) -> (String, String) {
    crate::init_logger();

    // compile
    let source = SourceTree::single("".into(), source.to_string());
    let project = match lutra_compiler::check(source, Default::default()) {
        Ok(p) => p,
        Err(e) => panic!("{e}"),
    };

    // compile to sql
    let (program, ty) =
        lutra_compiler::compile(&project, "main", None, ProgramFormat::SqlPg).unwrap();
    let program = program.as_sql_pg().unwrap();

    // format sql
    let options = sqlformat::FormatOptions::default();
    let formatted_sql = sqlformat::format(&program.sql, &sqlformat::QueryParams::None, &options);

    let input = input.encode(&ty.input, &ty.defs).unwrap();

    // execute
    let rel_data = lutra_runner_postgres::execute(client, program, &input).unwrap();

    // decode and print source
    let output = lutra_bin::Value::decode(&rel_data, &ty.output, &ty.defs).unwrap();
    let output = output.print_source(&ty.output, &ty.defs).unwrap();

    (formatted_sql, output)
}

pub fn _sql_and_output((sql, output): (String, String)) -> String {
    format!("{sql}\n---\n{output}")
}

static RUN_ID: sync::LazyLock<u64> = sync::LazyLock::new(|| {
    let mut h = std::hash::DefaultHasher::new();
    if let Ok(run_id) = env::var("NEXTEST_RUN_ID") {
        run_id.hash(&mut h);
    } else {
        time::SystemTime::now().hash(&mut h);
    }
    h.finish()
});

pub fn _get_test_db_client() -> Result<postgres::Client, postgres::Error> {
    let run_id = *RUN_ID as i64;
    let db_name = format!("l-test-{run_id:016x}");

    let config_shared = POSTGRES_URL_SHARED.parse::<postgres::Config>()?;
    let mut config_test = config_shared.clone();
    config_test.dbname(&db_name);

    let mut client_main = config_shared.connect(postgres::NoTls)?;
    client_main.execute("SELECT pg_advisory_lock($1)", &[&run_id])?;

    let databases: HashSet<String> = client_main
        .query("SELECT datname FROM pg_database", &[])?
        .iter()
        .map(|r| r.get::<_, String>(0))
        .filter(|d| d.starts_with("l-test-"))
        .collect();

    if !databases.contains(&db_name) {
        // cleanup old test dbs
        for d in databases {
            client_main.execute(&format!("DROP DATABASE \"{d}\""), &[])?;
        }

        // create test db
        client_main.execute(&format!("CREATE DATABASE \"{db_name}\""), &[])?;

        let mut client_test = config_test.connect(postgres::NoTls)?;
        client_test.batch_execute(MOVIES_SETUP)?;

        drop(client_main); // this will release the lock
        Ok(client_test)
    } else {
        drop(client_main);

        config_test.connect(postgres::NoTls)
    }
}

const MOVIES_SETUP: &str = r#"
CREATE TABLE persons (
    id int4 primary key generated by default as identity,
    first_name text not null,
    last_name text
);

CREATE TABLE movies (
    id int4 primary key generated by default as identity,
    title text not null,
    release_year int2,
    director_id int4 references persons(id)
);
CREATE INDEX ON movies (release_year);

CREATE TABLE movie_actors (
    source int4 references movies(id),
    target int4 references persons(id),
    role text
);

CREATE SCHEMA another;
CREATE TABLE another.days (
    id int4 primary key generated by default as identity,
    name text
);
CREATE TABLE another."proj/days" (
    id int4 primary key generated by default as identity,
    name text
);

INSERT INTO persons (first_name, last_name) VALUES ('Tom', 'Hanks');
INSERT INTO persons (first_name) VALUES ('Robin');
INSERT INTO persons (first_name, last_name) VALUES ('Steven', 'Spielberg');

INSERT INTO movies (title, release_year, director_id)
  SELECT
    'Forrest Gump',
    1994,
    (SELECT id FROM persons WHERE first_name = 'Steven');
INSERT INTO movie_actors (source, target)
  SELECT
    (SELECT id FROM movies WHERE title = 'Forrest Gump'),
    p.id
  FROM (
    SELECT id FROM persons WHERE first_name in ('Tom', 'Robin')
  ) p;
INSERT INTO movies (title, release_year, director_id)
  SELECT
    'The Prestige',
    2006,
    NULL;

INSERT INTO another.days (name) VALUES ('Monday'), ('Tuesday');
INSERT INTO another."proj/days" (name) VALUES ('Wednesday'), ('Thursday'), ('Friday');
"#;

#[test]
fn prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = 3: int16
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      3::int2 AS value
    ---
    3
    ");
}

#[test]
fn tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {3: int16, false}
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      3::int2 AS _0,
      FALSE AS _1
    ---
    {
      3,
      false,
    }
    ");
}

#[test]
fn array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [3, 6, 12]: [int16]
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r3.value
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int2 AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          6::int2 AS value
        UNION
        ALL
        SELECT
          2::int8 AS index,
          12::int2 AS value
      ) AS r3
    ORDER BY
      r3.index
    ---
    [
      3,
      6,
      12,
    ]
    ");
}

#[test]
fn array_empty() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = []: [bool]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r0.value
    FROM
      (
        SELECT
          0 AS index,
          NULL::bool AS value
        WHERE
          false
      ) AS r0
    ORDER BY
      r0.index
    ---
    []
    "#);
}

#[test]
fn array_enum() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          Pending, InProgress: {started_at: text, owner: text}, Done: text
        }
        const main = [Status::Pending, Status::InProgress({"today", "me"}), Status::Done("ok")]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r3._t,
      r3._1_0,
      r3._1_1,
      r3._2
    FROM
      (
        SELECT
          0::int8 AS index,
          0::"char" AS _t,
          NULL::text AS _1_0,
          NULL::text AS _1_1,
          NULL::text AS _2
        UNION
        ALL
        SELECT
          1::int8 AS index,
          1::"char" AS _t,
          'today' AS _1_0,
          'me' AS _1_1,
          NULL::text AS _2
        UNION
        ALL
        SELECT
          2::int8 AS index,
          2::"char" AS _t,
          NULL::text AS _1_0,
          NULL::text AS _1_1,
          'ok' AS _2
      ) AS r3
    ORDER BY
      r3.index
    ---
    [
      Pending,
      InProgress({
        started_at = "today",
        owner = "me",
      }),
      Done("ok"),
    ]
    "#);
}

#[test]
fn enum_array() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          Pending, InProgress: [text], Done: text
        }
        const main = {
          "statuses:",
          [Status::Pending, Status::InProgress(["today", "me"]), Status::Done("ok")],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'statuses:' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                ASCII(r6._t)
                WHEN 0 THEN json_build_object('0', jsonb_build_array())
                WHEN 1 THEN json_build_object('1', r6._1)
                WHEN 2 THEN json_build_object('2', r6._2)
              END
              ORDER BY
                r6.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::"char" AS _t,
              NULL::jsonb AS _1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::"char" AS _t,
              (
                SELECT
                  COALESCE(
                    jsonb_agg(
                      r3.value
                      ORDER BY
                        r3.index
                    ),
                    '[]'::jsonb
                  ) AS value
                FROM
                  (
                    SELECT
                      0::int8 AS index,
                      'today' AS value
                    UNION
                    ALL
                    SELECT
                      1::int8 AS index,
                      'me' AS value
                  ) AS r3
              ) AS _1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              2::int8 AS index,
              2::"char" AS _t,
              NULL::jsonb AS _1,
              'ok' AS _2
          ) AS r6
      ) AS _1
    ---
    {
      "statuses:",
      [
        Pending,
        InProgress([
          "today",
          "me",
        ]),
        Done("ok"),
      ],
    }
    "#);
}

#[test]
fn tuple_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {3: int16, {false, true, {"hello"}, 4: int32}}
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      3::int2 AS _0,
      FALSE AS _1_0,
      TRUE AS _1_1,
      'hello' AS _1_2_0,
      4::int4 AS _1_3
    ---
    {
      3,
      {
        false,
        true,
        {
          "hello",
        },
        4,
      },
    }
    "#);
}

#[test]
fn tuple_array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {true, [1, 2, 3]: [int64], [4]: [int32], false}
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      TRUE AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r3.value
              ORDER BY
                r3.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int8 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              2::int8 AS value
            UNION
            ALL
            SELECT
              2::int8 AS index,
              3::int8 AS value
          ) AS r3
      ) AS _1,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r5.value
              ORDER BY
                r5.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              4::int4 AS value
          ) AS r5
      ) AS _2,
      FALSE AS _3
    ---
    {
      true,
      [
        1,
        2,
        3,
      ],
      [
        4,
      ],
      false,
    }
    ");
}

#[test]
fn tuple_array_enum() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        type Status: enum {
          Pending, InProgress: {started_at: text, owner: text}, Done: text
        }
        const main = {
          "statuses:",
          [Status::Pending, Status::InProgress({"today", "me"}), Status::Done("ok")],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'statuses:' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              CASE
                ASCII(r3._t)
                WHEN 0 THEN json_build_object('0', jsonb_build_array())
                WHEN 1 THEN json_build_object('1', jsonb_build_array(r3._1_0, r3._1_1))
                WHEN 2 THEN json_build_object('2', r3._2)
              END
              ORDER BY
                r3.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::"char" AS _t,
              NULL::text AS _1_0,
              NULL::text AS _1_1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::"char" AS _t,
              'today' AS _1_0,
              'me' AS _1_1,
              NULL::text AS _2
            UNION
            ALL
            SELECT
              2::int8 AS index,
              2::"char" AS _t,
              NULL::text AS _1_0,
              NULL::text AS _1_1,
              'ok' AS _2
          ) AS r3
      ) AS _1
    ---
    {
      "statuses:",
      [
        Pending,
        InProgress({
          started_at = "today",
          owner = "me",
        }),
        Done("ok"),
      ],
    }
    "#);
}

#[test]
fn tuple_array_empty() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {true, []: [int64], false}
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      TRUE AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              r0.value
              ORDER BY
                r0.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0 AS index,
              NULL::int8 AS value
            WHERE
              false
          ) AS r0
      ) AS _1,
      FALSE AS _2
    ---
    {
      true,
      [],
      false,
    }
    ");
}

#[test]
fn array_array_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [[1, 2, 3], [4, 5]]: [[int64]]
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r9.value
    FROM
      (
        SELECT
          0::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r3.value
                  ORDER BY
                    r3.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  1::int8 AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  2::int8 AS value
                UNION
                ALL
                SELECT
                  2::int8 AS index,
                  3::int8 AS value
              ) AS r3
          ) AS value
        UNION
        ALL
        SELECT
          1::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r7.value
                  ORDER BY
                    r7.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  4::int8 AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  5::int8 AS value
              ) AS r7
          ) AS value
      ) AS r9
    ORDER BY
      r9.index
    ---
    [
      [
        1,
        2,
        3,
      ],
      [
        4,
        5,
      ],
    ]
    ");
}

#[test]
fn array_array_array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [[[{1: int32, "hello", 2: int16}]]]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r5.value
    FROM
      (
        SELECT
          0::int8 AS index,
          (
            SELECT
              COALESCE(
                jsonb_agg(
                  r3.value
                  ORDER BY
                    r3.index
                ),
                '[]'::jsonb
              ) AS value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  (
                    SELECT
                      COALESCE(
                        jsonb_agg(
                          jsonb_build_array(r1._0, r1._1, r1._2)
                          ORDER BY
                            r1.index
                        ),
                        '[]'::jsonb
                      ) AS value
                    FROM
                      (
                        SELECT
                          0::int8 AS index,
                          1::int4 AS _0,
                          'hello' AS _1,
                          2::int2 AS _2
                      ) AS r1
                  ) AS value
              ) AS r3
          ) AS value
      ) AS r5
    ORDER BY
      r5.index
    ---
    [
      [
        [
          {
            1,
            "hello",
            2,
          },
        ],
      ],
    ]
    "#);
}

#[test]
fn tuple_array_tuple_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main =
          {
            1: int32,
            [
              {
                1: int32,
                {
                  1: int32, true, 2: int16
                },
                2: int16
              }
            ],
            2: int16
          }
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      1::int4 AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              jsonb_build_array(
                r1._0,
                jsonb_build_array(r1._1_0, r1._1_1, r1._1_2),
                r1._2
              )
              ORDER BY
                r1.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int4 AS _0,
              1::int4 AS _1_0,
              TRUE AS _1_1,
              2::int2 AS _1_2,
              2::int2 AS _2
          ) AS r1
      ) AS _1,
      2::int2 AS _2
    ---
    {
      1,
      [
        {
          1,
          {
            1,
            true,
            2,
          },
          2,
        },
      ],
      2,
    }
    ");
}

#[test]
fn array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = [{3: int64, false}, {6, true}, {12, false}]
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r3._0,
      r3._1
    FROM
      (
        SELECT
          0::int8 AS index,
          3::int8 AS _0,
          FALSE AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          6::int8 AS _0,
          TRUE AS _1
        UNION
        ALL
        SELECT
          2::int8 AS index,
          12::int8 AS _0,
          FALSE AS _1
      ) AS r3
    ORDER BY
      r3.index
    ---
    [
      {
        3,
        false,
      },
      {
        6,
        true,
      },
      {
        12,
        false,
      },
    ]
    "#);
}

#[test]
fn tuple_array_tuple_prim() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
        const main = {
            "hello",
            [{3: int16, false}, {6, true}, {12, false}],
        }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'hello' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              jsonb_build_array(r3._0, r3._1)
              ORDER BY
                r3.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              3::int2 AS _0,
              FALSE AS _1
            UNION
            ALL
            SELECT
              1::int8 AS index,
              6::int2 AS _0,
              TRUE AS _1
            UNION
            ALL
            SELECT
              2::int8 AS index,
              12::int2 AS _0,
              FALSE AS _1
          ) AS r3
      ) AS _1
    ---
    {
      "hello",
      [
        {
          3,
          false,
        },
        {
          6,
          true,
        },
        {
          12,
          false,
        },
      ],
    }
    "#);
}

#[test]
fn param_00() {
    insta::assert_snapshot!(_run(r#"
    func main(x: int64) -> x + 1
    "#,
    lutra_bin::Value::Int64(3)
    ).1, @"4");
}

#[test]
fn param_01() {
    insta::assert_snapshot!(_run(r#"
    func main(x: int64, y: text) -> {y, x}
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Int64(3),
        lutra_bin::Value::Text("hello".into())
    ])
    ).1, @r#"
    {
      "hello",
      3,
    }
    "#);
}

#[test]
fn param_02() {
    insta::assert_snapshot!(_run(r#"
    func main(x: {int64, {text, bool}, int32}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Int64(3),
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Text("hello".into()),
            lutra_bin::Value::Bool(true),
        ]),
        lutra_bin::Value::Int32(5),
    ])
    ).1, @r#"
    {
      3,
      {
        "hello",
        true,
      },
      5,
    }
    "#);
}

#[test]
fn param_03() {
    insta::assert_snapshot!(_run(r#"
    func main(x: {int64, [text], int32}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Int64(3),
        lutra_bin::Value::Array(vec![
            lutra_bin::Value::Text("hello".into()),
            lutra_bin::Value::Text("world".into()),
        ]),
        lutra_bin::Value::Int32(5),
    ])
    ).1, @r#"
    {
      3,
      [
        "hello",
        "world",
      ],
      5,
    }
    "#);
}

#[test]
fn param_04() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int64, text}]) -> std::index(x, 1)
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Int64(5),
            lutra_bin::Value::Text("hello".into()),
        ]),
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Int64(7),
            lutra_bin::Value::Text("world".into()),
        ]),
    ])
    ).1, @r#"
    {
      7,
      "world",
    }
    "#);
}

#[test]
fn param_05() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int32, {int32, int16}, int16}]) -> x
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Int32(5),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Int32(7),
                lutra_bin::Value::Int16(7),
            ]),
            lutra_bin::Value::Int16(1212),
        ])
    ])
    ).1, @r"
    [
      {
        5,
        {
          7,
          7,
        },
        1212,
      },
    ]
    ");
}

#[test]
fn param_06() {
    insta::assert_snapshot!(_run(r#"
    func main(x: [{int32, {int32, int16}, int16}]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Int32(5),
            lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Int32(7),
                lutra_bin::Value::Int16(7),
            ]),
            lutra_bin::Value::Int16(1212),
        ])
    ])
    ).1, @r#"
    {
      "hello",
      [
        {
          5,
          {
            7,
            7,
          },
          1212,
        },
      ],
    }
    "#);
}

#[test]
fn param_07() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Status: enum {
      Pending, InProgress: {started_at: text, owner: text}, Done: text
    }
    func main(x: Status) -> {"hello", x}
    "#,
    lutra_bin::Value::Enum(
        1,
        Box::new(lutra_bin::Value::Tuple(vec![
            lutra_bin::Value::Text("today".into()),
            lutra_bin::Value::Text("me".into())
        ]))
    )
    )), @r#"
    SELECT
      'hello' AS _0,
      $1::"char" AS _1_t,
      $2::text AS _1_1_0,
      $3::text AS _1_1_1,
      $4::text AS _1_2
    ---
    {
      "hello",
      InProgress({
        started_at = "today",
        owner = "me",
      }),
    }
    "#);
}

#[test]
fn param_08() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Status: enum {
      Pending, InProgress: {started_at: text, owner: text}, Done: text
    }
    func main(x: [Status]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Enum(
            1,
            Box::new(lutra_bin::Value::Tuple(vec![
                lutra_bin::Value::Text("today".into()),
                lutra_bin::Value::Text("me".into())
            ]))
        ),
        lutra_bin::Value::Enum(
            0,
            Box::new(lutra_bin::Value::Tuple(vec![]))
        ),
        lutra_bin::Value::Enum(
            2,
            Box::new(lutra_bin::Value::Text("ok".into()))
        ),
    ])
    )), @r#"
    SELECT
      'hello' AS _0,
      $1::jsonb AS _1
    ---
    {
      "hello",
      [
        InProgress({
          started_at = "today",
          owner = "me",
        }),
        Pending,
        Done("ok"),
      ],
    }
    "#);
}

#[test]
fn param_09() {
    insta::assert_snapshot!(_run(r#"
    type Status: enum {
      Pending, InProgress: {started_at: text, owner: text}, Done: text
    }
    func main(x: {text, Status}) -> x
    "#,
    lutra_bin::Value::Tuple(vec![
        lutra_bin::Value::Text("hello".into()),
        lutra_bin::Value::Enum(
            2,
            Box::new(lutra_bin::Value::Text("ok".into()))
        ),
    ])
    ).1, @r#"
    {
      "hello",
      Done("ok"),
    }
    "#);
}

#[test]
fn tuple_unpacking_00() {
    insta::assert_snapshot!(_run(r#"
    func main() -> {
      4: int16,
      ([{id = 3: int32, title = "Hello world!"}] | std::index(0)),
    }
    "#,
    lutra_bin::Value::unit(),
    ).1, @r#"
    {
      4,
      {
        id = 3,
        title = "Hello world!",
      },
    }
    "#);
}

#[test]
fn json_pack_00() {
    // Having array in a tuple forces it to be packed to JSON.
    // Applying an operation of that array then forces it to unpack.

    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [2, 5, 4, 3, 1, 2]: [int32]}

    func main() -> (
      get_data().a
      | std::map(func (y: int32) -> -y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      -2,
      -5,
      -4,
      -3,
      -1,
      -2,
    ]
    "#);
}

#[test]
fn json_pack_01() {
    // Having array in a tuple forces it to be packed to JSON.
    // Applying an operation of that array then forces it to unpack.

    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [{2: int32, false}, {5, true}, {4, false}]}

    func main() -> (
      get_data().a
      | std::map(func (y: {int32, bool}) -> {-y.0, !y.1})
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        -2,
        true,
      },
      {
        -5,
        false,
      },
      {
        -4,
        true,
      },
    ]
    "#);
}

#[test]
fn json_pack_02() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> [[1: int16, 2, 3], [4, 5, 6]]

    func main() -> (
      get_data() | std::map(func (y: [int16]) -> (
        std::index(y, 1)
      ))
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      2,
      5,
    ]
    "#);
}

#[test]
fn json_pack_03() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> [[1: int64, 2, 3], [4, 5, 6]]

    func main() -> (
      get_data()
      | std::map(func (y: [int64]) -> (
        y | std::map(func (z: int64) -> 6-z)
      ))
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      [
        5,
        4,
        3,
      ],
      [
        2,
        1,
        0,
      ],
    ]
    "#);
}

#[test]
fn json_pack_04() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = [false, true, true]}

    func main() -> (
      get_data().a
      | std::map(func (y: bool) -> !y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      true,
      false,
      false,
    ]
    "#);
}

#[test]
fn json_pack_05() {
    insta::assert_snapshot!(_run(r#"
    func get_data() -> {a = ["no", "yes", "neither"]}

    func main() -> (
      get_data().a
      | std::map(func (y: text) -> y)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      "no",
      "yes",
      "neither",
    ]
    "#);
}

#[test]
fn json_pack_06() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      {"hello", [[true]]}.1
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      [
        true,
      ],
    ]
    ");
}

#[test]
fn json_pack_07() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      {
        "hello",
        [
          {
            "hello",
            [{1: int32, {1: int32, [5: int32], 2: int16}, 2: int16}]
          }.1
        ]
      }.1
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      [
        {
          1,
          {
            1,
            [
              5,
            ],
            2,
          },
          2,
        },
      ],
    ]
    ");
}

#[test]
fn json_pack_08() {
    insta::assert_snapshot!(_run(r#"
    func main() -> (
      std::index([["hello"]], 0)
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      "hello",
    ]
    "#);
}

#[test]
fn json_pack_09() {
    // JsonUnpack(JsonPack(_)) should be optimized away

    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main(x: [int8]) -> {"hello", x}
    "#,
    lutra_bin::Value::Array(vec![
        lutra_bin::Value::Int8(1),
        lutra_bin::Value::Int8(2),
        lutra_bin::Value::Int8(3),
    ]))), @r#"
    SELECT
      'hello' AS _0,
      $1::jsonb AS _1
    ---
    {
      "hello",
      [
        1,
        2,
        3,
      ],
    }
    "#);
}

#[test]
fn json_pack_10() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    func main() -> {"hello", [1: int8, 2]}
    "#,
    lutra_bin::Value::unit())), @r#"
    SELECT
      'hello' AS _0,
      (
        SELECT
          COALESCE(
            jsonb_agg(
              ASCII(r2.value)
              ORDER BY
                r2.index
            ),
            '[]'::jsonb
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              1::"char" AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              2::"char" AS value
          ) AS r2
      ) AS _1
    ---
    {
      "hello",
      [
        1,
        2,
      ],
    }
    "#);
}

#[test]
fn if_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const en = ["yes", "no"]
    const sl = ["da", "ne"]
    const lang = "sl"

    func main() -> if lang == "en" then en else sl
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r14.value
    FROM
      (
        WITH r0 AS (
          SELECT
            CASE
              WHEN ('sl' = 'en') THEN 0::int2
              ELSE 1::int2
            END AS value
        )
        SELECT
          r13.index,
          r13.value
        FROM
          (
            SELECT
              r3.index,
              r3.value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  'yes' AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  'no' AS value
              ) AS r3,
              LATERAL (
                SELECT
                  r5.value AS value
                FROM
                  r0 AS r5
              ) AS r6
            WHERE
              (r6.value = 0::int2)
            UNION
            ALL
            SELECT
              r9.index,
              r9.value
            FROM
              (
                SELECT
                  0::int8 AS index,
                  'da' AS value
                UNION
                ALL
                SELECT
                  1::int8 AS index,
                  'ne' AS value
              ) AS r9,
              LATERAL (
                SELECT
                  r11.value AS value
                FROM
                  r0 AS r11
              ) AS r12
            WHERE
              (r12.value = 1::int2)
          ) AS r13
      ) AS r14
    ORDER BY
      r14.index
    ---
    [
      "da",
      "ne",
    ]
    "#);
}

#[test]
fn match_04() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type Animal: enum {
      Cat: text,
      Dog: enum {Collie: text, Generic},
    }

    func main() -> (
      [
        Animal::Cat("Whiskers"),
        Animal::Dog(Animal::Dog::Collie("Belie")),
        Animal::Dog(Animal::Dog::Generic),
      ]
      | std::map(func (animal: Animal) -> match animal {
        .Cat(name) => f"Hello {name}",
        .Dog(.Generic) => "Who's a good boy?",
        .Dog(.Collie(name)) => f"Come here {name}",
      })
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r12.value
    FROM
      (
        SELECT
          r3.index AS index,
          (
            SELECT
              CASE
                WHEN (r5._t = 0::"char") THEN ('Hello ' || r5._0)
                WHEN (
                  (r5._t = 1::"char")
                  AND (r5._1_t = 1::"char")
                ) THEN 'Who''s a good boy?'
                ELSE ('Come here ' || r5._1_0)
              END AS value
            FROM
              (
                SELECT
                  r3._t AS _t,
                  r3._0 AS _0,
                  r3._1_t AS _1_t,
                  r3._1_0 AS _1_0
              ) AS r5
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              0::"char" AS _t,
              'Whiskers' AS _0,
              NULL::"char" AS _1_t,
              NULL::text AS _1_0
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::"char" AS _t,
              NULL::text AS _0,
              0::"char" AS _1_t,
              'Belie' AS _1_0
            UNION
            ALL
            SELECT
              2::int8 AS index,
              1::"char" AS _t,
              NULL::text AS _0,
              1::"char" AS _1_t,
              NULL::text AS _1_0
          ) AS r3
      ) AS r12
    ORDER BY
      r12.index
    ---
    [
      "Hello Whiskers",
      "Come here Belie",
      "Who's a good boy?",
    ]
    "#);
}
#[test]
fn match_05() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const name = "Tom"

    func main() -> match name {
      "world" => "Hello world!",
      n => f"Hello {n}"
    }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      CASE
        WHEN (r0.value = 'world') THEN 'Hello world!'
        ELSE ('Hello ' || r0.value)
      END AS value
    FROM
      (
        SELECT
          'Tom' AS value
      ) AS r0
    ---
    "Hello Tom"
    "#);
}

#[test]
fn sql_from_00() {
    let mut client = _get_test_db_client().unwrap();

    insta::assert_snapshot!(_sql_and_output(_run_on(&mut client, r#"
    type Movie: {
      id: int32,
      title: text,
      release_year: int16,
      director_id: enum {None, Some: int32},
    }

    func main(): [Movie] -> std::sql::from("movies")
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r0._0,
      r0._1,
      r0._2,
      r0._3
    FROM
      (
        SELECT
          NULL AS index,
          id AS _0,
          title AS _1,
          release_year AS _2,
          director_id AS _3
        FROM
          movies
      ) AS r0
    ORDER BY
      r0.index
    ---
    [
      {
        id = 1,
        title = "Forrest Gump",
        release_year = 1994,
        director_id = Some(3),
      },
      {
        id = 2,
        title = "The Prestige",
        release_year = 2006,
        director_id = None,
      },
    ]
    "#);
}

#[test]
fn sql_from_01() {
    // test schema names

    let mut client = _get_test_db_client().unwrap();

    insta::assert_snapshot!(_run_on(&mut client, r#"
    type Movie: {title: text}

    func main(): [Movie] -> std::sql::from("public/movies")
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        title = "Forrest Gump",
      },
      {
        title = "The Prestige",
      },
    ]
    "#);

    insta::assert_snapshot!(_run_on(&mut client, r#"
    type Day: {name: text}

    func main(): [Day] -> std::sql::from("another/days")
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        name = "Monday",
      },
      {
        name = "Tuesday",
      },
    ]
    "#);

    insta::assert_snapshot!(_run_on(&mut client, r#"
    type Day: {name: text}

    func main(): [Day] -> std::sql::from("another/proj/days")
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        name = "Wednesday",
      },
      {
        name = "Thursday",
      },
      {
        name = "Friday",
      },
    ]
    "#);
}

#[test]
fn sql_insert_00() {
    let mut client = _get_test_db_client().unwrap();
    let mut tran = client.transaction().unwrap();

    insta::assert_snapshot!(_sql_and_output(_run_on(&mut tran, r#"
    type Movie: {
      title: text,
      release_year: int16
    }
    const two_movies: [Movie] = [
      {title = "Memento", release_year = 2000},
      {title = "Inception", release_year = 2010}
    ]

    func main(): {} -> std::sql::insert(two_movies, "movies")
    "#, lutra_bin::Value::unit())), @r"
    INSERT INTO
      movies (title, release_year)
    SELECT
      r2._0,
      r2._1
    FROM
      (
        SELECT
          0::int8 AS index,
          'Memento' AS _0,
          2000::int2 AS _1
        UNION
        ALL
        SELECT
          1::int8 AS index,
          'Inception' AS _0,
          2010::int2 AS _1
      ) AS r2
    ---
    {
    }
    ");

    insta::assert_snapshot!(_run_on(&mut tran, r#"
    type Movie: {
      title: text,
      release_year: int16
    }
    func main(): [Movie] -> (
      std::sql::from("movies")
      | std::sort(func (m) -> std::to_int64(m.release_year))
    )
    "#, lutra_bin::Value::unit()).1, @r#"
    [
      {
        title = "Forrest Gump",
        release_year = 1994,
      },
      {
        title = "Memento",
        release_year = 2000,
      },
      {
        title = "The Prestige",
        release_year = 2006,
      },
      {
        title = "Inception",
        release_year = 2010,
      },
    ]
    "#);
}

#[test]
fn group_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    const values: [int64] = [1, 1, 1, 3, 2, 3]

    func main() -> (
      values
      | std::group(func (x) -> x)
      | std::map(func (this) -> {
        value = this.key,
        sum = std::sum(this.values),
      })
    )
    "#, lutra_bin::Value::unit())), @r"
    SELECT
      r7._0,
      r7._1
    FROM
      (
        SELECT
          (ROW_NUMBER() OVER ())::int4 AS index,
          r6.value AS _0,
          COALESCE(SUM(r6.value), 0)::int8 AS _1
        FROM
          (
            SELECT
              0::int8 AS index,
              1::int8 AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              1::int8 AS value
            UNION
            ALL
            SELECT
              2::int8 AS index,
              1::int8 AS value
            UNION
            ALL
            SELECT
              3::int8 AS index,
              3::int8 AS value
            UNION
            ALL
            SELECT
              4::int8 AS index,
              2::int8 AS value
            UNION
            ALL
            SELECT
              5::int8 AS index,
              3::int8 AS value
          ) AS r6
        GROUP BY
          r6.value
      ) AS r7
    ORDER BY
      r7.index
    ---
    [
      {
        value = 1,
        sum = 3,
      },
      {
        value = 3,
        sum = 6,
      },
      {
        value = 2,
        sum = 2,
      },
    ]
    ");
}

#[test]
fn opt_00() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type OptText: enum {
      None,
      Some: text,
    }
    func main() -> {
      OptText::Some("hello"),
      OptText::None,
      std::is_some(OptText::Some("hello")),
      std::is_none(OptText::Some("hello")),
    }
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      'hello' AS _0,
      NULL::text AS _1,
      (
        SELECT
          CASE
            WHEN r0.value IS NOT NULL THEN TRUE
            ELSE FALSE
          END AS value
        FROM
          (
            SELECT
              'hello' AS value
          ) AS r0
      ) AS _2,
      (
        SELECT
          CASE
            WHEN r1.value IS NOT NULL THEN FALSE
            ELSE TRUE
          END AS value
        FROM
          (
            SELECT
              'hello' AS value
          ) AS r1
      ) AS _3
    ---
    {
      Some("hello"),
      None,
      true,
      false,
    }
    "#);
}

#[test]
fn opt_01() {
    insta::assert_snapshot!(_sql_and_output(_run(r#"
    type OptText: enum {
      None,
      Some: text,
    }
    func main() -> (
      [OptText::Some("hello"), OptText::None, OptText::Some("world")]
      | std::map(func (x) -> match x {
          .Some(x) => x,
          .None => "none",
        })
    )
    "#, lutra_bin::Value::unit())), @r#"
    SELECT
      r7.value
    FROM
      (
        SELECT
          r3.index AS index,
          (
            SELECT
              CASE
                WHEN r5.value IS NOT NULL THEN (
                  SELECT
                    r5.value
                )
                ELSE 'none'
              END AS value
            FROM
              (
                SELECT
                  r3.value AS value
              ) AS r5
          ) AS value
        FROM
          (
            SELECT
              0::int8 AS index,
              'hello' AS value
            UNION
            ALL
            SELECT
              1::int8 AS index,
              NULL::text AS value
            UNION
            ALL
            SELECT
              2::int8 AS index,
              'world' AS value
          ) AS r3
      ) AS r7
    ORDER BY
      r7.index
    ---
    [
      "hello",
      "none",
      "world",
    ]
    "#);
}

#[test]
fn std_array_unpack() {
    insta::assert_snapshot!(_run(r#"
    type PgIndex: {
      indrelid: int32,
      indisunique: bool,
      indisprimary: bool,
      indkey: text,
    }
    type PgClass: {
      oid: int32,
      relname: text,
    }
    func main() -> (
      # find pg_class row
      std::sql::from("pg_catalog/pg_class"): [PgClass]

      # for pg_class table
      | std::find(func (c) -> c.relname == "pg_class")

      # find pg_index row
      | func (c) -> (
        std::sql::from("pg_catalog/pg_index"): [PgIndex]
        | std::find(func (i) -> (
          i.indrelid == c.oid # on this table
          && !i.indisprimary && i.indisunique # that is unique, but not primary
        ))
      )
      # and unpack indkey, which is int2vec
      | func (i) -> std::sql::unpack_array(i.indkey): [int16]
    )
    "#, lutra_bin::Value::unit()).1, @r"
    [
      2,
      3,
    ]
    ");
}
