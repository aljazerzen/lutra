use lutra_bin::Value;

#[track_caller]
fn _test_typed_data_roundtrip(value: Value, ty: &str) -> String {
    let ty = lutra_frontend::_test_compile_ty(ty);

    let mut ltd_buf = Vec::new();
    lutra_typed_data::encode_typed_data(&mut ltd_buf, value.clone(), &ty).unwrap();

    let (value_decoded, ty_decoded) = lutra_typed_data::decode_typed_data(&ltd_buf).unwrap();

    assert_eq!(value, value_decoded);
    assert_eq!(ty, ty_decoded);

    pretty_hex::pretty_hex(&ltd_buf)
}

#[test]
fn test_typed_data_01() {
    insta::assert_snapshot!(_test_typed_data_roundtrip(
        Value::Tuple(vec![
            Value::Int(42),
            Value::Text("Hello world!".to_string()),
            Value::Array(vec![Value::Bool(true), Value::Bool(false)]),
        ]),
        "{int, text, [bool]}",
    ), @r#"
    Length: 480 (0x1e0) bytes
    0000:   01 11 00 00  00 01 9a 00  00 00 a6 00  00 00 26 00   ..............&.
    0010:   00 00 08 00  00 00 03 00  00 00 00 00  00 00 00 00   ................
    0020:   27 00 00 00  01 27 00 00  00 00 00 00  00 00 00 2d   '....'.........-
    0030:   00 00 00 01  2d 00 00 00  00 00 00 00  00 02 33 00   ....-.........3.
    0040:   00 00 01 4d  00 00 00 00  00 00 00 00  40 00 00 00   ...M........@...
    0050:   00 00 00 00  08 00 00 00  00 00 00 00  03 00 00 00   ................
    0060:   00 40 00 00  00 00 00 00  00 08 00 00  00 00 00 00   .@..............
    0070:   00 00 09 00  00 00 01 09  00 00 00 02  00 00 00 00   ................
    0080:   08 00 00 00  00 00 00 00  08 00 00 00  00 00 00 00   ................
    0090:   40 00 00 00  00 00 00 00  08 00 00 00  00 00 00 00   @...............
    00a0:   c0 00 00 00  00 00 00 00  08 00 00 00  00 00 00 00   ................
    00b0:   2a 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   *...............
    00c0:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    00d0:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    00e0:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    00f0:   10 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0100:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0110:   0c 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0120:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0130:   14 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0140:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0150:   02 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0160:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0170:   48 00 00 00  00 00 00 00  65 00 00 00  00 00 00 00   H.......e.......
    0180:   6c 00 00 00  00 00 00 00  6c 00 00 00  00 00 00 00   l.......l.......
    0190:   6f 00 00 00  00 00 00 00  20 00 00 00  00 00 00 00   o....... .......
    01a0:   77 00 00 00  00 00 00 00  6f 00 00 00  00 00 00 00   w.......o.......
    01b0:   72 00 00 00  00 00 00 00  6c 00 00 00  00 00 00 00   r.......l.......
    01c0:   64 00 00 00  00 00 00 00  21 00 00 00  00 00 00 00   d.......!.......
    01d0:   01 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    "#);
}

#[test]
fn test_typed_data_02() {
    insta::assert_snapshot!(_test_typed_data_roundtrip(Value::Bool(true), "bool"), @r#"
    Length: 47 (0x2f) bytes
    0000:   00 11 00 00  00 01 11 00  00 00 1d 00  00 00 01 00   ................
    0010:   00 00 02 00  00 00 00 08  00 00 00 00  00 00 00 08   ................
    0020:   00 00 00 00  00 00 00 01  00 00 00 00  00 00 00      ...............
    "#);
}
