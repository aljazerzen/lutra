#![cfg(test)]

use lutra_bin::Value;

#[track_caller]
fn _test_typed_data_roundtrip(value: Value, ty: &str) -> String {
    let ty = lutra_frontend::_test_compile_ty(ty);

    let mut ltd_buf = Vec::new();
    lutra_typed_data::encode_typed_data(&mut ltd_buf, value.clone(), &ty).unwrap();

    let (value_decoded, ty_decoded) = lutra_typed_data::decode_typed_data(&ltd_buf).unwrap();

    assert_eq!(value, value_decoded);
    assert_eq!(ty, ty_decoded);

    pretty_hex::pretty_hex(&ltd_buf)
}

#[test]
fn test_typed_data_01() {
    insta::assert_snapshot!(_test_typed_data_roundtrip(
        Value::Tuple(vec![
            Value::Int(42),
            Value::Text("Hello world!".to_string()),
            Value::Array(vec![Value::Bool(true), Value::Bool(false)]),
        ]),
        "{int, text, [bool]}",
    ), @r#"
    Length: 480 (0x1e0) bytes
    0000:   00 00 00 00  00 40 00 00  00 00 00 00  00 08 00 00   .....@..........
    0010:   00 00 00 00  00 03 00 00  00 00 40 00  00 00 00 00   ..........@.....
    0020:   00 00 08 00  00 00 00 00  00 00 02 00  00 00 00 08   ................
    0030:   00 00 00 00  00 00 00 08  00 00 00 00  00 00 00 00   ................
    0040:   15 00 00 00  01 15 00 00  00 40 00 00  00 00 00 00   .........@......
    0050:   00 08 00 00  00 00 00 00  00 00 00 00  00 00 00 5e   ...............^
    0060:   00 00 00 01  5e 00 00 00  00 00 00 00  00 00 58 00   ....^.........X.
    0070:   00 00 01 58  00 00 00 00  00 00 00 00  02 3d 00 00   ...X.........=..
    0080:   00 01 38 00  00 00 2d 00  00 00 03 00  00 00 c0 00   ..8...-.........
    0090:   00 00 00 00  00 00 08 00  00 00 00 00  00 00 48 00   ..............H.
    00a0:   00 00 00 00  00 00 65 00  00 00 00 00  00 00 6c 00   ......e.......l.
    00b0:   00 00 00 00  00 00 6c 00  00 00 00 00  00 00 6f 00   ......l.......o.
    00c0:   00 00 00 00  00 00 20 00  00 00 00 00  00 00 77 00   ...... .......w.
    00d0:   00 00 00 00  00 00 6f 00  00 00 00 00  00 00 72 00   ......o.......r.
    00e0:   00 00 00 00  00 00 6c 00  00 00 00 00  00 00 64 00   ......l.......d.
    00f0:   00 00 00 00  00 00 21 00  00 00 00 00  00 00 01 00   ......!.........
    0100:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 2a 00   ..............*.
    0110:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0120:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0130:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0140:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 16 00   ................
    0150:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0160:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 0c 00   ................
    0170:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    0180:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 12 00   ................
    0190:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    01a0:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 02 00   ................
    01b0:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
    01c0:   00 00 00 00  00 00 00 00  00 00 00 00  00 00 01 48   ...............H
    01d0:   01 00 00 01  45 01 00 00  3a 01 00 00  26 00 00 00   ....E...:...&...
    "#);
}

#[test]
fn test_typed_data_02() {
    insta::assert_snapshot!(_test_typed_data_roundtrip(Value::Bool(true), "bool"), @r#"
    Length: 47 (0x2f) bytes
    0000:   02 00 00 00  00 08 00 00  00 00 00 00  00 08 00 00   ................
    0010:   00 00 00 00  00 01 00 00  00 00 00 00  00 00 1d 00   ................
    0020:   00 00 01 1d  00 00 00 12  00 00 00 01  00 00 00      ...............
    "#);
}
