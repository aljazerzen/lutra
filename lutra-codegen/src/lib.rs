mod codegen_fn;
mod codegen_ty;

use std::fs;
use std::path::PathBuf;

use lutra_frontend::{decl, pr, CompileParams, DiscoverParams};

#[track_caller]
pub fn generate(
    project_dir: &std::path::Path,
    out_file: &std::path::Path,
    options: GenerateOptions,
) -> Vec<PathBuf> {
    // discover the project
    let source = lutra_frontend::discover(DiscoverParams {
        project_path: project_dir.into(),
    })
    .unwrap();

    // compile
    let project =
        lutra_frontend::compile(source, CompileParams {}).unwrap_or_else(|e| panic!("{e}"));

    // generate
    let mut file = fs::File::create(out_file).unwrap();
    let generated = codegen_main(&project.root_module.module, &options).unwrap();
    std::io::Write::write_all(&mut file, generated.as_bytes()).unwrap();

    // return vec of input files
    project.source.get_sources().map(|s| s.0.clone()).collect()
}

pub struct GenerateOptions {
    generate_types: bool,
    generate_encode_decode: bool,
    generate_function_traits: bool,
}

impl Default for GenerateOptions {
    fn default() -> Self {
        Self {
            generate_types: true,
            generate_encode_decode: true,
            generate_function_traits: true,
        }
    }
}

impl GenerateOptions {
    pub fn no_generate_types(mut self) -> Self {
        self.generate_types = false;
        self
    }

    pub fn no_generate_encode_decode(mut self) -> Self {
        self.generate_encode_decode = false;
        self
    }

    pub fn no_generate_function_traits(mut self) -> Self {
        self.generate_function_traits = false;
        self
    }
}

fn codegen_main(
    module: &decl::Module,
    options: &GenerateOptions,
) -> Result<String, std::fmt::Error> {
    use std::fmt::Write;

    let mut w = String::new();
    writeln!(w, "//# Generated by lutra-codegen\n")?;

    codegen_in(&mut w, module, options)?;
    Ok(w)
}

fn codegen_in(
    w: &mut impl std::fmt::Write,
    module: &decl::Module,
    options: &GenerateOptions,
) -> Result<(), std::fmt::Error> {
    // collect decls
    let mut tys = Vec::new();
    let mut functions = Vec::new();
    let mut sub_modules = Vec::new();
    for (name, decl) in &module.names {
        match &decl.kind {
            lutra_frontend::decl::DeclKind::Module(module) => {
                sub_modules.push((name, module));
            }
            lutra_frontend::decl::DeclKind::Ty(ty) => {
                tys.push((name, ty, &decl.annotations));
            }
            lutra_frontend::decl::DeclKind::Expr(expr) => {
                let ty = expr.ty.as_ref().unwrap();
                if let pr::TyKind::Function(Some(func)) = &ty.kind {
                    functions.push((name, func));
                }
            }
            _ => {}
        }
    }

    // write types
    let all_tys = if options.generate_types {
        codegen_ty::write_tys(w, &tys)?
    } else {
        vec![]
    };

    // write trait for functions
    if options.generate_function_traits {
        codegen_fn::write_functions(w, &functions)?;
    }

    // recurse into sub modules
    for (name, sub_mod) in sub_modules {
        writeln!(w, "pub mod {name} {{")?;
        codegen_in(w, sub_mod, options)?;
        writeln!(w, "}}\n")?;
    }

    // write type impls
    if options.generate_encode_decode {
        codegen_ty::write_tys_impls(w, &all_tys)?;
    }

    Ok(())
}
