mod codegen_fn;
mod codegen_ty;

use std::fs;
use std::path::PathBuf;

use lutra_frontend::{decl, pr, CompileParams, DiscoverParams};

pub fn generate_types(project_dir: &std::path::Path, out_file: &std::path::Path) -> Vec<PathBuf> {
    let source = lutra_frontend::discover(DiscoverParams {
        project_path: project_dir.into(),
    })
    .unwrap();

    let project =
        lutra_frontend::compile(source, CompileParams {}).unwrap_or_else(|e| panic!("{e}"));

    // write types
    let mut file = fs::File::create(out_file).unwrap();
    let generated = codegen_main(&project.root_module.module).unwrap();
    std::io::Write::write_all(&mut file, generated.as_bytes()).unwrap();

    // return vec of input files
    project.source.get_sources().map(|s| s.0.clone()).collect()
}

pub fn codegen_main(module: &decl::Module) -> Result<String, std::fmt::Error> {
    use std::fmt::Write;

    let mut w = String::new();
    writeln!(w, "//# Generated by lutra-codegen\n")?;

    codegen_in(&mut w, module)?;
    Ok(w)
}

fn codegen_in(w: &mut impl std::fmt::Write, module: &decl::Module) -> Result<(), std::fmt::Error> {
    // collect decls
    let mut tys = Vec::new();
    let mut functions = Vec::new();
    let mut sub_modules = Vec::new();
    for (name, decl) in &module.names {
        match &decl.kind {
            lutra_frontend::decl::DeclKind::Module(module) => {
                sub_modules.push((name, module));
            }
            lutra_frontend::decl::DeclKind::Ty(ty) => {
                tys.push((name, ty));
            }
            lutra_frontend::decl::DeclKind::Expr(expr) => {
                let ty = expr.ty.as_ref().unwrap();
                if let pr::TyKind::Function(Some(func)) = &ty.kind {
                    functions.push((name, func));
                }
            }
            _ => {}
        }
    }

    // write types
    let all_tys = codegen_ty::write_tys(w, &tys)?;

    // write trait for functions
    codegen_fn::write_functions(w, &functions)?;

    // recurse into sub modules
    for (name, sub_mod) in sub_modules {
        writeln!(w, "pub mod {name} {{")?;
        codegen_in(w, sub_mod)?;
        writeln!(w, "}}\n")?;
    }

    // write type impls
    codegen_ty::write_tys_impls(w, &all_tys)?;

    Ok(())
}
