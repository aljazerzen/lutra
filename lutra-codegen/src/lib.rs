mod codegen_encode;
mod codegen_fn;
mod codegen_ty;

use std::path::PathBuf;
use std::{collections::VecDeque, fs};

use lutra_bin::{ir, Encode};
use lutra_frontend::{decl, pr, CompileParams, DiscoverParams};

#[track_caller]
pub fn generate(
    project_dir: &std::path::Path,
    out_file: &std::path::Path,
    options: GenerateOptions,
) -> Vec<PathBuf> {
    // discover the project
    let source = lutra_frontend::discover(DiscoverParams {
        project_path: project_dir.into(),
    })
    .unwrap();

    // compile
    let project =
        lutra_frontend::compile(source, CompileParams {}).unwrap_or_else(|e| panic!("{e}"));

    // generate
    let mut file = fs::File::create(out_file).unwrap();
    let generated = codegen_main(&project.root_module.module, &options).unwrap();
    std::io::Write::write_all(&mut file, generated.as_bytes()).unwrap();

    // return vec of input files
    project.source.get_sources().map(|s| s.0.clone()).collect()
}

#[track_caller]
pub fn compile_program(
    project_dir: &std::path::Path,
    expr_path: &[&str],
    out_file: &std::path::Path,
) {
    // discover the project
    let source = lutra_frontend::discover(DiscoverParams {
        project_path: project_dir.into(),
    })
    .unwrap();

    // compile
    let project =
        lutra_frontend::compile(source, CompileParams {}).unwrap_or_else(|e| panic!("{e}"));

    // lower & bytecode
    let program = lutra_frontend::lower(&project.root_module, &pr::Path::new(expr_path));
    let program = lutra_frontend::bytecode_program(program);

    let mut buf = bytes::BytesMut::new();
    program.encode(&mut buf);

    std::fs::write(out_file, buf).unwrap();
}

#[derive(Debug, Clone)]
pub struct GenerateOptions {
    generate_types: bool,
    generate_encode_decode: bool,
    generate_function_traits: bool,

    lutra_bin_path: String,
}

impl Default for GenerateOptions {
    fn default() -> Self {
        Self {
            generate_types: true,
            generate_encode_decode: true,
            generate_function_traits: true,
            lutra_bin_path: "::lutra_bin".into(),
        }
    }
}

impl GenerateOptions {
    pub fn no_generate_types(mut self) -> Self {
        self.generate_types = false;
        self
    }

    pub fn no_generate_encode_decode(mut self) -> Self {
        self.generate_encode_decode = false;
        self
    }

    pub fn no_generate_function_traits(mut self) -> Self {
        self.generate_function_traits = false;
        self
    }

    pub fn with_lutra_bin_path(mut self, path: String) -> Self {
        self.lutra_bin_path = path;
        self
    }
}

#[derive(Debug)]
pub struct Context<'a> {
    current_module: pr::Path,

    /// Buffer for types that don't have their own Lutra decl, but need their own Rust decl.
    /// When such type ref is encountered, it is pushed into here and generated later.
    def_buffer: VecDeque<ir::Ty>,

    options: &'a GenerateOptions,
}

impl<'a> Context<'a> {
    pub fn new(module_path: pr::Path, options: &'a GenerateOptions) -> Self {
        Self {
            def_buffer: Default::default(),
            current_module: module_path,
            options,
        }
    }

    pub fn is_done(&self) -> bool {
        self.def_buffer.is_empty()
    }
}

fn codegen_main(
    module: &decl::Module,
    options: &GenerateOptions,
) -> Result<String, std::fmt::Error> {
    use std::fmt::Write;

    let mut w = String::new();
    writeln!(w, "//# Generated by lutra-codegen\n")?;

    let module_path = pr::Path::new::<String, _>(vec![]);
    codegen_in(&mut w, module, module_path, options)?;
    Ok(w)
}

fn codegen_in(
    w: &mut impl std::fmt::Write,
    module: &decl::Module,
    module_path: pr::Path,
    options: &GenerateOptions,
) -> Result<(), std::fmt::Error> {
    // collect decls
    let mut tys = Vec::new();
    let mut functions = Vec::new();
    let mut sub_modules = Vec::new();
    for (name, decl) in &module.names {
        if decl.built_in {
            continue;
        }
        match &decl.kind {
            lutra_frontend::decl::DeclKind::Module(module) => {
                sub_modules.push((name, module));
            }
            lutra_frontend::decl::DeclKind::Ty(ty) => {
                let mut ty = lutra_bin::ir::Ty::from(ty.clone());
                infer_names(name, &mut ty);

                tys.push((ty, decl.annotations.as_slice()));
            }
            lutra_frontend::decl::DeclKind::Expr(expr) => {
                let ty = expr.ty.as_ref().unwrap();
                let mut ty = lutra_bin::ir::Ty::from(ty.clone());
                infer_names(name, &mut ty);

                if let ir::TyKind::Function(func) = ty.kind {
                    functions.push((name, *func));
                }
            }
            _ => {}
        }
    }

    let mut ctx = Context::new(module_path.clone(), options);

    // write types
    let mut all_tys = if options.generate_types {
        codegen_ty::write_tys(w, tys, &mut ctx)?
    } else {
        vec![]
    };

    // write trait for functions
    if options.generate_function_traits {
        codegen_fn::write_functions(w, &functions, &mut ctx)?;

        all_tys.extend(codegen_ty::write_tys_in_buffer(w, &mut ctx)?);
    }

    // recurse into sub modules
    for (name, sub_mod) in sub_modules {
        writeln!(w, "pub mod {name} {{")?;

        let path = module_path.clone().prepend(vec![name.clone()]);
        codegen_in(w, sub_mod, path, options)?;
        writeln!(w, "}}\n")?;
    }

    // write type impls
    if options.generate_encode_decode {
        codegen_encode::write_encode_impls(w, &all_tys, &mut ctx)?;
    }

    assert!(ctx.is_done(), "{ctx:?}");

    Ok(())
}

/// Types might not have names, because they are defined inline.
/// This function traverses a type definition and generates names for all of the types.
fn infer_names(stmt_name: &str, ty: &mut ir::Ty) {
    if ty.name.is_none() {
        ty.name = Some(stmt_name.to_string());
    }

    let mut name_prefix = Vec::new();
    infer_names_re(ty, &mut name_prefix);
}

fn infer_names_re(ty: &mut ir::Ty, name_prefix: &mut Vec<String>) {
    if ty.name.is_none() {
        ty.name = Some(name_prefix.concat());
    } else {
        name_prefix.push(ty.name.clone().unwrap());
    }

    match &mut ty.kind {
        ir::TyKind::Primitive(_) | ir::TyKind::Ident(_) => {}

        ir::TyKind::Tuple(fields) => {
            for (index, field) in fields.iter_mut().enumerate() {
                let name = codegen_ty::tuple_field_name(&field.name, index);
                name_prefix.push(name.into_owned());

                infer_names_re(&mut field.ty, name_prefix);
                name_prefix.pop();
            }
        }

        ir::TyKind::Array(items_ty) => {
            name_prefix.push("Items".to_string());
            infer_names_re(items_ty, name_prefix);
            name_prefix.pop();
        }

        ir::TyKind::Enum(variants) => {
            for v in variants {
                name_prefix.push(v.name.clone());
                infer_names_re(&mut v.ty, name_prefix);
                name_prefix.pop();
            }
        }

        ir::TyKind::Function(func) => {
            for param in &mut func.params {
                infer_names_re(param, name_prefix);
            }
            infer_names_re(&mut func.body, name_prefix);
        }
    }
}
