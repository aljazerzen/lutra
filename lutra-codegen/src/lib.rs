mod codegen_encode;
mod codegen_fn;
mod codegen_program;
mod codegen_ty;
mod python;

pub use python::generate as generate_python;

use std::collections::HashMap;
use std::path::PathBuf;
use std::{collections::VecDeque, fs};

use lutra_bin::{Encode, ir};
use lutra_compiler::{CheckParams, DiscoverParams, Project};

#[track_caller]
pub fn generate(
    project_dir: &std::path::Path,
    out_file: &std::path::Path,
    options: GenerateOptions,
) -> Vec<PathBuf> {
    // tracing_subscriber::fmt::Subscriber::builder()
    //     .without_time()
    //     .with_target(false)
    //     .with_max_level(tracing::Level::DEBUG)
    //     .with_writer(std::io::stderr)
    //     .init();

    // discover the project
    let source = lutra_compiler::discover(DiscoverParams {
        project: Some(project_dir.into()),
    })
    .unwrap();

    // compile
    let project = lutra_compiler::check(source, CheckParams {}).unwrap_or_else(|e| panic!("{e}"));

    // generate
    let mut file = fs::File::create(out_file).unwrap();
    let out_dir = out_file.parent().unwrap().to_path_buf();
    let generated = codegen_main(&project, &options, out_dir).unwrap();
    std::io::Write::write_all(&mut file, generated.as_bytes()).unwrap();

    // return vec of input files
    project
        .source
        .get_sources()
        .map(|s| project.source.root.join(s.0))
        .collect()
}

#[track_caller]
pub fn generate_program_bytecode(
    project_dir: &std::path::Path,
    program: &str,
    out_file: &std::path::Path,
) {
    // discover the project
    let source = lutra_compiler::discover(DiscoverParams {
        project: Some(project_dir.into()),
    })
    .unwrap();

    // compile
    let project = lutra_compiler::check(source, CheckParams {}).unwrap_or_else(|e| panic!("{e}"));

    // lower & bytecode
    let (program, _ty) = lutra_compiler::compile(
        &project,
        program,
        None,
        lutra_compiler::ProgramFormat::BytecodeLt,
    )
    .unwrap();

    let buf = program.into_bytecode_lt().unwrap().encode();
    std::fs::write(out_file, buf).unwrap();
}

#[derive(Debug, Clone)]
pub struct GenerateOptions {
    generate_types: bool,
    generate_encode_decode: bool,
    generate_function_traits: bool,

    generate_sr_modules: Vec<String>,

    lutra_bin_path: String,
}

impl Default for GenerateOptions {
    fn default() -> Self {
        Self {
            generate_types: true,
            generate_encode_decode: true,
            generate_function_traits: true,
            generate_sr_modules: Vec::new(),
            lutra_bin_path: "::lutra_bin".into(),
        }
    }
}

impl GenerateOptions {
    /// Do not generate type definitions
    pub fn no_generate_types(mut self) -> Self {
        self.generate_types = false;
        self
    }

    /// Do not generate [lutra_bin::Encode] and [lutra_bin::Decode] implementations
    pub fn no_generate_encode_decode(mut self) -> Self {
        self.generate_encode_decode = false;
        self
    }

    /// Do not generate traits for functions
    pub fn no_generate_function_traits(mut self) -> Self {
        self.generate_function_traits = false;
        self
    }

    /// Set path to [lutra_bin] dependency
    pub fn with_lutra_bin_path(mut self, path: String) -> Self {
        self.lutra_bin_path = path;
        self
    }

    /// Generates SR programs for all functions in a module
    pub fn generate_sr_in_module(mut self, module_path: impl ToString) -> Self {
        self.generate_sr_modules.push(module_path.to_string());
        self
    }
}

#[derive(Debug)]
pub struct Context<'a> {
    current_rust_mod: Vec<String>,

    /// Buffer for types that don't have their own Lutra decl, but need their own Rust decl.
    /// When such type ref is encountered, it is pushed into here and generated later.
    def_buffer: VecDeque<ir::Ty>,

    // static env
    options: &'a GenerateOptions,
    ty_defs: &'a HashMap<ir::Path, &'a ir::Ty>,
    project: &'a Project,
    out_dir: PathBuf,
}

impl<'a> Context<'a> {
    fn is_done(&self) -> bool {
        self.def_buffer.is_empty()
    }

    #[allow(dead_code)]
    fn get_ty_mat<'t: 'a>(&'t self, ty: &'t ir::Ty) -> &'t ir::Ty {
        if let ir::TyKind::Ident(path) = &ty.kind {
            self.ty_defs.get(path).unwrap()
        } else {
            ty
        }
    }
}

fn codegen_main(
    project: &Project,
    options: &GenerateOptions,
    out_dir: PathBuf,
) -> Result<String, std::fmt::Error> {
    use std::fmt::Write;

    let module = lutra_compiler::lower_type_defs(project);
    let module = lutra_compiler::layouter::on_root_module(module);

    let ty_defs = module.iter_types_re().collect();

    let mut w = String::new();
    writeln!(w, "//# Generated by lutra-codegen\n")?;

    let mut ctx = Context {
        current_rust_mod: vec![],
        def_buffer: VecDeque::new(),

        options,
        ty_defs: &ty_defs,
        project,
        out_dir,
    };

    let module_path = vec![];
    codegen_module(&mut w, &module, module_path, &mut ctx)?;
    Ok(w)
}

fn codegen_module(
    w: &mut impl std::fmt::Write,
    module: &ir::Module,
    module_path: Vec<String>,
    ctx: &mut Context,
) -> Result<(), std::fmt::Error> {
    // collect defs
    let mut tys = Vec::new();
    let mut functions = Vec::new();
    let mut sub_modules = Vec::new();

    // iterate pr defs (which keep the order in the source)
    let root_mod = &ctx.project.root_module;
    let pr_mod = root_mod.get_submodule(&module_path).unwrap();
    for (name, pr_def) in &pr_mod.defs {
        let Some(decl) = module.decls.iter().find(|d| &d.name == name) else {
            continue;
        };

        match &decl.decl {
            ir::Decl::Module(module) => {
                sub_modules.push((name, module));
            }
            ir::Decl::Type(ty) => {
                let mut ty = ty.clone();
                infer_names(name, &mut ty);

                tys.push((ty, pr_def.annotations.as_slice()));
            }
            ir::Decl::Var(ty) => {
                let mut ty = ty.clone();
                infer_names(name, &mut ty);

                if let ir::TyKind::Function(func) = ty.kind {
                    functions.push((name, *func));
                }
            }
        }
    }

    ctx.current_rust_mod = module_path.clone();

    // write types
    let mut all_tys = if ctx.options.generate_types {
        codegen_ty::write_tys(w, tys, ctx)?
    } else {
        vec![]
    };

    // write traits for functions
    if ctx.options.generate_function_traits {
        codegen_fn::write_functions(w, &functions, ctx)?;

        all_tys.extend(codegen_ty::write_tys_in_buffer(w, ctx)?);
    }

    // write traits for functions
    let module_path_str = module_path.as_slice().join("::");
    if ctx.options.generate_sr_modules.contains(&module_path_str) {
        codegen_program::write_sr_programs(w, &functions, ctx)?;

        all_tys.extend(codegen_ty::write_tys_in_buffer(w, ctx)?);
    }

    // recurse into sub modules
    for (name, sub_mod) in sub_modules {
        writeln!(w, "pub mod {name} {{")?;

        let mut path = module_path.clone();
        path.push(name.clone());
        codegen_module(w, sub_mod, path, ctx)?;
        writeln!(w, "}}\n")?;
    }

    // write encode/decode impls
    ctx.current_rust_mod = module_path.clone();
    if ctx.options.generate_encode_decode {
        codegen_encode::write_encode_impls(w, &all_tys, ctx)?;
    }

    assert!(ctx.is_done(), "{ctx:?}");

    Ok(())
}

/// Types might not have names, because they are defined inline.
/// This function traverses a type definition and generates names for all of the types.
fn infer_names(def_name: &str, ty: &mut ir::Ty) {
    if ty.name.is_none() {
        ty.name = Some(def_name.to_string());
    }

    let mut name_prefix = Vec::new();
    infer_names_re(ty, &mut name_prefix);
}

fn infer_names_of_program_ty(ty: &mut lutra_bin::rr::ProgramType, program_name: &str) {
    let mut name_camel = vec![snake_to_sentence(program_name)];
    {
        name_camel.push("Input".into());
        infer_names_re(&mut ty.input, &mut name_camel);
        name_camel.pop();
    }
    {
        name_camel.push("Output".into());
        infer_names_re(&mut ty.output, &mut name_camel);
        name_camel.pop();
    }
}

fn infer_names_re(ty: &mut ir::Ty, name_prefix: &mut Vec<String>) {
    if ty.name.is_none() {
        ty.name = Some(name_prefix.concat());
    } else {
        name_prefix.push(ty.name.clone().unwrap());
    }

    match &mut ty.kind {
        ir::TyKind::Primitive(_) | ir::TyKind::Ident(_) => {}

        ir::TyKind::Tuple(fields) => {
            for (index, field) in fields.iter_mut().enumerate() {
                let name = codegen_ty::tuple_field_name(&field.name, index);
                name_prefix.push(name.into_owned());

                infer_names_re(&mut field.ty, name_prefix);
                name_prefix.pop();
            }
        }

        ir::TyKind::Array(items_ty) => {
            name_prefix.push("Items".to_string());
            infer_names_re(items_ty, name_prefix);
            name_prefix.pop();
        }

        ir::TyKind::Enum(variants) => {
            for v in variants {
                name_prefix.push(v.name.clone());
                infer_names_re(&mut v.ty, name_prefix);
                name_prefix.pop();
            }
        }

        ir::TyKind::Function(func) => {
            for param in &mut func.params {
                infer_names_re(param, name_prefix);
            }
            infer_names_re(&mut func.body, name_prefix);
        }
    }
}

fn camel_to_snake(camel: &str) -> String {
    let mut snake = String::with_capacity(camel.len());
    for current in camel.chars() {
        if current.is_uppercase() {
            if !snake.is_empty() && snake.ends_with('_') {
                snake.push('_');
            }
            snake.push(current.to_lowercase().next().unwrap());
        } else {
            snake.push(current);
        }
    }

    snake
}

fn snake_to_sentence(snake: &str) -> String {
    let mut sentence = String::with_capacity(snake.len());
    let mut next_upper = true;
    for current in snake.chars() {
        if current == '_' {
            next_upper = true;
            continue;
        }

        if next_upper {
            sentence.push(current.to_uppercase().next().unwrap());
        } else {
            sentence.push(current.to_lowercase().next().unwrap());
        }
        next_upper = false;
    }

    sentence
}
