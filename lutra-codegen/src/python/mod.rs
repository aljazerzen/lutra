use std::collections::{HashMap, HashSet, VecDeque};
use std::fs;
use std::path::PathBuf;
use std::{borrow::Cow, fmt::Write};

use lutra_bin::{Encode, ir, layout};
use lutra_compiler::{CompileParams, DiscoverParams, Project, pr};

#[track_caller]
pub fn generate(
    project_dir: &std::path::Path,
    out_file: &std::path::Path,
    options: super::GenerateOptions,
) -> Vec<PathBuf> {
    // tracing_subscriber::fmt::Subscriber::builder()
    // .without_time()
    // .with_max_level(tracing::Level::TRACE)
    // .try_init()
    // .ok();

    // discover the project
    let source = lutra_compiler::discover(DiscoverParams {
        project_path: project_dir.into(),
    })
    .unwrap();

    // compile
    let project =
        lutra_compiler::compile(source, CompileParams {}).unwrap_or_else(|e| panic!("{e}"));

    // generate
    let mut file = fs::File::create(out_file).unwrap();
    let out_dir = out_file.parent().unwrap().to_path_buf();
    let generated = codegen_main(&project, out_dir, &options).unwrap();
    std::io::Write::write_all(&mut file, generated.as_bytes()).unwrap();

    // return vec of input files
    project
        .source
        .get_sources()
        .filter(|s| s.0.to_str().is_none_or(|x| x != "std.lt"))
        .map(|s| s.0.clone())
        .collect()
}

#[derive(Debug)]
pub struct Context<'a> {
    current_rust_mod: Vec<String>,

    /// Buffer for types that don't have their own Lutra decl, but need their own Rust decl.
    /// When such type ref is encountered, it is pushed into here and generated later.
    def_buffer: VecDeque<ir::Ty>,

    tys_written: HashSet<String>,

    // static env
    options: &'a super::GenerateOptions,
    ty_defs: &'a HashMap<ir::Path, &'a ir::Ty>,
    project: &'a Project,
    #[allow(dead_code)]
    out_dir: PathBuf,
}

impl<'a> Context<'a> {
    fn is_done(&self) -> bool {
        self.def_buffer.is_empty()
    }

    #[allow(dead_code)]
    fn get_ty_mat<'t: 'a>(&'t self, ty: &'t ir::Ty) -> &'t ir::Ty {
        if let ir::TyKind::Ident(path) = &ty.kind {
            self.ty_defs.get(path).unwrap()
        } else {
            ty
        }
    }
}

fn codegen_main(
    project: &Project,
    out_dir: PathBuf,
    options: &super::GenerateOptions,
) -> Result<String, std::fmt::Error> {
    use std::fmt::Write;

    let module = lutra_compiler::lower_type_defs(&project.root_module);
    let module = lutra_compiler::layouter::on_root_module(module);

    let ty_defs = module.iter_types_re().collect();

    let mut w = String::new();
    writeln!(w, "# Generated by lutra-codegen\n")?;
    writeln!(w, "import base64  # noqa: F401")?;
    writeln!(w, "import dataclasses  # noqa: F401")?;
    writeln!(w, "import functools  # noqa: F401")?;
    writeln!(w, "import typing  # noqa: F401")?;
    writeln!(w)?;
    writeln!(w, "import lutra_bin")?;
    writeln!(w)?;

    let mut ctx = Context {
        current_rust_mod: vec![],
        def_buffer: VecDeque::new(),
        tys_written: Default::default(),

        options,
        ty_defs: &ty_defs,
        project,
        out_dir,
    };

    let module_path = vec![];
    codegen_module(&mut w, &module, module_path, &mut ctx)?;
    Ok(w)
}

fn codegen_module(
    w: &mut impl std::fmt::Write,
    module: &ir::Module,
    module_path: Vec<String>,
    ctx: &mut Context,
) -> Result<(), std::fmt::Error> {
    // collect decls
    let mut tys = Vec::new();
    let mut functions = Vec::new();
    let mut sub_modules = Vec::new();

    // iterate pr decls (which keep the order in the source)
    let root_mod = &ctx.project.root_module;
    let pr_mod = root_mod.module.get_submodule(&module_path).unwrap();
    for (name, pr_decl) in &pr_mod.names {
        let Some(decl) = module.decls.iter().find(|d| &d.name == name) else {
            continue;
        };

        match &decl.decl {
            ir::Decl::Module(module) => {
                sub_modules.push((name, module));
            }
            ir::Decl::Type(ty) => {
                let mut ty = ty.clone();
                super::infer_names(name, &mut ty);

                tys.push((ty, pr_decl.annotations.as_slice()));
            }
            ir::Decl::Var(ty) => {
                let mut ty = ty.clone();
                super::infer_names(name, &mut ty);

                if let ir::TyKind::Function(func) = ty.kind {
                    functions.push((name, *func));
                }
            }
        }
    }

    ctx.current_rust_mod = module_path.clone();

    // write types
    let mut tys = write_tys(w, tys, ctx)?;

    // write traits for functions
    let module_path_str = module_path.as_slice().join("::");
    if ctx.options.generate_sr_modules.contains(&module_path_str) {
        write_sr_programs(w, &functions, ctx)?;

        tys.extend(write_tys_in_buffer(w, ctx)?);
    }

    // recurse into sub modules
    for (name, sub_mod) in sub_modules {
        writeln!(w, "pub mod {name} {{")?;

        let mut path = module_path.clone();
        path.push(name.clone());
        codegen_module(w, sub_mod, path, ctx)?;
        writeln!(w, "}}\n")?;
    }

    // write codecs
    for ty in &tys {
        write_ty_def_codec(w, ty, ctx)?;
    }

    assert!(ctx.is_done(), "{ctx:?}");

    Ok(())
}

pub fn write_tys(
    w: &mut impl Write,
    tys: Vec<(ir::Ty, &[pr::Annotation])>,
    ctx: &mut Context,
) -> Result<Vec<ir::Ty>, std::fmt::Error> {
    let mut all_tys = Vec::new();

    for (ty, annotations) in tys {
        write_ty_def(w, &ty, annotations, ctx)?;
        all_tys.push(ty);

        all_tys.extend(write_tys_in_buffer(w, ctx)?);
    }
    Ok(all_tys)
}

pub fn write_tys_in_buffer(
    w: &mut impl Write,
    ctx: &mut Context<'_>,
) -> Result<Vec<ir::Ty>, std::fmt::Error> {
    let mut all_tys = Vec::new();
    while let Some(ty) = ctx.def_buffer.pop_front() {
        if ctx.tys_written.contains(ty.name.as_ref().unwrap()) {
            continue;
        }
        let annotations = vec![];
        write_ty_def(w, &ty, &annotations, ctx)?;

        all_tys.push(ty);
    }
    Ok(all_tys)
}

/// Generates a type definition, implementing Encodable
#[rustfmt::skip::macros(writeln)]
#[rustfmt::skip::macros(write)]
pub fn write_ty_def(
    w: &mut impl Write,
    ty: &ir::Ty,
    _annotations: &[pr::Annotation],
    ctx: &mut Context,
) -> Result<(), std::fmt::Error> {
    let name = ty.name.as_ref().unwrap();
    let codec_name = format!("{name}Codec");

    writeln!(w)?;

    match &ty.kind {
        ir::TyKind::Primitive(_) | ir::TyKind::Array(_) | ir::TyKind::Tuple(_) => {
            writeln!(w, "@dataclasses.dataclass")?;
        }

        ir::TyKind::Enum(_) => {
            writeln!(w, "@dataclasses.dataclass(kw_only=True, repr=False)")?;
        }

        _ => unimplemented!(),
    }

    writeln!(w, "class {name}(lutra_bin.Encodable):")?;
    match &ty.kind {
        ir::TyKind::Primitive(_) | ir::TyKind::Array(_) => {
            writeln!(w, "    value: {}", ty_ref(ty, ctx))?;
        }

        ir::TyKind::Tuple(fields) => {
            // fields definitions
            for (index, field) in fields.iter().enumerate() {
                let name = tuple_field_name(&field.name, index);

                writeln!(w, "    {name}: {}", ty_ref(&field.ty, ctx))?;
            }
        }

        ir::TyKind::Enum(variants) => {
            // variant definitions
            for variant in variants {
                let name = camel_to_snake(&variant.name);

                let ty = if variant.ty.is_unit() {
                    Cow::Borrowed("typing.Literal[True] | None")
                } else {
                    let ty = ty_ref(&variant.ty, ctx);
                    if ty.contains('\'') {
                        format!("typing.Optional[{ty}]").into()
                    } else {
                        format!("{ty} | None").into()
                    }
                };

                writeln!(w, "    {name}: {ty} = None")?;
            }

            writeln!(w)?;
            writeln!(w, "    def __repr__(self) -> str:")?;
            for variant in variants {
                let variant_name = camel_to_snake(&variant.name);
                writeln!(w, "        if self.{variant_name} is not None:")?;

                write!(w, r"            return ")?;
                if variant.ty.is_unit() {
                    writeln!(w, r#""{name}({variant_name})""#)?;
                } else {
                    writeln!(w, r#"f"{name}({variant_name}={{self.{variant_name}!r}})""#)?;
                }
            }
        }

        _ => unimplemented!(),
    }
    writeln!(w)?;
    writeln!(w, "    @classmethod")?;
    writeln!(w, "    def codec(cls) -> '{codec_name}':")?;
    writeln!(w, "        return {codec_name}()")?;
    writeln!(w)?;

    ctx.tys_written.insert(name.clone());

    Ok(())
}

/// Generates a code impl for a type
#[rustfmt::skip::macros(writeln)]
#[rustfmt::skip::macros(write)]
pub fn write_ty_def_codec(
    w: &mut impl Write,
    ty: &ir::Ty,
    ctx: &mut Context,
) -> Result<(), std::fmt::Error> {
    let name = ty.name.as_ref().unwrap();
    let codec_name = format!("{name}Codec");

    writeln!(w)?;
    writeln!(w, "class {codec_name}:")?;

    match &ty.kind {
        ir::TyKind::Enum(variants) => {
            // for enums, we init the EnumCodecHelper
            let enum_format = lutra_bin::layout::enum_format(variants);
            let mut buf = bytes::BytesMut::new();
            enum_format.encode(&mut buf);
            let format_base85 = base85::encode(&buf);
            writeln!(w, "    helper = lutra_bin.EnumCodecHelper(")?;
            writeln!(w, "        base64.b85decode(b'{format_base85}'),")?;
            writeln!(w, "    )")?;
        }
        _ => {}
    }

    let head_bytes = ty.layout.as_ref().unwrap().head_size.div_ceil(8);
    writeln!(w, "    def head_bytes(self) -> int:")?;
    writeln!(w, "        return {head_bytes}")?;

    match &ty.kind {
        ir::TyKind::Primitive(_) | ir::TyKind::Array(_) => {
            writeln!(w, "    def decode(self, buf: bytes) -> {name}:")?;
            writeln!(w, "        return {name}({}.decode(buf))", ty_codec(ty, ctx))?;
            writeln!(w, "    def encode_head(self, obj: {name}, buf: lutra_bin.BytesMut) -> typing.Any:")?;
            writeln!(w, "        return {}.encode_head(obj.value, buf)", ty_codec(ty, ctx))?;
            writeln!(w, "    def encode_body(self, obj: {name}, residual: typing.Any, buf: lutra_bin.BytesMut) -> typing.Any:")?;
            writeln!(w, "        return {}.encode_body(obj.value, residual, buf)", ty_codec(ty, ctx))?;
        }

        ir::TyKind::Tuple(fields) => {
            // decode
            writeln!(w)?;
            writeln!(w, "    def decode(self, buf: bytes) -> {name}:")?;
            writeln!(w, "        buf = memoryview(buf)")?;

            let offsets = layout::tuple_field_offsets(ty);
            for (index, field) in fields.iter().enumerate() {
                let buf = format!("buf[{}:]", offsets[index]);
                writeln!(w, "        f{index} = {}", ty_decode(&field.ty, &buf, ctx))?;
            }
            write!(w, "        return {name}(")?;
            for (index, _) in fields.iter().enumerate() {
                write!(w, "f{index}, ")?;
            }
            writeln!(w, ")")?;

            // encode_head
            writeln!(w)?;
            writeln!(w, "    def encode_head(self, obj: {name}, buf: lutra_bin.BytesMut) -> typing.Any:")?;
            writeln!(w, "        return (")?;
            for (index, field) in fields.iter().enumerate() {
                let name = tuple_field_name(&field.name, index);
                let val_ref = format!("obj.{name}");
                write!(w, "            ",)?;
                writeln!(w, "{}.encode_head({val_ref}, buf),", ty_codec(&field.ty, ctx))?;
            }
            writeln!(w, "        )")?;

            // encode_body
            writeln!(w)?;
            writeln!(w, "    def encode_body(self, obj: {name}, residuals: typing.Any, buf: lutra_bin.BytesMut) -> typing.Any:")?;
            for (index, field) in fields.iter().enumerate() {
                let name = tuple_field_name(&field.name, index);
                let val_ref = format!("obj.{name}");
                let res_ref = format!("residuals[{index}]");

                let encode_body = ty_encode_body(&field.ty, &val_ref, &res_ref, ctx);
                if !encode_body.is_empty() {
                    writeln!(w, "        {encode_body}")?;
                }
            }
        }

        ir::TyKind::Enum(variants) => {
            // decode
            let head = lutra_bin::layout::enum_head_format(variants);

            writeln!(w)?;
            writeln!(w, "    def decode(self, buf: bytes) -> {name}:")?;
            writeln!(w, "        tag, inner_offset = self.helper.decode_head(buf)")?;
            for (tag, variant) in variants.iter().enumerate() {
                let variant_name = camel_to_snake(&variant.name);
                writeln!(w, "        if tag == {tag}:")?;

                if variant.ty.is_unit() {
                    writeln!(w, "            return {name}({variant_name}=True)")?;
                } else {
                    writeln!(w, "            return {name}({variant_name}={}.decode(buf[inner_offset:]))", ty_codec(&variant.ty, ctx))?;
                }
            }
            writeln!(w, "        raise AssertionError()")?;

            // encode_head
            writeln!(w)?;
            writeln!(w, "    def encode_head(self, obj: {name}, buf: lutra_bin.BytesMut) -> typing.Any:")?;
            writeln!(w, "        tag: int")?;
            writeln!(w, "        res: typing.Any")?;
            for (tag, variant) in variants.iter().enumerate() {
                let variant_name = camel_to_snake(&variant.name);
                writeln!(w, "        if obj.{variant_name} is not None:")?;
                writeln!(w, "            tag = {tag}")?;
                writeln!(w, "            res = self.helper.encode_head_tag(tag, buf)")?;
                if !head.has_ptr && !variant.ty.is_unit() {
                    writeln!(w, "            res = {}.encode_head(obj.{variant_name}, buf)", ty_codec(&variant.ty, ctx))?;
                }
            }
            writeln!(w, "        self.helper.encode_head_padding(tag, buf)")?;
            writeln!(w, "        return res")?;

            // encode_body
            writeln!(w)?;
            writeln!(w, "    def encode_body(self, obj: {name}, residual: typing.Any, buf: lutra_bin.BytesMut) -> typing.Any:")?;
            if head.has_ptr {
                writeln!(w, "        self.helper.encode_body_ptr(residual, buf)")?;
                for variant in variants {
                    if variant.ty.is_unit() {
                        continue;
                    }

                    let variant_name = camel_to_snake(&variant.name);
                    writeln!(w, "        if obj.{variant_name} is not None:")?;
                    writeln!(w, "            r = {}.encode_head(obj.{variant_name}, buf)", ty_codec(&variant.ty, ctx))?;
                    writeln!(w, "            {}.encode_body(obj.{variant_name}, r, buf)", ty_codec(&variant.ty, ctx))?;
                }
            } else {
                writeln!(w, "        if residual is None:")?;
                writeln!(w, "            return")?;
                for variant in variants {
                    if variant.ty.is_unit() {
                        continue;
                    }

                    let variant_name = camel_to_snake(&variant.name);
                    writeln!(w, "        if obj.{variant_name} is not None:")?;
                    writeln!(w, "            {}.encode_body(obj.{variant_name}, residual, buf)", ty_codec(&variant.ty, ctx))?;
                }
            }
        }

        _ => unimplemented!(),
    }
    writeln!(w)?;

    Ok(())
}

fn tuple_field_name(name: &Option<String>, index: usize) -> Cow<'_, str> {
    (name.as_ref())
        .map(|x| Cow::Borrowed(x.as_str()))
        .unwrap_or_else(|| format!("field{index}").into())
}

/// Reference to a python type
fn ty_ref(ty: &ir::Ty, ctx: &mut Context) -> Cow<'static, str> {
    match &ty.kind {
        ir::TyKind::Primitive(ir::TyPrimitive::bool) => "bool".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int8) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int16) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int32) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int64) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint8) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint16) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint32) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint64) => "int".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::float32) => "float".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::float64) => "float".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::text) => "str".into(),

        ir::TyKind::Array(items_ty) => format!("list[{}]", ty_ref(items_ty, ctx)).into(),

        ir::TyKind::Ident(ident) => {
            let name = ident.0.last().unwrap().clone();
            if ctx.tys_written.contains(&name) {
                name.into()
            } else {
                format!("'{name}'").into()
            }
        }

        ir::TyKind::Tuple(_) | ir::TyKind::Enum(_) => {
            let name = ty
                .name
                .clone()
                .unwrap_or_else(|| panic!("no name for {ty:?}"));

            if ctx.tys_written.contains(&name) {
                name.into()
            } else {
                ctx.def_buffer.push_back(ty.clone());
                format!("'{name}'").into()
            }
        }

        _ => unimplemented!(),
    }
}

// Construct Codec class that can encode/decode the type
fn ty_codec(ty: &ir::Ty, ctx: &mut Context) -> Cow<'static, str> {
    match &ty.kind {
        ir::TyKind::Primitive(ir::TyPrimitive::bool) => "lutra_bin.BoolCodec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int8) => "lutra_bin.Int8Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int16) => "lutra_bin.Int16Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int32) => "lutra_bin.Int32Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::int64) => "lutra_bin.Int64Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint8) => "lutra_bin.Uint8Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint16) => "lutra_bin.Uint16Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint32) => "lutra_bin.Uint32Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::uint64) => "lutra_bin.Uint64Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::float32) => "lutra_bin.Float32Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::float64) => "lutra_bin.Float64Codec()".into(),
        ir::TyKind::Primitive(ir::TyPrimitive::text) => "lutra_bin.TextCodec()".into(),

        ir::TyKind::Array(item_ty) => {
            format!("lutra_bin.ArrayCodec({})", ty_codec(item_ty, ctx)).into()
        }

        ir::TyKind::Ident(_) | ir::TyKind::Tuple(_) | ir::TyKind::Enum(_) => {
            format!("{}.codec()", ty_ref(ty, ctx)).into()
        }

        _ => unimplemented!(),
    }
}

fn ty_decode(ty: &ir::Ty, buf_ref: &str, ctx: &mut Context) -> String {
    match &ty.kind {
        ir::TyKind::Primitive(_) | ir::TyKind::Array(_) => {
            // these types are decoded into native (primitive) types, so they don't implement Encodable
            format!("{}.decode({buf_ref})", ty_codec(ty, ctx))
        }

        ir::TyKind::Ident(_) | ir::TyKind::Tuple(_) | ir::TyKind::Enum(_) => {
            format!("{}.decode({buf_ref})", ty_codec(ty, ctx))
        }

        _ => unimplemented!(),
    }
}

fn ty_encode_body(ty: &ir::Ty, val_ref: &str, residual_ref: &str, ctx: &mut Context) -> String {
    let codec = ty_codec(ty, ctx);
    format!("{codec}.encode_body({val_ref}, {residual_ref}, buf)")
}

fn write_sr_programs(
    w: &mut impl Write,
    functions: &[(&String, ir::TyFunction)],
    ctx: &mut Context,
) -> Result<(), std::fmt::Error> {
    if functions.is_empty() {
        return Ok(());
    }

    for (name, func) in functions {
        let mut fq_path = pr::Path::new(&ctx.current_rust_mod);
        fq_path.push((*name).clone());

        // compile
        let program = lutra_compiler::compile_to_sql(ctx.project, &fq_path);

        // encode to base85
        let mut buf = bytes::BytesMut::new();
        program.encode(&mut buf);
        let program_base85 = base85::encode(&buf);

        writeln!(w)?;
        writeln!(w, "@functools.cache")?;
        writeln!(w, "def {name}() -> lutra_bin.TypedProgram:")?;
        writeln!(w, "    return lutra_bin.TypedProgram(")?;
        writeln!(w, "        base64.b85decode(b'{program_base85}'),")?;
        writeln!(w, "        type(()),")?;
        writeln!(w, "        {},", ty_codec(&func.body, ctx))?;
        writeln!(w, "    )")?;
    }

    Ok(())
}

fn camel_to_snake(camel: &str) -> String {
    let mut snake = String::with_capacity(camel.len());
    let mut chars = camel.chars().peekable();

    while let Some(current) = chars.next() {
        if current.is_uppercase() {
            if !snake.is_empty() && snake.chars().last().unwrap() != '_' {
                snake.push('_');
            }
            snake.push(current.to_lowercase().next().unwrap());
        } else {
            snake.push(current);
        }
    }

    snake
}
