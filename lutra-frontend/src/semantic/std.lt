# Operators

let mul: func (left: int, right: int): int
let div: func (left: int, right: int): int
let mod: func (left: int, right: int): int
let add: func (left: int, right: int): int
let sub: func (left: int, right: int): int
let neg: func (x: int): int

let eq: func (left: int, right: int): bool
let ne: func (left: int, right: int): bool

let gt: func (left: int, right: int): bool
let lt: func (left: int, right: int): bool
let gte: func (left: int, right: int): bool
let lte: func (left: int, right: int): bool

let and: func (left: bool, right: bool): bool
let or: func (left: bool, right: bool): bool
let not: func (expr: bool): bool

let regex_search: func (text: text, pattern: text): bool


# Array functions

let index: func <T> (array: [T], position: int): T

let map: func <I, O> (
  array: [I],
  mapper: func (I): O,
): [O]

let filter: func <T> (
  array: [T],
  condition: func (T): bool,
): [T]

let slice: func <T> (
  array: [T],
  start: int64,
  end: int64,
): [T]

let sort: func <I> (
  array: [I],
  key: func (I): int,
): [I]

let to_columnar: func ( # <I: {i1 = I1}>
  array: [{int, int}]
): {[int], [int]}

let from_columnar: func ( # <I: {i1 = [I1]}>
  columnar: {[int], [int]}
): [{int, int}]

let map_columnar = func ( # <I: {i1 = I1}, O: {o1 = O1}>
  array: [{int, int}],
  mapper: func ({[int], [int]}): {[int], [int]},
): [{int, int}] -> (
  array | to_columnar | mapper | from_columnar
)

let aggregate = func ( # <I: {i1 = I1}, O>
  array: [{int, int}],
  mapper: func ({[int], [int]}): {int, int},
): {int, int} -> (
  array | to_columnar | mapper
)

# let join = func <A, B> (
#   with: [B],
#   condition: bool,
#   side: text,
#   tbl: [A],
# ): [{A, B}]
# 
# let group = func <I, B, PO> (
#   by: B,
#   pipeline: func [I - B] -> [PO],
#   tbl: [I],
# ): [{B, ..PO}]
# 
# let append = func (bottom, top)

# Aggregation functions

let min: func (column: [int]): int

let max: func (column: [int]): int

let sum: func (column: [int]): int

let count: func (column: [int]):int

let average: func (column: [int]): float

let all: func (column: [bool]): bool

let any: func (column: [bool]): bool

let contains: func (value: [int], pattern: int): bool

let join: func (column: [text], separator: text): text

# Window functions

let lag: func (column: [int], offset: int): [int]
let lead: func (column: [int], offset: int): [int]
let row_number: func (column: [int]): [int]

## Mathematical functions
module math {
  let abs: func (val: int): int
  let floor: func (val: int): int
  let ceil: func (val: int): int
  let pi: float
  let exp: func (val: int): int
  let ln: func (val: int): int
  let log10: func (val: int): int
  let log: func (base: int, val: int): int
  let sqrt: func (val: int): int
  let degrees: func (val: int): int
  let radians: func (val: int): int
  let cos: func (val: int): int
  let acos: func (val: int): int
  let sin: func (val: int): int
  let asin: func (val: int): int
  let tan: func (val: int): int
  let atan: func (val: int): int
  let pow: func (val: int, exponent: int): int
  let round: func (val: int, n_digits: int): int
}

## Text functions
module text_ops {
  let lower: func (value: text): text
  let upper: func (value: text): text

  let ltrim: func (value: text): text
  let rtrim: func (value: text): text
  let trim: func (value: text): text

  let length: func (value: text): uint32

  let substring: func (value: text, offset: int, length: int): text
  let replace: func (value: text, pattern: text, replacement: text): text

  let starts_with: func (value: text, prefix: text): bool
  let contains: func (value: text, substr: text): bool
  let ends_with: func (value: text, suffix: text): bool
}
