use crate::ir::decl::DeclKind;
use crate::ir::pl::*;
use crate::pr::{Ty, TyKind};
use crate::semantic::NS_STD;
use crate::Result;

impl super::Resolver<'_> {
    /// Entry point to the resolver.
    /// fq_ident must point to an unresolved declaration.
    pub fn resolve_decl(&mut self, fq_ident: Path) -> Result<()> {
        if !fq_ident.starts_with_part(NS_STD) {
            log::debug!("resolving decl {fq_ident}");
        }

        // take decl out of the module
        let mut decl = {
            let module = self.root_mod.module.get_submodule_mut(fq_ident.path());
            module.unwrap().names.remove(fq_ident.name()).unwrap()
        };
        let stmt = decl.kind.into_unresolved().unwrap();
        self.debug_current_decl = fq_ident.clone();

        // resolve
        match stmt {
            StmtKind::ModuleDef(_) => {
                unreachable!("module def cannot be unresolved at this point")
                // it should have been converted into Module in resolve_decls::init_module_tree
            }
            StmtKind::VarDef(var_def) => {
                let def = self.fold_var_def(var_def)?;
                let expected_ty = def.ty;

                decl.kind = match def.value {
                    Some(mut def_value) => {
                        // var value is provided

                        // validate type
                        if expected_ty.is_some() {
                            let who = || Some(fq_ident.name().to_string());
                            self.validate_expr_type(&mut def_value, expected_ty.as_ref(), &who)?;
                        }

                        // finalize global generics
                        // if let Some(mapping) = self.finalize_global_generics() {
                        //     let ty = def_value.ty.unwrap();
                        //     def_value.ty = Some(TypeReplacer::on_ty(ty, mapping));
                        // }

                        DeclKind::Expr(def_value)
                    }
                    None => {
                        // var value is not provided: treat this var as a param
                        let mut expr =
                            Box::new(Expr::new(ExprKind::Param(fq_ident.name().to_string())));
                        expr.ty = expected_ty;
                        DeclKind::Expr(expr)
                    }
                };
            }
            StmtKind::TypeDef(ty_def) => {
                let value = if let Some(value) = ty_def.value {
                    value
                } else {
                    Ty::new(TyKind::Tuple(vec![]))
                };

                let mut ty = fold_type_opt(self, Some(value))?.unwrap();
                ty.name = Some(fq_ident.name().to_string());

                decl.kind = DeclKind::Ty(ty);
            }
            StmtKind::ImportDef(target) => {
                decl.kind = DeclKind::Import(target.name);
            }
        };

        // put decl back in
        {
            let module = self.root_mod.module.get_submodule_mut(fq_ident.path());
            module
                .unwrap()
                .names
                .insert(fq_ident.name().to_string(), decl);
        }
        Ok(())
    }
}
